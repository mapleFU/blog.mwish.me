<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="概念介绍Arrow 包含着一些对应的 Runtime 类型的语义，可以执行一些计算相关的功能，它的上层可以是 Python 脚本直接调用 Arrow Compute，也可以是 Substrait Plan 调用 Acero。 简单来说，Arrow 这些计算可以包括 Compute 层和 Acero 层：  Compute: (执行单元) Datum, Expression, Function 和">
<meta property="og:type" content="article">
<meta property="og:title" content="Arrow Compute: CallFunction and Add">
<meta property="og:url" content="http://blog.mwish.me/2023/05/27/Arrow-Compute/index.html">
<meta property="og:site_name" content="风空之岛">
<meta property="og:description" content="概念介绍Arrow 包含着一些对应的 Runtime 类型的语义，可以执行一些计算相关的功能，它的上层可以是 Python 脚本直接调用 Arrow Compute，也可以是 Substrait Plan 调用 Acero。 简单来说，Arrow 这些计算可以包括 Compute 层和 Acero 层：  Compute: (执行单元) Datum, Expression, Function 和">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-05-26T16:45:00.000Z">
<meta property="article:modified_time" content="2023-05-26T16:47:17.010Z">
<meta property="article:author" content="mwish">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/logo.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico">
        
      
    
    <!-- title -->
    <title>Arrow Compute: CallFunction and Add</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/06/01/Arrow-Data-System/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/05/04/Type-and-Array-in-Columnar-System/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2023/05/27/Arrow-Compute/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&text=Arrow Compute: CallFunction and Add"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&title=Arrow Compute: CallFunction and Add"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&is_video=false&description=Arrow Compute: CallFunction and Add"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Arrow Compute: CallFunction and Add&body=Check out this article: http://blog.mwish.me/2023/05/27/Arrow-Compute/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&title=Arrow Compute: CallFunction and Add"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&title=Arrow Compute: CallFunction and Add"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&title=Arrow Compute: CallFunction and Add"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&title=Arrow Compute: CallFunction and Add"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&name=Arrow Compute: CallFunction and Add&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2023/05/27/Arrow-Compute/&t=Arrow Compute: CallFunction and Add"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">概念介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-CallFunction-%E5%92%8C-%E2%80%9Cadd%E2%80%9D-%E7%9C%8B%E8%B5%B7"><span class="toc-number">2.</span> <span class="toc-text">从 CallFunction 和 “add” 看起</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FunctionRegistry"><span class="toc-number">2.0.1.</span> <span class="toc-text">FunctionRegistry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function"><span class="toc-number">2.0.2.</span> <span class="toc-text">Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kernel-%E6%89%A7%E8%A1%8C%E5%99%A8%E5%92%8C%E9%80%BB%E8%BE%91%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">2.0.3.</span> <span class="toc-text">Kernel 执行器和逻辑的生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kernel-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D"><span class="toc-number">2.0.4.</span> <span class="toc-text">Kernel 的类型匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Arrow Compute: CallFunction and Add
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">mwish</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-05-26T16:45:00.000Z" itemprop="datePublished">2023-05-27</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>Arrow 包含着一些对应的 Runtime 类型的语义，可以执行一些计算相关的功能，它的上层可以是 Python 脚本直接调用 Arrow Compute，也可以是 Substrait Plan 调用 Acero。</p>
<p>简单来说，Arrow 这些计算可以包括 Compute 层和 Acero 层：</p>
<ol>
<li>Compute: (执行单元) Datum, Expression, Function 和 Function 层面的执行( Kernel, FunctionExecutor, KernelExecutor)</li>
<li>Acero: Push-Based Execution Model, ExecBatch, 调度（可能会用到 dataset 层的 api 来访问数据）</li>
</ol>
<p><strong>Datum</strong>: 一个泛用类型，可以包装 {scalar, array, chunked array, record batch, table}.  操作的输入和输出通常都是某种 <code>vector&lt;Datum&gt; -&gt; Datum</code></p>
<p>Function: 由<strong>一个或者数个 Kernel</strong> 组成，每个 Kernel 有操作和对应的<strong>输入/输出类型</strong>，Function 按照 Function name 注册在 <strong>FunctionRegistry</strong> 中. 在类型匹配的时候，Function 支持「挑选最佳的匹配」，并且，Function 支持 implicit cast，将一些类型完成对应的转型.</p>
<p>好，上面的知识你已经知道了，下面举一个弱智的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i64_3 = std::<span class="built_in">make_shared</span>&lt;arrow::Int64Scalar&gt;(<span class="number">3</span>);</span><br><span class="line">arrow::Datum incremented_datum;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(incremented_datum,</span><br><span class="line">                      arrow::compute::<span class="built_in">CallFunction</span>(<span class="string">&quot;add&quot;</span>, &#123;int64_array_a, i64_3&#125;));</span><br><span class="line">std::shared_ptr&lt;::arrow::Array&gt; incremented_array = std::<span class="built_in">move</span>(incremented_datum).<span class="built_in">make_array</span>();</span><br><span class="line">std::cout &lt;&lt; incremented_array-&gt;<span class="built_in">ToString</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<ol>
<li>这里输入是一个 <code>Array</code> 和 <code>Scalar</code>，类型都是 <code>Int64</code>，输出是一个 <code>Int64Array</code></li>
<li>调用了 <code>arrow::compute::CallFunction</code>, 通过名称 <code>&quot;add&quot;</code> 来调用对应的函数</li>
<li>返回类型是一个 <code>Datum</code>，可以 get 出来是一个 Array。</li>
</ol>
<p>实际上，把 <code>Int64Scalar</code> 换成 <code>Int32Scalar</code> 也是可以通过的，因为这里的系统支持内部的转型。甚至从 Dict 转成普通类型也是可以的. Arrow Compute 指定了一个类型兼容性的表格，来处理这项任务：<a target="_blank" rel="noopener" href="https://arrow.apache.org/docs/cpp/compute.html#common-numeric-type">https://arrow.apache.org/docs/cpp/compute.html#common-numeric-type</a></p>
<p>这里简单的推断一下这套规则，感觉 Arrow 用的是简单的类型映射写进去的，没有引入一些相对复杂一些的计算：</p>
<ul>
<li>Numeric<ul>
<li>Numeric 允许 Implicit Cast<ul>
<li>Signed integer / Unsigned integer / Floating Point 的 Common Type 是 <code>max(T1, T2)</code></li>
<li>(Unsigned, Signed) 的 Common Type 是 <code>larger-int(max(T1, T2))</code>. 特殊的，当其中一个类型是 64-bit 的时候，这里选择的输出类型是 int64 (而可能不是 decimal)。这代表，<code>(int64, uint64)</code> 中，u64 的大于 <code>i64::max</code> 的值会被 truncate</li>
</ul>
</li>
<li>Arrow 有 Decimal128 和 Decimal256</li>
</ul>
</li>
<li>Temporal: Date types (Date32, Date64), Time types (Time32, Time64), Timestamp, Duration, Interval.</li>
<li>“Binary-like”: Binary, LargeBinary, sometimes also FixedSizeBinary.</li>
<li>“String-like”: String, LargeString.<ul>
<li>这里不支持特殊的限定长度或者 char varchar 类型。而且 String / LargeString 实际上和物理 Layout 有关</li>
</ul>
</li>
<li>“List-like”: List, LargeList, sometimes also FixedSizeList.</li>
<li>“Nested”: List-likes (including FixedSizeList), Struct, Union, and related types like Map.</li>
</ul>
<p>（令我感觉很搞笑的是，这里竟然没有包括字典和 REE. <code>&#123;字典, REE&#125;</code> 允许 Implicit Cast 到）</p>
<blockquote>
<p>需要注意的是，Group Aggregation 并不能用 <code>CallFunction</code> 来调用</p>
</blockquote>
<p>Function 有几种类型，粗略的说，类型包含：</p>
<ol>
<li>Aggregators: 接收 (chunked) array / scalar，生成一个 Scalar Output Value</li>
<li>Grouped Aggregations: 类似 GROUP BY (col1, col2…)。接收 Hash Agg (我简单扫了一下，似乎不支持 SortMerge + Agg?)。实现上算子会类似下面所示。在这个</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HashAggregate</span></span><br><span class="line"><span class="function">  <span class="title">grouper</span><span class="params">(hash)</span></span></span><br><span class="line"><span class="function">  <span class="title">hash_agg</span><span class="params">(agg)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>Scalar Functions: Scalar 并不是表示这个函数是 <code>F(Scalar) -&gt; Scalar</code>，而是表示一种单射关系，从一组是参数生成另一组参数。举例为 “add”, “mul” 甚至 “abs” 这种。实际上这里种类是非常多的，不过我们这篇博客不介绍框架之外的东西。<ol>
<li>比较有意思的是，random number generator 这种 0 个参数的东西也被归类了这里。</li>
</ol>
</li>
<li>Vector Functions: 输出是类似带状态的，比如 Sort / 累积和 / Filter 这种</li>
</ol>
<p>上面的系统被组织成下面的层次：</p>
<ul>
<li>ExecNode (in Acero)</li>
<li>Function( 不同类型的 Function )</li>
<li>Kernel (同一个 Function 的不同实现)</li>
</ul>
<p>下面我们来阅读后面两项的代码组织。</p>
<h2 id="从-CallFunction-和-“add”-看起"><a href="#从-CallFunction-和-“add”-看起" class="headerlink" title="从 CallFunction 和 “add” 看起"></a>从 CallFunction 和 “add” 看起</h2><p>一些函数能够被 <code>CallFunction</code> 调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ARROW_EXPORT</span></span><br><span class="line"><span class="function">Result&lt;Datum&gt; <span class="title">CallFunction</span><span class="params">(<span class="type">const</span> std::string&amp; func_name, <span class="type">const</span> std::vector&lt;Datum&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> FunctionOptions* options, ExecContext* ctx = NULLPTR)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ARROW_EXPORT</span></span><br><span class="line"><span class="function">Result&lt;Datum&gt; <span class="title">CallFunction</span><span class="params">(<span class="type">const</span> std::string&amp; func_name, <span class="type">const</span> std::vector&lt;Datum&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                           ExecContext* ctx = NULLPTR)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ARROW_EXPORT</span></span><br><span class="line"><span class="function">Result&lt;Datum&gt; <span class="title">CallFunction</span><span class="params">(<span class="type">const</span> std::string&amp; func_name, <span class="type">const</span> ExecBatch&amp; batch,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> FunctionOptions* options, ExecContext* ctx = NULLPTR)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ARROW_EXPORT</span></span><br><span class="line"><span class="function">Result&lt;Datum&gt; <span class="title">CallFunction</span><span class="params">(<span class="type">const</span> std::string&amp; func_name, <span class="type">const</span> ExecBatch&amp; batch,</span></span></span><br><span class="line"><span class="params"><span class="function">                           ExecContext* ctx = NULLPTR)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里除了我们之前介绍的，还有几个比较好玩的参数:</p>
<ol>
<li><code>FunctionOptions</code>: 是一个比较奇怪的东西</li>
<li><code>ExecBatch</code>: 基本上是 Acero 之类的传下来的，它们倾向以 Batch 模式来 Exec</li>
<li><code>ExecContext</code>: 执行的时候的上下文，包含了：<ol>
<li>MemoryPool</li>
<li>CPU Info ( SIMD instr 之类的）</li>
<li>CPU Executor</li>
<li>ChunkSize ( Batch Size )</li>
<li>Function Registry</li>
</ol>
</li>
</ol>
<p>那么，最为最开始使用的用户，我们可以自顶向下的来看看这个 CallFunction:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;Datum&gt; <span class="title">CallFunction</span><span class="params">(<span class="type">const</span> std::string&amp; func_name, <span class="type">const</span> std::vector&lt;Datum&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> FunctionOptions* options, ExecContext* ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ctx = <span class="built_in">default_exec_context</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(std::shared_ptr&lt;<span class="type">const</span> Function&gt; func,</span><br><span class="line">                        ctx-&gt;<span class="built_in">func_registry</span>()-&gt;<span class="built_in">GetFunction</span>(func_name));</span><br><span class="line">  <span class="keyword">return</span> func-&gt;<span class="built_in">Execute</span>(args, options, ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FunctionRegistry"><a href="#FunctionRegistry" class="headerlink" title="FunctionRegistry"></a>FunctionRegistry</h4><p>FunctionRegistry 的实现关系类似 Naming 的 Scope:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionRegistry</span>::FunctionRegistryImpl &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  FunctionRegistryImpl* parent_;</span><br><span class="line">  std::mutex lock_;</span><br><span class="line">  std::unordered_map&lt;std::string, std::shared_ptr&lt;Function&gt;&gt; name_to_function_;</span><br><span class="line">  std::unordered_map&lt;std::string, <span class="type">const</span> FunctionOptionsType*&gt; name_to_options_type_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>内部成员实际上会有 <code>lock_</code> 的保护</li>
<li>有父级关系( 我看了下，arrow 内部好像没用到，感觉是给用户处理 UDF 之类的？）</li>
<li>允许加入成员和 alias</li>
</ol>
<p>那么，这里层次是怎么玩的呢，答案是它会按照分类来创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::unique_ptr&lt;FunctionRegistry&gt; <span class="title">CreateBuiltInRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> registry = FunctionRegistry::<span class="built_in">Make</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register core kernels</span></span><br><span class="line">  <span class="built_in">RegisterScalarCast</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterVectorHash</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterVectorSelection</span>(registry.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RegisterScalarOptions</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterVectorOptions</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterAggregateOptions</span>(registry.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ARROW_COMPUTE</span></span><br><span class="line">  <span class="comment">// Register additional kernels</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Scalar functions</span></span><br><span class="line">  <span class="built_in">RegisterScalarArithmetic</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarBoolean</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarComparison</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarIfElse</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarNested</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarRandom</span>(registry.<span class="built_in">get</span>());  <span class="comment">// Nullary</span></span><br><span class="line">  <span class="built_in">RegisterScalarRoundArithmetic</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarSetLookup</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarStringAscii</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarStringUtf8</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarTemporalBinary</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarTemporalUnary</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarValidity</span>(registry.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Vector functions</span></span><br><span class="line">  <span class="built_in">RegisterVectorArraySort</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterVectorCumulativeSum</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterVectorNested</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterVectorRank</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterVectorReplace</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterVectorSelectK</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterVectorSort</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterVectorRunEndEncode</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterVectorRunEndDecode</span>(registry.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Aggregate functions</span></span><br><span class="line">  <span class="built_in">RegisterHashAggregateBasic</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarAggregateBasic</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarAggregateMode</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarAggregateQuantile</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarAggregateTDigest</span>(registry.<span class="built_in">get</span>());</span><br><span class="line">  <span class="built_in">RegisterScalarAggregateVariance</span>(registry.<span class="built_in">get</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> registry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace internal</span></span><br><span class="line"></span><br><span class="line"><span class="function">FunctionRegistry* <span class="title">GetFunctionRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">auto</span> g_registry = internal::<span class="built_in">CreateBuiltInRegistry</span>();</span><br><span class="line">  <span class="keyword">return</span> g_registry.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们举几个例子，比如插入 Cast 相关的:</p>
<ol>
<li>MetaFunction 本质上是个转发器(误)</li>
<li>注册了一个 FunctionOption，这里绑定的是类型和对应的成员。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">auto</span> kCastOptionsType = <span class="built_in">GetFunctionOptionsType</span>&lt;CastOptions&gt;(</span><br><span class="line">    arrow::internal::<span class="built_in">DataMember</span>(<span class="string">&quot;to_type&quot;</span>, &amp;CastOptions::to_type),</span><br><span class="line">    arrow::internal::<span class="built_in">DataMember</span>(<span class="string">&quot;allow_int_overflow&quot;</span>, &amp;CastOptions::allow_int_overflow),</span><br><span class="line">    arrow::internal::<span class="built_in">DataMember</span>(<span class="string">&quot;allow_time_truncate&quot;</span>, &amp;CastOptions::allow_time_truncate),</span><br><span class="line">    arrow::internal::<span class="built_in">DataMember</span>(<span class="string">&quot;allow_time_overflow&quot;</span>, &amp;CastOptions::allow_time_overflow),</span><br><span class="line">    arrow::internal::<span class="built_in">DataMember</span>(<span class="string">&quot;allow_decimal_truncate&quot;</span>,</span><br><span class="line">                                &amp;CastOptions::allow_decimal_truncate),</span><br><span class="line">    arrow::internal::<span class="built_in">DataMember</span>(<span class="string">&quot;allow_float_truncate&quot;</span>,</span><br><span class="line">                                &amp;CastOptions::allow_float_truncate),</span><br><span class="line">    arrow::internal::<span class="built_in">DataMember</span>(<span class="string">&quot;allow_invalid_utf8&quot;</span>, &amp;CastOptions::allow_invalid_utf8));</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RegisterScalarCast</span><span class="params">(FunctionRegistry* registry)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_OK</span>(registry-&gt;<span class="built_in">AddFunction</span>(std::<span class="built_in">make_shared</span>&lt;CastMetaFunction&gt;()));</span><br><span class="line">  <span class="built_in">DCHECK_OK</span>(registry-&gt;<span class="built_in">AddFunctionOptionsType</span>(kCastOptionsType));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实你会对这个 FunctionType 很困惑，我也很困惑，看上去他们挫了一套反射库：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Options, <span class="keyword">typename</span>... Properties&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> FunctionOptionsType* <span class="title">GetFunctionOptionsType</span><span class="params">(<span class="type">const</span> Properties&amp;... properties)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="keyword">class</span> <span class="title class_">OptionsType</span> : <span class="keyword">public</span> GenericOptionsType &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">OptionsType</span><span class="params">(<span class="type">const</span> arrow::internal::PropertyTuple&lt;Properties...&gt; properties)</span></span></span><br><span class="line"><span class="function">        : properties_(properties) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">type_name</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> Options::kTypeName; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">Stringify</span><span class="params">(<span class="type">const</span> FunctionOptions&amp; options)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; self = <span class="built_in">checked_cast</span>&lt;<span class="type">const</span> Options&amp;&gt;(options);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">StringifyImpl</span>&lt;Options&gt;(self, properties_).<span class="built_in">Finish</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(<span class="type">const</span> FunctionOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> FunctionOptions&amp; other)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; lhs = <span class="built_in">checked_cast</span>&lt;<span class="type">const</span> Options&amp;&gt;(options);</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; rhs = <span class="built_in">checked_cast</span>&lt;<span class="type">const</span> Options&amp;&gt;(other);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">CompareImpl</span>&lt;Options&gt;(lhs, rhs, properties_).equal_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Status <span class="title">ToStructScalar</span><span class="params">(<span class="type">const</span> FunctionOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                          std::vector&lt;std::string&gt;* field_names,</span></span></span><br><span class="line"><span class="params"><span class="function">                          std::vector&lt;std::shared_ptr&lt;Scalar&gt;&gt;* values)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; self = <span class="built_in">checked_cast</span>&lt;<span class="type">const</span> Options&amp;&gt;(options);</span><br><span class="line">      <span class="built_in">RETURN_NOT_OK</span>(</span><br><span class="line">          <span class="built_in">ToStructScalarImpl</span>&lt;Options&gt;(self, properties_, field_names, values).status_);</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Result&lt;std::unique_ptr&lt;FunctionOptions&gt;&gt; <span class="built_in">FromStructScalar</span>(</span><br><span class="line">        <span class="type">const</span> StructScalar&amp; scalar) <span class="type">const</span> <span class="keyword">override</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> options = std::<span class="built_in">make_unique</span>&lt;Options&gt;();</span><br><span class="line">      <span class="built_in">RETURN_NOT_OK</span>(</span><br><span class="line">          <span class="built_in">FromStructScalarImpl</span>&lt;Options&gt;(options.<span class="built_in">get</span>(), scalar, properties_).status_);</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">move</span>(options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;FunctionOptions&gt; <span class="title">Copy</span><span class="params">(<span class="type">const</span> FunctionOptions&amp; options)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> out = std::<span class="built_in">make_unique</span>&lt;Options&gt;();</span><br><span class="line">      <span class="built_in">CopyImpl</span>&lt;Options&gt;(out.<span class="built_in">get</span>(), <span class="built_in">checked_cast</span>&lt;<span class="type">const</span> Options&amp;&gt;(options), properties_);</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">move</span>(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> arrow::internal::PropertyTuple&lt;Properties...&gt; properties_;</span><br><span class="line">  &#125; <span class="built_in">instance</span>(arrow::internal::<span class="built_in">MakeProperties</span>(properties...));</span><br><span class="line">  <span class="keyword">return</span> &amp;instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p>然后我们来看看 <code>Function</code> 部分，以 “Add” 为例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Result&lt;Datum&gt; <span class="title">ExecuteInternal</span><span class="params">(<span class="type">const</span> Function&amp; func, std::vector&lt;Datum&gt; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int64_t</span> passed_length, <span class="type">const</span> FunctionOptions* options,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ExecContext* ctx)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(<span class="keyword">auto</span> inputs, internal::<span class="built_in">GetFunctionArgumentTypes</span>(args));</span><br><span class="line">  <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(<span class="keyword">auto</span> func_exec, func.<span class="built_in">GetBestExecutor</span>(inputs));</span><br><span class="line">  <span class="built_in">ARROW_RETURN_NOT_OK</span>(func_exec-&gt;<span class="built_in">Init</span>(options, ctx));</span><br><span class="line">  <span class="keyword">return</span> func_exec-&gt;<span class="built_in">Execute</span>(args, passed_length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="function">Result&lt;Datum&gt; <span class="title">Function::Execute</span><span class="params">(<span class="type">const</span> std::vector&lt;Datum&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> FunctionOptions* options, ExecContext* ctx)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ExecuteInternal</span>(*<span class="keyword">this</span>, args, <span class="comment">/*passed_length=*/</span><span class="number">-1</span>, options, ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Result&lt;Datum&gt; <span class="title">Function::Execute</span><span class="params">(<span class="type">const</span> ExecBatch&amp; batch, <span class="type">const</span> FunctionOptions* options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ExecContext* ctx)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ExecuteInternal</span>(*<span class="keyword">this</span>, batch.values, batch.length, options, ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Function 内部有一层 <code>Dispatch</code> 的流程:</p>
<ol>
<li>创建对应的 Executor，这里的 Executor 是个 <code>KernelExecutor</code> 类型</li>
<li>然后找到 Best 的 Kernel( <code>GetBestExecutor</code> )</li>
<li>包装成一个 FunctionExecutor 返回</li>
</ol>
<p>我们先来讲 <code>Kernel</code>，然后来讲对应的 Executors</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Result&lt;std::shared_ptr&lt;FunctionExecutor&gt;&gt; Function::<span class="built_in">GetBestExecutor</span>(</span><br><span class="line">    std::vector&lt;TypeHolder&gt; inputs) <span class="type">const</span> &#123;</span><br><span class="line">  std::unique_ptr&lt;detail::KernelExecutor&gt; executor;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">kind</span>() == Function::SCALAR) &#123;</span><br><span class="line">    executor = detail::KernelExecutor::<span class="built_in">MakeScalar</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">kind</span>() == Function::VECTOR) &#123;</span><br><span class="line">    executor = detail::KernelExecutor::<span class="built_in">MakeVector</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">kind</span>() == Function::SCALAR_AGGREGATE) &#123;</span><br><span class="line">    executor = detail::KernelExecutor::<span class="built_in">MakeScalarAggregate</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">NotImplemented</span>(<span class="string">&quot;Direct execution of HASH_AGGREGATE functions&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(<span class="type">const</span> Kernel* kernel, <span class="built_in">DispatchBest</span>(&amp;inputs));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;detail::FunctionExecutorImpl&gt;(std::<span class="built_in">move</span>(inputs), kernel,</span><br><span class="line">                                                        std::<span class="built_in">move</span>(executor), *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Kernel-执行器和逻辑的生成"><a href="#Kernel-执行器和逻辑的生成" class="headerlink" title="Kernel 执行器和逻辑的生成"></a>Kernel 执行器和逻辑的生成</h4><p>首先，我们来介绍 Kernel 对象，Kernel 的类型稍稍有点复杂：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// \brief Common initializer function for all kernel types.</span></span><br><span class="line"><span class="keyword">using</span> KernelInit = std::function&lt;Result&lt;std::unique_ptr&lt;KernelState&gt;&gt;(</span><br><span class="line">    KernelContext*, <span class="type">const</span> KernelInitArgs&amp;)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// \brief Base type for kernels. Contains the function signature and</span></span><br><span class="line"><span class="comment">/// optionally the state initialization function, along with some common</span></span><br><span class="line"><span class="comment">/// attributes</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ARROW_EXPORT</span> Kernel &#123;</span><br><span class="line">  <span class="built_in">Kernel</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Kernel</span>(std::shared_ptr&lt;KernelSignature&gt; sig, KernelInit init)</span><br><span class="line">      : <span class="built_in">signature</span>(std::<span class="built_in">move</span>(sig)), <span class="built_in">init</span>(std::<span class="built_in">move</span>(init)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Kernel</span>(std::vector&lt;InputType&gt; in_types, OutputType out_type, KernelInit init)</span><br><span class="line">      : <span class="built_in">Kernel</span>(KernelSignature::<span class="built_in">Make</span>(std::<span class="built_in">move</span>(in_types), std::<span class="built_in">move</span>(out_type)),</span><br><span class="line">               std::<span class="built_in">move</span>(init)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief The &quot;signature&quot; of the kernel containing the InputType input</span></span><br><span class="line">  <span class="comment">/// argument validators and OutputType output type resolver.</span></span><br><span class="line">  std::shared_ptr&lt;KernelSignature&gt; signature;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Create a new KernelState for invocations of this kernel, e.g. to</span></span><br><span class="line">  <span class="comment">/// set up any options or state relevant for execution.</span></span><br><span class="line">  KernelInit init;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Create a vector of new KernelState for invocations of this kernel.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Status <span class="title">InitAll</span><span class="params">(KernelContext*, <span class="type">const</span> KernelInitArgs&amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::vector&lt;std::unique_ptr&lt;KernelState&gt;&gt;*)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Indicates whether execution can benefit from parallelization</span></span><br><span class="line">  <span class="comment">/// (splitting large chunks into smaller chunks and using multiple</span></span><br><span class="line">  <span class="comment">/// threads). Some kernels may not support parallel execution at</span></span><br><span class="line">  <span class="comment">/// all. Synchronization and concurrency-related issues are currently the</span></span><br><span class="line">  <span class="comment">/// responsibility of the Kernel&#x27;s implementation.</span></span><br><span class="line">  <span class="type">bool</span> parallelizable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Indicates the level of SIMD instruction support in the host CPU is</span></span><br><span class="line">  <span class="comment">/// required to use the function. The intention is for functions to be able to</span></span><br><span class="line">  <span class="comment">/// contain multiple kernels with the same signature but different levels of SIMD,</span></span><br><span class="line">  <span class="comment">/// so that the most optimized kernel supported on a host&#x27;s processor can be chosen.</span></span><br><span class="line">  SimdLevel::type simd_level = SimdLevel::NONE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Additional kernel-specific data</span></span><br><span class="line">  std::shared_ptr&lt;KernelState&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>举例子是 <code>Add</code> 这个 Binary 的 Scalar Function:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = <span class="built_in">MakeArithmeticFunction</span>&lt;Add&gt;(<span class="string">&quot;add&quot;</span>, add_doc);</span><br><span class="line"><span class="built_in">AddDecimalBinaryKernels</span>&lt;Add&gt;(<span class="string">&quot;add&quot;</span>, add.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>
<p>这里调了对应的 KernelGenerator，这里写了一套模版代码，我觉得调用起来挺方便，读起来感觉真的有点点难，首先这里有 <code>Add</code> 和 Checked 版本的 Add，他们提供是否检查的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg0, <span class="keyword">typename</span> Arg1&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> enable_if_floating_value&lt;T&gt; <span class="title">Call</span><span class="params">(KernelContext*, Arg0 left, Arg1 right,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Status*)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg0, <span class="keyword">typename</span> Arg1&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> enable_if_unsigned_integer_value&lt;T&gt; <span class="title">Call</span><span class="params">(KernelContext*, Arg0 left,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                            Arg1 right, Status*)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg0, <span class="keyword">typename</span> Arg1&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> enable_if_signed_integer_value&lt;T&gt; <span class="title">Call</span><span class="params">(KernelContext*, Arg0 left,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                          Arg1 right, Status*)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arrow::internal::<span class="built_in">SafeSignedAdd</span>(left, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg0, <span class="keyword">typename</span> Arg1&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> enable_if_decimal_value&lt;T&gt; <span class="title">Call</span><span class="params">(KernelContext*, Arg0 left, Arg1 right, Status*)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddChecked</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg0, <span class="keyword">typename</span> Arg1&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> enable_if_integer_value&lt;T&gt; <span class="title">Call</span><span class="params">(KernelContext*, Arg0 left, Arg1 right,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Status* st)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same&lt;T, Arg0&gt;::value &amp;&amp; std::is_same&lt;T, Arg1&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    T result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ARROW_PREDICT_FALSE</span>(<span class="built_in">AddWithOverflow</span>(left, right, &amp;result))) &#123;</span><br><span class="line">      *st = Status::<span class="built_in">Invalid</span>(<span class="string">&quot;overflow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg0, <span class="keyword">typename</span> Arg1&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> enable_if_floating_value&lt;T&gt; <span class="title">Call</span><span class="params">(KernelContext*, Arg0 left, Arg1 right,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Status*)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same&lt;T, Arg0&gt;::value &amp;&amp; std::is_same&lt;T, Arg1&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg0, <span class="keyword">typename</span> Arg1&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> enable_if_decimal_value&lt;T&gt; <span class="title">Call</span><span class="params">(KernelContext*, Arg0 left, Arg1 right, Status*)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有一个地方需要注意一下，虽然 Arrow 可能会在调用的时候判断，如果输入（有一个）是 NULL，那么输出 NULL。但是 Add 的时候，针对 Null 上 Undefined 的地方做加法开销也不大。我们这里看 <code>MakeArithmeticFunction&lt;Add&gt;(&quot;add&quot;, add_doc)</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里还塞了一个 FunctionDoc 进去</span></span><br><span class="line"><span class="type">const</span> FunctionDoc add_doc&#123;<span class="string">&quot;Add the arguments element-wise&quot;</span>,</span><br><span class="line">                          (<span class="string">&quot;Results will wrap around on integer overflow.\n&quot;</span></span><br><span class="line">                           <span class="string">&quot;Use function \&quot;add_checked\&quot; if you want overflow\n&quot;</span></span><br><span class="line">                           <span class="string">&quot;to return an error.&quot;</span>),</span><br><span class="line">                          &#123;<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>然后和：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Op, <span class="keyword">typename</span> FunctionImpl = ArithmeticFunction&gt;</span><br><span class="line">std::shared_ptr&lt;ScalarFunction&gt; <span class="built_in">MakeArithmeticFunction</span>(std::string name,</span><br><span class="line">                                                       FunctionDoc doc) &#123;</span><br><span class="line">  <span class="keyword">auto</span> func = std::<span class="built_in">make_shared</span>&lt;FunctionImpl&gt;(name, Arity::<span class="built_in">Binary</span>(), std::<span class="built_in">move</span>(doc));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ty : <span class="built_in">NumericTypes</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> exec = <span class="built_in">ArithmeticExecFromOp</span>&lt;ScalarBinaryEqualTypes, Op&gt;(ty);</span><br><span class="line">    <span class="built_in">DCHECK_OK</span>(func-&gt;<span class="built_in">AddKernel</span>(&#123;ty, ty&#125;, ty, exec));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">AddNullExec</span>(func.<span class="built_in">get</span>());</span><br><span class="line">  <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>NumericTypes</code> 包含什么呢：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Numeric types</span></span><br><span class="line"><span class="built_in">Extend</span>(g_int_types, &amp;g_numeric_types);</span><br><span class="line"><span class="built_in">Extend</span>(g_floating_types, &amp;g_numeric_types);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-parametric, non-nested types. This also DOES NOT include</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// * Decimal</span></span><br><span class="line"><span class="comment">// * Fixed Size Binary</span></span><br><span class="line"><span class="comment">// * Time32</span></span><br><span class="line"><span class="comment">// * Time64</span></span><br><span class="line"><span class="comment">// * Timestamp</span></span><br><span class="line">g_primitive_types = &#123;<span class="built_in">null</span>(), <span class="built_in">boolean</span>(), <span class="built_in">date32</span>(), <span class="built_in">date64</span>()&#125;;</span><br><span class="line"><span class="built_in">Extend</span>(g_numeric_types, &amp;g_primitive_types);</span><br></pre></td></tr></table></figure>
<p>然后调用 <code>ArithmeticExecFromOp&lt;ScalarBinaryEqualTypes, Op&gt;(ty)</code> 产生 <code>ArrayKernelExec</code>, <code>ArithmeticExecFromOp</code> 会使用 <code>ScalarBinaryEqualTypes</code> 这个 Generator 来把动态的调用分发到静态模版上:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ArrayKernelExec = <span class="built_in">Status</span> (*)(KernelContext*, <span class="type">const</span> ExecSpan&amp;, ExecResult*);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt; <span class="keyword">class</span> <span class="title class_">KernelGenerator</span>, <span class="keyword">typename</span> Op,</span><br><span class="line">          <span class="keyword">typename</span> KernelType = ArrayKernelExec, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">KernelType <span class="built_in">ArithmeticExecFromOp</span>(detail::GetTypeId get_id) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (get_id.id) &#123;</span><br><span class="line">    <span class="keyword">case</span> Type::INT8:</span><br><span class="line">      <span class="keyword">return</span> KernelGenerator&lt;Int8Type, Int8Type, Op, Args...&gt;::Exec;</span><br><span class="line">    <span class="keyword">case</span> Type::UINT8:</span><br><span class="line">      <span class="keyword">return</span> KernelGenerator&lt;UInt8Type, UInt8Type, Op, Args...&gt;::Exec;</span><br><span class="line">    <span class="keyword">case</span> Type::INT16:</span><br><span class="line">      <span class="keyword">return</span> KernelGenerator&lt;Int16Type, Int16Type, Op, Args...&gt;::Exec;</span><br><span class="line">    <span class="keyword">case</span> Type::UINT16:</span><br><span class="line">      <span class="keyword">return</span> KernelGenerator&lt;UInt16Type, UInt16Type, Op, Args...&gt;::Exec;</span><br><span class="line">    <span class="keyword">case</span> Type::INT32:</span><br><span class="line">      <span class="keyword">return</span> KernelGenerator&lt;Int32Type, Int32Type, Op, Args...&gt;::Exec;</span><br><span class="line">    <span class="keyword">case</span> Type::UINT32:</span><br><span class="line">      <span class="keyword">return</span> KernelGenerator&lt;UInt32Type, UInt32Type, Op, Args...&gt;::Exec;</span><br><span class="line">    <span class="keyword">case</span> Type::DURATION:</span><br><span class="line">    <span class="keyword">case</span> Type::INT64:</span><br><span class="line">    <span class="keyword">case</span> Type::TIMESTAMP:</span><br><span class="line">      <span class="keyword">return</span> KernelGenerator&lt;Int64Type, Int64Type, Op, Args...&gt;::Exec;</span><br><span class="line">    <span class="keyword">case</span> Type::UINT64:</span><br><span class="line">      <span class="keyword">return</span> KernelGenerator&lt;UInt64Type, UInt64Type, Op, Args...&gt;::Exec;</span><br><span class="line">    <span class="keyword">case</span> Type::FLOAT:</span><br><span class="line">      <span class="keyword">return</span> KernelGenerator&lt;FloatType, FloatType, Op, Args...&gt;::Exec;</span><br><span class="line">    <span class="keyword">case</span> Type::DOUBLE:</span><br><span class="line">      <span class="keyword">return</span> KernelGenerator&lt;DoubleType, DoubleType, Op, Args...&gt;::Exec;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">DCHECK</span>(<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">return</span> FailFunctor&lt;KernelType&gt;::Exec;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来看 Generator:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A kernel exec generator for binary kernels where both input types are the</span></span><br><span class="line"><span class="comment">// same</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutType, <span class="keyword">typename</span> ArgType, <span class="keyword">typename</span> Op&gt;</span><br><span class="line"><span class="keyword">using</span> ScalarBinaryEqualTypes = ScalarBinary&lt;OutType, ArgType, ArgType, Op&gt;;</span><br></pre></td></tr></table></figure>
<p>里面是：</p>
<ol>
<li>把输入输出的 Array 用泛型抽了迭代器出来</li>
<li>根据 <code>Op::Call</code> 来调用</li>
<li>根据一个泛型 Writer 来抽出输出，写输出的数据</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A kernel exec generator for binary functions that addresses both array and</span></span><br><span class="line"><span class="comment">// scalar inputs and dispatches input iteration and output writing to other</span></span><br><span class="line"><span class="comment">// templates</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This template executes the operator even on the data behind null values,</span></span><br><span class="line"><span class="comment">// therefore it is generally only suitable for operators that are safe to apply</span></span><br><span class="line"><span class="comment">// even on the null slot values.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The &quot;Op&quot; functor should have the form</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// struct Op &#123;</span></span><br><span class="line"><span class="comment">//   template &lt;typename OutValue, typename Arg0Value, typename Arg1Value&gt;</span></span><br><span class="line"><span class="comment">//   static OutValue Call(KernelContext* ctx, Arg0Value arg0, Arg1Value arg1, Status* st)</span></span><br><span class="line"><span class="comment">//   &#123;</span></span><br><span class="line"><span class="comment">//     // implementation</span></span><br><span class="line"><span class="comment">//     // <span class="doctag">NOTE:</span> &quot;status&quot; should only populated with errors,</span></span><br><span class="line"><span class="comment">//     //       leave it unmodified to indicate Status::OK()</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutType, <span class="keyword">typename</span> Arg0Type, <span class="keyword">typename</span> Arg1Type, <span class="keyword">typename</span> Op&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ScalarBinary</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> OutValue = <span class="keyword">typename</span> GetOutputType&lt;OutType&gt;::T;</span><br><span class="line">  <span class="keyword">using</span> Arg0Value = <span class="keyword">typename</span> GetViewType&lt;Arg0Type&gt;::T;</span><br><span class="line">  <span class="keyword">using</span> Arg1Value = <span class="keyword">typename</span> GetViewType&lt;Arg1Type&gt;::T;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Status <span class="title">ArrayArray</span><span class="params">(KernelContext* ctx, <span class="type">const</span> ArraySpan&amp; arg0,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> ArraySpan&amp; arg1, ExecResult* out)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Status <span class="title">ArrayScalar</span><span class="params">(KernelContext* ctx, <span class="type">const</span> ArraySpan&amp; arg0, <span class="type">const</span> Scalar&amp; arg1,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ExecResult* out)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Status <span class="title">ScalarArray</span><span class="params">(KernelContext* ctx, <span class="type">const</span> Scalar&amp; arg0, <span class="type">const</span> ArraySpan&amp; arg1,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ExecResult* out)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Status <span class="title">Exec</span><span class="params">(KernelContext* ctx, <span class="type">const</span> ExecSpan&amp; batch, ExecResult* out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (batch[<span class="number">0</span>].<span class="built_in">is_array</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (batch[<span class="number">1</span>].<span class="built_in">is_array</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ArrayArray</span>(ctx, batch[<span class="number">0</span>].array, batch[<span class="number">1</span>].array, out);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ArrayScalar</span>(ctx, batch[<span class="number">0</span>].array, *batch[<span class="number">1</span>].scalar, out);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (batch[<span class="number">1</span>].<span class="built_in">is_array</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ScalarArray</span>(ctx, *batch[<span class="number">0</span>].scalar, batch[<span class="number">1</span>].array, out);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">DCHECK</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Invalid</span>(<span class="string">&quot;Should be unreachable&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后调用 <code>func-&gt;AddKernel(/*输入类型*/&#123;ty, ty&#125;, /*输出类型*/ty, ``/*执行callback*/``exec)</code> 来添加执行的 Kernel。</p>
<p>这里我们再回过头看看那个问题，Kernel 是什么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Kernel</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// \brief Arguments to pass to an KernelInit function. A struct is used to help</span></span><br><span class="line"><span class="comment">/// avoid API breakage should the arguments passed need to be expanded.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KernelInitArgs</span> &#123;</span><br><span class="line">  <span class="comment">/// \brief A pointer to the kernel being initialized. The init function may</span></span><br><span class="line">  <span class="comment">/// depend on the kernel&#x27;s KernelSignature or other data contained there.</span></span><br><span class="line">  <span class="type">const</span> Kernel* kernel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief The types of the input arguments that the kernel is</span></span><br><span class="line">  <span class="comment">/// about to be executed against.</span></span><br><span class="line">  <span class="type">const</span> std::vector&lt;TypeHolder&gt;&amp; inputs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Opaque options specific to this kernel. May be nullptr for functions</span></span><br><span class="line">  <span class="comment">/// that do not require options.</span></span><br><span class="line">  <span class="type">const</span> FunctionOptions* options;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// \brief Common initializer function for all kernel types.</span></span><br><span class="line"><span class="keyword">using</span> KernelInit = std::function&lt;Result&lt;std::unique_ptr&lt;KernelState&gt;&gt;(</span><br><span class="line">    KernelContext*, <span class="type">const</span> KernelInitArgs&amp;)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// \brief Base type for kernels. Contains the function signature and</span></span><br><span class="line"><span class="comment">/// optionally the state initialization function, along with some common</span></span><br><span class="line"><span class="comment">/// attributes</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ARROW_EXPORT</span> Kernel &#123;</span><br><span class="line">  <span class="built_in">Kernel</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Kernel</span>(std::shared_ptr&lt;KernelSignature&gt; sig, KernelInit init)</span><br><span class="line">      : <span class="built_in">signature</span>(std::<span class="built_in">move</span>(sig)), <span class="built_in">init</span>(std::<span class="built_in">move</span>(init)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Kernel</span>(std::vector&lt;InputType&gt; in_types, OutputType out_type, KernelInit init)</span><br><span class="line">      : <span class="built_in">Kernel</span>(KernelSignature::<span class="built_in">Make</span>(std::<span class="built_in">move</span>(in_types), std::<span class="built_in">move</span>(out_type)),</span><br><span class="line">               std::<span class="built_in">move</span>(init)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief The &quot;signature&quot; of the kernel containing the InputType input</span></span><br><span class="line">  <span class="comment">/// argument validators and OutputType output type resolver.</span></span><br><span class="line">  std::shared_ptr&lt;KernelSignature&gt; signature;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Create a new KernelState for invocations of this kernel, e.g. to</span></span><br><span class="line">  <span class="comment">/// set up any options or state relevant for execution.</span></span><br><span class="line">  KernelInit init;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Create a vector of new KernelState for invocations of this kernel.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> Status <span class="title">InitAll</span><span class="params">(KernelContext*, <span class="type">const</span> KernelInitArgs&amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::vector&lt;std::unique_ptr&lt;KernelState&gt;&gt;*)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> parallelizable = <span class="literal">true</span>;</span><br><span class="line">  SimdLevel::type simd_level = SimdLevel::NONE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Additional kernel-specific data</span></span><br><span class="line">  std::shared_ptr&lt;KernelState&gt; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Kernel 本身是一组奇怪的 api，包含 <code>KernelState</code>, 外部根据<code>KernelSignature</code> 和 <code>KernelInit</code>来调用它，我们来看 <code>ScalarKernel</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ArrayKernelExec = <span class="built_in">Status</span> (*)(KernelContext*, <span class="type">const</span> ExecSpan&amp;, ExecResult*);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// \brief Kernel data structure for implementations of ScalarFunction. In</span></span><br><span class="line"><span class="comment">/// addition to the members found in Kernel, contains the null handling</span></span><br><span class="line"><span class="comment">/// and memory pre-allocation preferences.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ARROW_EXPORT</span> ScalarKernel : <span class="keyword">public</span> Kernel &#123;</span><br><span class="line">  <span class="built_in">ScalarKernel</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ScalarKernel</span>(std::shared_ptr&lt;KernelSignature&gt; sig, ArrayKernelExec exec,</span><br><span class="line">               KernelInit init = NULLPTR)</span><br><span class="line">      : <span class="built_in">Kernel</span>(std::<span class="built_in">move</span>(sig), init), <span class="built_in">exec</span>(exec) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ScalarKernel</span>(std::vector&lt;InputType&gt; in_types, OutputType out_type, ArrayKernelExec exec,</span><br><span class="line">               KernelInit init = NULLPTR)</span><br><span class="line">      : <span class="built_in">Kernel</span>(std::<span class="built_in">move</span>(in_types), std::<span class="built_in">move</span>(out_type), std::<span class="built_in">move</span>(init)), <span class="built_in">exec</span>(exec) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Perform a single invocation of this kernel. Depending on the</span></span><br><span class="line">  <span class="comment">/// implementation, it may only write into preallocated memory, while in some</span></span><br><span class="line">  <span class="comment">/// cases it will allocate its own memory. Any required state is managed</span></span><br><span class="line">  <span class="comment">/// through the KernelContext.</span></span><br><span class="line">  ArrayKernelExec exec;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Writing execution results into larger contiguous allocations</span></span><br><span class="line">  <span class="comment">/// requires that the kernel be able to write into sliced output ArrayData*,</span></span><br><span class="line">  <span class="comment">/// including sliced output validity bitmaps. Some kernel implementations may</span></span><br><span class="line">  <span class="comment">/// not be able to do this, so setting this to false disables this</span></span><br><span class="line">  <span class="comment">/// functionality.</span></span><br><span class="line">  <span class="type">bool</span> can_write_into_slices = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For scalar functions preallocated data and intersecting arg validity</span></span><br><span class="line">  <span class="comment">// bitmaps is a reasonable default</span></span><br><span class="line">  NullHandling::type null_handling = NullHandling::INTERSECTION;</span><br><span class="line">  MemAllocation::type mem_allocation = MemAllocation::PREALLOCATE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里比较关键的是这个 Exec，我们来看看执行侧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ARROW_EXPORT</span> KernelExecutor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">KernelExecutor</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The Kernel&#x27;s `init` method must be called and any KernelState set in the</span></span><br><span class="line">  <span class="comment">/// KernelContext *before* KernelExecutor::Init is called. This is to facilitate</span></span><br><span class="line">  <span class="comment">/// the case where init may be expensive and does not need to be called again for</span></span><br><span class="line">  <span class="comment">/// each execution of the kernel, for example the same lookup table can be re-used</span></span><br><span class="line">  <span class="comment">/// for all scanned batches in a dataset filter.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Init</span><span class="params">(KernelContext*, KernelInitArgs)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(wesm): per ARROW-16819, adding ExecBatch variant so that a batch</span></span><br><span class="line">  <span class="comment">// length can be passed in for scalar functions; will have to return and</span></span><br><span class="line">  <span class="comment">// clean a bunch of things up</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Execute</span><span class="params">(<span class="type">const</span> ExecBatch&amp; batch, ExecListener* listener)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Datum <span class="title">WrapResults</span><span class="params">(<span class="type">const</span> std::vector&lt;Datum&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> std::vector&lt;Datum&gt;&amp; outputs)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Check the actual result type against the resolved output type</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">CheckResultType</span><span class="params">(<span class="type">const</span> Datum&amp; out, <span class="type">const</span> <span class="type">char</span>* function_name)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> std::unique_ptr&lt;KernelExecutor&gt; <span class="title">MakeScalar</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> std::unique_ptr&lt;KernelExecutor&gt; <span class="title">MakeVector</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> std::unique_ptr&lt;KernelExecutor&gt; <span class="title">MakeScalarAggregate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最终，<code>ScalarExecutor::Execute</code> 会执行那个 <code>exec</code>，来处理对应的逻辑:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ExecuteNonSpans</span><span class="params">(ExecListener* listener)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ARROW-16756: Kernel is going to allocate some memory and so</span></span><br><span class="line">  <span class="comment">// for the time being we pass in an empty or partially-filled</span></span><br><span class="line">  <span class="comment">// shared_ptr&lt;ArrayData&gt; or shared_ptr&lt;Scalar&gt; to be populated</span></span><br><span class="line">  <span class="comment">// by the kernel.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We will eventually delete the Scalar output path per</span></span><br><span class="line">  <span class="comment">// ARROW-16757.</span></span><br><span class="line">  ExecSpan input;</span><br><span class="line">  ExecResult output;</span><br><span class="line">  <span class="keyword">while</span> (span_iterator_.<span class="built_in">Next</span>(&amp;input)) &#123;</span><br><span class="line">    <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(output.value, <span class="built_in">PrepareOutput</span>(input.length));</span><br><span class="line">    <span class="built_in">DCHECK</span>(output.<span class="built_in">is_array_data</span>());</span><br><span class="line"></span><br><span class="line">    ArrayData* out_arr = output.<span class="built_in">array_data</span>().<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">if</span> (output_type_.type-&gt;<span class="built_in">id</span>() == Type::NA) &#123;</span><br><span class="line">      out_arr-&gt;null_count = out_arr-&gt;length;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kernel_-&gt;null_handling == NullHandling::INTERSECTION) &#123;</span><br><span class="line">      <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">PropagateNulls</span>(kernel_ctx_, input, out_arr));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (kernel_-&gt;null_handling == NullHandling::OUTPUT_NOT_NULL) &#123;</span><br><span class="line">      out_arr-&gt;null_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_NOT_OK</span>(kernel_-&gt;<span class="built_in">exec</span>(kernel_ctx_, input, &amp;output));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output type didn&#x27;t change</span></span><br><span class="line">    <span class="built_in">DCHECK</span>(output.<span class="built_in">is_array_data</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emit a result for each chunk</span></span><br><span class="line">    <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">EmitResult</span>(std::<span class="built_in">move</span>(output.<span class="built_in">array_data</span>()), listener));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Kernel-的类型匹配"><a href="#Kernel-的类型匹配" class="headerlink" title="Kernel 的类型匹配"></a>Kernel 的类型匹配</h4><p>还有一个比较重要的是 Kernel 函数的类型匹配，这里会根据 <code>Matches</code> 来挑选对应的类型来进行匹配。我们回到 <code>ExecuteInternal</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;Datum&gt; <span class="title">ExecuteInternal</span><span class="params">(<span class="type">const</span> Function&amp; func, std::vector&lt;Datum&gt; args,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int64_t</span> passed_length, <span class="type">const</span> FunctionOptions* options,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ExecContext* ctx)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(<span class="keyword">auto</span> inputs, internal::<span class="built_in">GetFunctionArgumentTypes</span>(args));</span><br><span class="line">  <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(<span class="keyword">auto</span> func_exec, func.<span class="built_in">GetBestExecutor</span>(inputs));</span><br><span class="line">  <span class="built_in">ARROW_RETURN_NOT_OK</span>(func_exec-&gt;<span class="built_in">Init</span>(options, ctx));</span><br><span class="line">  <span class="keyword">return</span> func_exec-&gt;<span class="built_in">Execute</span>(args, passed_length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会:</p>
<ol>
<li><code>GetBestExecutor</code>，根据 <code>Function::DispatchBest</code> 来找到对应的 <code>Kernel</code>，然后创建 <code>FunctionExecutor</code>. <code>Dispatch</code> 默认走的是 <code>DispatchExact</code>，就是找到完全对应的输入。有的时候根据需求不同，可能会插入一些 <code>Cast</code></li>
<li>在 <code>func_exec-&gt;Init</code> 阶段，去 Init 需要的内容</li>
<li>调用 <code>func_exec-&gt;Execute</code></li>
</ol>
<p>Dispatch 的签名如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// \brief Return a best-match kernel that can execute the function given the argument</span></span><br><span class="line"><span class="comment">/// types, after implicit casts are applied.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \param[in,out] values Argument types. An element may be modified to</span></span><br><span class="line"><span class="comment">/// indicate that the returned kernel only approximately matches the input</span></span><br><span class="line"><span class="comment">/// value descriptors; callers are responsible for casting inputs to the type</span></span><br><span class="line"><span class="comment">/// required by the kernel.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Result&lt;<span class="type">const</span> Kernel*&gt; <span class="title">DispatchBest</span><span class="params">(std::vector&lt;TypeHolder&gt;* values)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们再以 Add 为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArithmeticFunction</span> : ScalarFunction &#123;</span><br><span class="line">  <span class="keyword">using</span> ScalarFunction::ScalarFunction;</span><br><span class="line"></span><br><span class="line">  <span class="function">Result&lt;<span class="type">const</span> Kernel*&gt; <span class="title">DispatchBest</span><span class="params">(std::vector&lt;TypeHolder&gt;* types)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">CheckArity</span>(types-&gt;<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">CheckDecimals</span>(types));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> arrow::compute::detail::DispatchExactImpl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> kernel = <span class="built_in">DispatchExactImpl</span>(<span class="keyword">this</span>, *types)) <span class="keyword">return</span> kernel;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnsureDictionaryDecoded</span>(types);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only promote types for binary functions</span></span><br><span class="line">    <span class="keyword">if</span> (types-&gt;<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">ReplaceNullWithOtherType</span>(types);</span><br><span class="line">      TimeUnit::type finest_unit;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">CommonTemporalResolution</span>(types-&gt;<span class="built_in">data</span>(), types-&gt;<span class="built_in">size</span>(), &amp;finest_unit)) &#123;</span><br><span class="line">        <span class="built_in">ReplaceTemporalTypes</span>(finest_unit, types);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (TypeHolder type = <span class="built_in">CommonNumeric</span>(*types)) &#123;</span><br><span class="line">          <span class="built_in">ReplaceTypes</span>(type, types);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> kernel = <span class="built_in">DispatchExactImpl</span>(<span class="keyword">this</span>, *types)) <span class="keyword">return</span> kernel;</span><br><span class="line">    <span class="keyword">return</span> arrow::compute::detail::<span class="built_in">NoMatchingKernel</span>(<span class="keyword">this</span>, *types);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个地方就是创建所有需要的上下文，<code>Kernel</code> 的挑选来自于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// \brief An type-checking interface to permit customizable validation rules</span></span><br><span class="line"><span class="comment">/// for use with InputType and KernelSignature. This is for scenarios where the</span></span><br><span class="line"><span class="comment">/// acceptance is not an exact type instance, such as a TIMESTAMP type for a</span></span><br><span class="line"><span class="comment">/// specific TimeUnit, but permitting any time zone.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ARROW_EXPORT</span> TypeMatcher &#123;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">TypeMatcher</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Return true if this matcher accepts the data type.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Matches</span><span class="params">(<span class="type">const</span> DataType&amp; type)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief A human-interpretable string representation of what the type</span></span><br><span class="line">  <span class="comment">/// matcher checks for, usable when printing KernelSignature or formatting</span></span><br><span class="line">  <span class="comment">/// error messages.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Return true if this TypeMatcher contains the same matching rule as</span></span><br><span class="line">  <span class="comment">/// the other. Currently depends on RTTI.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">Equals</span><span class="params">(<span class="type">const</span> TypeMatcher&amp; other)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里也允许 <code>Output</code> 计算出对应的输出类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// \brief Container to capture both exact and input-dependent output types.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ARROW_EXPORT</span> OutputType &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// \brief An enum indicating whether the value type is an invariant fixed</span></span><br><span class="line">  <span class="comment">/// value or one that&#x27;s computed by a kernel-defined resolver function.</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">ResolveKind</span> &#123; FIXED, COMPUTED &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Type resolution function. Given input types, return output type.  This</span></span><br><span class="line">  <span class="comment">/// function MAY may use the kernel state to decide the output type based on</span></span><br><span class="line">  <span class="comment">/// the FunctionOptions.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// This function SHOULD _not_ be used to check for arity, that is to be</span></span><br><span class="line">  <span class="comment">/// performed one or more layers above.</span></span><br><span class="line">  <span class="keyword">using</span> Resolver = <span class="built_in">Result</span>&lt;TypeHolder&gt; (*)(KernelContext*, <span class="type">const</span> std::vector&lt;TypeHolder&gt;&amp;);</span><br></pre></td></tr></table></figure>
<p>在 Init 的时候逻辑如下. 这里 <code>Add</code> 对应的上下文不太多。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">KernelInit</span><span class="params">(<span class="type">const</span> FunctionOptions* options)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">CheckOptions</span>(func, options));</span><br><span class="line">  <span class="keyword">if</span> (options == NULLPTR) &#123;</span><br><span class="line">    options = func.<span class="built_in">default_options</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (kernel-&gt;init) &#123;</span><br><span class="line">    <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(state,</span><br><span class="line">                          kernel-&gt;<span class="built_in">init</span>(&amp;kernel_ctx, &#123;kernel, in_types, options&#125;));</span><br><span class="line">    kernel_ctx.<span class="built_in">SetState</span>(state.<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RETURN_NOT_OK</span>(executor-&gt;<span class="built_in">Init</span>(&amp;kernel_ctx, &#123;kernel, in_types, options&#125;));</span><br><span class="line">  <span class="keyword">this</span>-&gt;options = options;</span><br><span class="line">  inited = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Init</span><span class="params">(<span class="type">const</span> FunctionOptions* options, ExecContext* exec_ctx)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (exec_ctx == NULLPTR) &#123;</span><br><span class="line">    exec_ctx = <span class="built_in">default_exec_context</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  kernel_ctx = KernelContext&#123;exec_ctx, kernel&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">KernelInit</span>(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章简单串了一下最简单的 Add 执行的流程，限于本人目前水平和篇幅，这部分不会很详细。等待本人更熟悉 Runtime 代码再扩充本文的内容。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">概念介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-CallFunction-%E5%92%8C-%E2%80%9Cadd%E2%80%9D-%E7%9C%8B%E8%B5%B7"><span class="toc-number">2.</span> <span class="toc-text">从 CallFunction 和 “add” 看起</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FunctionRegistry"><span class="toc-number">2.0.1.</span> <span class="toc-text">FunctionRegistry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function"><span class="toc-number">2.0.2.</span> <span class="toc-text">Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kernel-%E6%89%A7%E8%A1%8C%E5%99%A8%E5%92%8C%E9%80%BB%E8%BE%91%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">2.0.3.</span> <span class="toc-text">Kernel 执行器和逻辑的生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kernel-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D"><span class="toc-number">2.0.4.</span> <span class="toc-text">Kernel 的类型匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2023/05/27/Arrow-Compute/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&text=Arrow Compute: CallFunction and Add"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&title=Arrow Compute: CallFunction and Add"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&is_video=false&description=Arrow Compute: CallFunction and Add"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Arrow Compute: CallFunction and Add&body=Check out this article: http://blog.mwish.me/2023/05/27/Arrow-Compute/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&title=Arrow Compute: CallFunction and Add"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&title=Arrow Compute: CallFunction and Add"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&title=Arrow Compute: CallFunction and Add"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&title=Arrow Compute: CallFunction and Add"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2023/05/27/Arrow-Compute/&name=Arrow Compute: CallFunction and Add&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2023/05/27/Arrow-Compute/&t=Arrow Compute: CallFunction and Add"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2024
    mwish
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FL51GBW6JT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FL51GBW6JT');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
