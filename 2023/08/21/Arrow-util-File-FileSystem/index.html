<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="FileSystem 可以看作 Arrow 的数据访问层（不太像 fs，而是一个虚拟的文件系统）。只不过它兼容的不是 POSIX 语义，而是自己在上面封了一套各种接口。具体可以看：  https:&#x2F;&#x2F;arrow.apache.org&#x2F;docs&#x2F;cpp&#x2F;api&#x2F;filesystem.html https:&#x2F;&#x2F;arrow.apache.org&#x2F;docs&#x2F;cpp&#x2F;api&#x2F;io.html  相关目录在：">
<meta property="og:type" content="article">
<meta property="og:title" content="Arrow util: File &amp; FileSystem">
<meta property="og:url" content="http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/index.html">
<meta property="og:site_name" content="风空之岛">
<meta property="og:description" content="FileSystem 可以看作 Arrow 的数据访问层（不太像 fs，而是一个虚拟的文件系统）。只不过它兼容的不是 POSIX 语义，而是自己在上面封了一套各种接口。具体可以看：  https:&#x2F;&#x2F;arrow.apache.org&#x2F;docs&#x2F;cpp&#x2F;api&#x2F;filesystem.html https:&#x2F;&#x2F;arrow.apache.org&#x2F;docs&#x2F;cpp&#x2F;api&#x2F;io.html  相关目录在：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-21T11:40:00.000Z">
<meta property="article:modified_time" content="2023-08-21T11:35:22.576Z">
<meta property="article:author" content="mwish">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/logo.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico">
        
      
    
    <!-- title -->
    <title>Arrow util: File &amp; FileSystem</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/09/05/It%E2%80%99s-not-always-obvious-when-tail-call-optimization-is-allowed/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/08/03/Arrow-Acero-Framework/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&text=Arrow util: File &amp; FileSystem"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&title=Arrow util: File &amp; FileSystem"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&is_video=false&description=Arrow util: File &amp; FileSystem"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Arrow util: File &amp; FileSystem&body=Check out this article: http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&title=Arrow util: File &amp; FileSystem"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&title=Arrow util: File &amp; FileSystem"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&title=Arrow util: File &amp; FileSystem"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&title=Arrow util: File &amp; FileSystem"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&name=Arrow util: File &amp; FileSystem&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&t=Arrow util: File &amp; FileSystem"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#FileSystem"><span class="toc-number">1.</span> <span class="toc-text">FileSystem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IOContext-and-Executor"><span class="toc-number">1.1.</span> <span class="toc-text">IOContext and Executor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">文件系统的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List-%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">List 文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dir-Operations"><span class="toc-number">1.3.</span> <span class="toc-text">Dir Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-and-Stream-Operations"><span class="toc-number">1.4.</span> <span class="toc-text">File and Stream Operations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File"><span class="toc-number">2.</span> <span class="toc-text">File</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffered-and-Memory-Layer"><span class="toc-number">2.0.1.</span> <span class="toc-text">Buffered and Memory Layer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transform"><span class="toc-number">2.1.</span> <span class="toc-text">Transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Caching-Layer"><span class="toc-number">2.2.</span> <span class="toc-text">Memory Caching Layer</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Arrow util: File &amp; FileSystem
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">mwish</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-08-21T11:40:00.000Z" itemprop="datePublished">2023-08-21</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>FileSystem 可以看作 Arrow 的数据访问层（不太像 fs，而是一个虚拟的文件系统）。只不过它兼容的不是 POSIX 语义，而是自己在上面封了一套各种接口。具体可以看：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://arrow.apache.org/docs/cpp/api/filesystem.html">https://arrow.apache.org/docs/cpp/api/filesystem.html</a></li>
<li><a target="_blank" rel="noopener" href="https://arrow.apache.org/docs/cpp/api/io.html">https://arrow.apache.org/docs/cpp/api/io.html</a></li>
</ul>
<p>相关目录在：</p>
<ul>
<li><code>cpp/src/io/interface.h</code>: 包含 file 本身部分接口、IO 的接口和所有的接口</li>
<li><code>cpp/src/io/file.h</code>: 包含 file 本身部分接口、IO 的接口和所有的接口</li>
<li><code>cpp/src/arrow/filesystem</code>: 包含 fs 部分实现和所有的接口<ul>
<li><code>hdfs.h</code> 下有个 <code>arrow::io::FileSystem</code>，这不是一套东西.</li>
</ul>
</li>
</ul>
<h2 id="FileSystem"><a href="#FileSystem" class="headerlink" title="FileSystem"></a>FileSystem</h2><p>FileSystem 这层抽象能够辨别出一个类似文件的语义，它的概念没有下层到 FS/VFS/Node 这样的层面。我个人理解，它对应的语义是：文件/目录 的 带规则的 List / Open / Delete / Create / GetInfo，其中还包含 Copy / Move(Rename) 这样的语义。同时提供了一些 async 或者类似 Batch 的接口。</p>
<p>FileSystem 这里有一些下面的子类：</p>
<blockquote>
<p>Subclassed by <a target="_blank" rel="noopener" href="https://arrow.apache.org/docs/cpp/api/filesystem.html#classarrow_1_1fs_1_1_gcs_file_system">arrow::fs::GcsFileSystem</a>, <a target="_blank" rel="noopener" href="https://arrow.apache.org/docs/cpp/api/filesystem.html#classarrow_1_1fs_1_1_hadoop_file_system">arrow::fs::HadoopFileSystem</a>, arrow::fs::internal::MockFileSystem, <a target="_blank" rel="noopener" href="https://arrow.apache.org/docs/cpp/api/filesystem.html#classarrow_1_1fs_1_1_local_file_system">arrow::fs::LocalFileSystem</a>, <a target="_blank" rel="noopener" href="https://arrow.apache.org/docs/cpp/api/filesystem.html#classarrow_1_1fs_1_1_s3_file_system">arrow::fs::S3FileSystem</a>, arrow::fs::SlowFileSystem, <a target="_blank" rel="noopener" href="https://arrow.apache.org/docs/cpp/api/filesystem.html#classarrow_1_1fs_1_1_sub_tree_file_system">arrow::fs::SubTreeFileSystem</a></p>
</blockquote>
<p>Local, S3, GCS, Hadoop 这几个虽然各有各的优化，但是一看名字你就懂他们是些啥。我们额外解释一下几个别的 FS:</p>
<ul>
<li><code>SlowFileSystem</code> 注入延时，是给测试用的，见下文：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// \brief A FileSystem implementation that delegates to another</span></span><br><span class="line"><span class="comment">/// implementation but inserts latencies at various points.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ARROW_EXPORT</span> SlowFileSystem : <span class="keyword">public</span> FileSystem &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SlowFileSystem</span>(std::shared_ptr&lt;FileSystem&gt; base_fs,</span><br><span class="line">                 std::shared_ptr&lt;io::LatencyGenerator&gt; latencies);</span><br><span class="line">  <span class="built_in">SlowFileSystem</span>(std::shared_ptr&lt;FileSystem&gt; base_fs, <span class="type">double</span> average_latency);</span><br><span class="line">  <span class="built_in">SlowFileSystem</span>(std::shared_ptr&lt;FileSystem&gt; base_fs, <span class="type">double</span> average_latency,</span><br><span class="line">                 <span class="type">int32_t</span> seed);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>MockFIleSystem</code>: 把所有内容持有在内存中的 FileSystem，应该是给测试用的</li>
<li><code>SubTreeFileSystem</code>: 感觉像是某个 base filesystem，给一个子路径的 “SubTree” 文件系统</li>
</ul>
<p>这里 arrow 内部还支持了一套统一的 URL 系统，然后从 URL 系统中 load 出来对应的 path。比如 <code>gcs://</code>, 内容是 <code>FileSystemFromUri</code>. 需要注意的是本地文件是 <code>file://</code> 这类的前缀。</p>
<p>话说到这里，每个文件系统还有一些文件和路径的概念，Arrow 是怎么映射这些文件和路径的呢？Arrow FileSystem 定义了 <code>NormalizeFilePath</code>，专门处理一些 Windows Path / SubTreeSystem 之类的路径之类的内容，来给路径的逻辑做了统一的处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;std::string&gt; <span class="title">SubTreeFileSystem::NormalizePath</span><span class="params">(std::string path)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(<span class="keyword">auto</span> real_path, <span class="built_in">PrependBase</span>(path));</span><br><span class="line">  <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(<span class="keyword">auto</span> normalized, base_fs_-&gt;<span class="built_in">NormalizePath</span>(real_path));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">StripBase</span>(std::<span class="built_in">move</span>(normalized));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在介绍 FileSystem 之前，我们先介绍一下系统运行的上下文。</p>
<h3 id="IOContext-and-Executor"><a href="#IOContext-and-Executor" class="headerlink" title="IOContext and Executor"></a>IOContext and Executor</h3><p>IOContext 是 Parquet 文件读取的「上下文」。因为 arrow 用的 C++17 没有标准的 async 模型，所以这里基本上还是用 IO 线程池包装了同步的接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// EXPERIMENTAL: options provider for IO tasks</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Includes an Executor (which will be used to execute asynchronous reads),</span></span><br><span class="line"><span class="comment">/// a MemoryPool (which will be used to allocate buffers when zero copy reads</span></span><br><span class="line"><span class="comment">/// are not possible), and an external id (in case the executor receives tasks from</span></span><br><span class="line"><span class="comment">/// multiple sources and must distinguish tasks associated with this IOContext).</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ARROW_EXPORT</span> IOContext &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  MemoryPool* pool_;</span><br><span class="line">  ::arrow::internal::Executor* executor_;</span><br><span class="line">  <span class="type">int64_t</span> external_id_;</span><br><span class="line">  StopToken stop_token_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>别的都很好理解，<code>external_id_</code> 是一个类似 IOTag 的东西。我看它这里没有做很细的 tag，就基于 id 判断一下。这里它把 <code>SubmitIO</code> 包装成异步的了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... SubmitArgs&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">SubmitIO</span><span class="params">(IOContext io_context, SubmitArgs&amp;&amp;... submit_args)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;::arrow::internal::Executor*&gt;()-&gt;Submit(submit_args...))</span> </span>&#123;</span><br><span class="line">  ::arrow::internal::TaskHints hints;</span><br><span class="line">  hints.external_id = io_context.<span class="built_in">external_id</span>();</span><br><span class="line">  <span class="keyword">return</span> io_context.<span class="built_in">executor</span>()-&gt;<span class="built_in">Submit</span>(hints, io_context.<span class="built_in">stop_token</span>(),</span><br><span class="line">                                       std::forward&lt;SubmitArgs&gt;(submit_args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里具体提交 IO 的时候还有一些 TaskHint，但是好像没有什么人真的用了这一套。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hints about a task that may be used by an Executor.</span></span><br><span class="line"><span class="comment">// They are ignored by the provided ThreadPool implementation.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskHints</span> &#123;</span><br><span class="line">  <span class="comment">// The lower, the more urgent</span></span><br><span class="line">  <span class="type">int32_t</span> priority = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// The IO transfer size in bytes</span></span><br><span class="line">  <span class="type">int64_t</span> io_size = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// The approximate CPU cost in number of instructions</span></span><br><span class="line">  <span class="type">int64_t</span> cpu_cost = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// An application-specific ID</span></span><br><span class="line">  <span class="type">int64_t</span> external_id = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于 Executor，这里可以当成 IO 线程的包装器接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ARROW_EXPORT</span> Executor &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> StopCallback = internal::FnOnce&lt;<span class="built_in">void</span>(<span class="type">const</span> Status&amp;)&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Executor</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Spawn a fire-and-forget task.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Function&gt;</span><br><span class="line">  <span class="function">Status <span class="title">Spawn</span><span class="params">(...)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Transfers a future to this executor.  Any continuations added to the</span></span><br><span class="line">  <span class="comment">// returned future will run in this executor.  Otherwise they would run</span></span><br><span class="line">  <span class="comment">// on the same thread that called MarkFinished.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This is necessary when (for example) an I/O task is completing a future.</span></span><br><span class="line">  <span class="comment">// The continuations of that future should run on the CPU thread pool keeping</span></span><br><span class="line">  <span class="comment">// CPU heavy work off the I/O thread pool.  So the I/O task should transfer</span></span><br><span class="line">  <span class="comment">// the future to the CPU executor before returning.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// By default this method will only transfer if the future is not already completed.  If</span></span><br><span class="line">  <span class="comment">// the future is already completed then any callback would be run synchronously and so</span></span><br><span class="line">  <span class="comment">// no transfer is typically necessary.  However, in cases where you want to force a</span></span><br><span class="line">  <span class="comment">// transfer (e.g. to help the scheduler break up units of work across multiple cores)</span></span><br><span class="line">  <span class="comment">// then you can override this behavior with `always_transfer`.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Transfer 完成的是一个这样的逻辑，比方说用户的线程是一个 IO 线程，那么可能这里会访问的时候不太希望是在</span></span><br><span class="line">  <span class="comment">// CPU Thread 去接受. 当然 Transfer 对于已经完成的 Future 可能会有点奇怪, 因为它实现是直接挂 callback</span></span><br><span class="line">  <span class="comment">// 的.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">Future&lt;T&gt; <span class="title">Transfer</span><span class="params">(Future&lt;T&gt; future)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Overload of Transfer which will always schedule callbacks on new threads even if the</span></span><br><span class="line">  <span class="comment">// future is finished when the callback is added.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This can be useful in cases where you want to ensure parallelism</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 强制 Transfer 操作.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">Future&lt;T&gt; <span class="title">TransferAlways</span><span class="params">(Future&lt;T&gt; future)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Return the level of parallelism (the number of tasks that may be executed</span></span><br><span class="line">  <span class="comment">// concurrently).  This may be an approximate number.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetCapacity</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if the thread from which this function is called is owned by this</span></span><br><span class="line">  <span class="comment">// Executor. Returns false if this Executor does not support this property.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">OwnsThisThread</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if this is the current executor being called</span></span><br><span class="line">  <span class="comment">// n.b. this defaults to just calling OwnsThisThread</span></span><br><span class="line">  <span class="comment">// unless the threadpool is disabled</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsCurrentExecutor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">OwnsThisThread</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// \brief An interface to represent something with a custom destructor</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// \see KeepAlive</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ARROW_EXPORT</span> Resource &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Resource</span>() = <span class="keyword">default</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Keep a resource alive until all executor threads have terminated</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Executors may have static storage duration.  In particular, the CPU and I/O</span></span><br><span class="line">  <span class="comment">/// executors are currently implemented this way.  These threads may access other</span></span><br><span class="line">  <span class="comment">/// objects with static storage duration such as the OpenTelemetry runtime context</span></span><br><span class="line">  <span class="comment">/// the default memory pool, or other static executors.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// The order in which these objects are destroyed is difficult to control.  In order</span></span><br><span class="line">  <span class="comment">/// to ensure those objects remain alive until all threads have finished those objects</span></span><br><span class="line">  <span class="comment">/// should be wrapped in a Resource object and passed into this method.  The given</span></span><br><span class="line">  <span class="comment">/// shared_ptr will be kept alive until all threads have finished their worker loops.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">KeepAlive</span><span class="params">(std::shared_ptr&lt;Resource&gt; resource)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// Subclassing API</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">SpawnReal</span><span class="params">(TaskHints hints, FnOnce&lt;<span class="type">void</span>()&gt; task, StopToken,</span></span></span><br><span class="line"><span class="params"><span class="function">                           StopCallback&amp;&amp;)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这部分接口其实都相对比较好理解.</p>
<p>先介绍几个比较好理解的接口：</p>
<ol>
<li><code>KeepAlive</code>: 生命周期 Ordering 维护器</li>
<li><code>OwnsThisThread()</code> 这部分实现很有意思，<code>ThreadPool</code> 实现这个的时候套了一层 <code>threadlocal</code>，我们可以看看</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> ThreadPool* current_thread_pool_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ThreadPool::OwnsThisThread</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> current_thread_pool_ == <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::LaunchWorkersUnlocked</span><span class="params">(<span class="type">int</span> threads)</span> </span>&#123;</span><br><span class="line">  std::shared_ptr&lt;State&gt; state = sp_state_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threads; i++) &#123;</span><br><span class="line">    state_-&gt;workers_.<span class="built_in">emplace_back</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = --(state_-&gt;workers_.<span class="built_in">end</span>());</span><br><span class="line">    *it = std::<span class="built_in">thread</span>([<span class="keyword">this</span>, state, it] &#123;</span><br><span class="line">      current_thread_pool_ = <span class="keyword">this</span>;</span><br><span class="line">      <span class="built_in">WorkerLoop</span>(state, it);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以直接看看 <code>Transfer</code> 的实现，这段处理的比较有意思</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> FT = Future&lt;T&gt;, <span class="keyword">typename</span> FTSync = <span class="keyword">typename</span> FT::SyncType&gt;</span><br><span class="line">Future&lt;T&gt; <span class="built_in">DoTransfer</span>(Future&lt;T&gt; future, <span class="type">bool</span> always_transfer = <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">auto</span> transferred = Future&lt;T&gt;::<span class="built_in">Make</span>();</span><br><span class="line">  <span class="keyword">if</span> (always_transfer) &#123;</span><br><span class="line">    CallbackOptions callback_options = CallbackOptions::<span class="built_in">Defaults</span>();</span><br><span class="line">    callback_options.should_schedule = ShouldSchedule::Always;</span><br><span class="line">    callback_options.executor = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">auto</span> sync_callback = [transferred](<span class="type">const</span> FTSync&amp; result) <span class="keyword">mutable</span> &#123;</span><br><span class="line">      transferred.<span class="built_in">MarkFinished</span>(result);</span><br><span class="line">    &#125;;</span><br><span class="line">    future.<span class="built_in">AddCallback</span>(sync_callback, callback_options);</span><br><span class="line">    <span class="keyword">return</span> transferred;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We could use AddCallback&#x27;s ShouldSchedule::IfUnfinished but we can save a bit of</span></span><br><span class="line">  <span class="comment">// work by doing the test here.</span></span><br><span class="line">  <span class="keyword">auto</span> callback = [<span class="keyword">this</span>, transferred](<span class="type">const</span> FTSync&amp; result) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> spawn_status =</span><br><span class="line">        <span class="built_in">Spawn</span>([transferred, result]() <span class="keyword">mutable</span> &#123; transferred.<span class="built_in">MarkFinished</span>(result); &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!spawn_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      transferred.<span class="built_in">MarkFinished</span>(spawn_status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">auto</span> callback_factory = [&amp;callback]() &#123; <span class="keyword">return</span> callback; &#125;;</span><br><span class="line">  <span class="keyword">if</span> (future.<span class="built_in">TryAddCallback</span>(callback_factory)) &#123;</span><br><span class="line">    <span class="keyword">return</span> transferred;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If the future is already finished and we aren&#x27;t going to force spawn a thread</span></span><br><span class="line">  <span class="comment">// then we don&#x27;t need to add another layer of callback and can return the original</span></span><br><span class="line">  <span class="comment">// future</span></span><br><span class="line">  <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很清晰：</p>
<ol>
<li>如果是 <code>always_transfer</code>，那么就可以创建一个 callback，直接挂过去</li>
<li>否则，尝试开一个 transfer &amp; callback 的 thread, 尝试 async 去 MarkFinish. 如果 Future 已经 finish 了，这部分逻辑倒是很好解决了。</li>
</ol>
<h3 id="文件系统的接口"><a href="#文件系统的接口" class="headerlink" title="文件系统的接口"></a>文件系统的接口</h3><p>这里有些比较好玩的，首先看 <code>FileSystem</code> 这个基类</p>
<h4 id="List-文件"><a href="#List-文件" class="headerlink" title="List 文件"></a>List 文件</h4><p>这里会有一些对 Stream Open 的支持，可以打开 File 之类的操作，和根据 FileSelector 去 List 的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Get info for the given target.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Any symlink is automatically dereferenced, recursively.</span></span><br><span class="line"><span class="comment">/// A nonexistent or unreachable file returns an Ok status and</span></span><br><span class="line"><span class="comment">/// has a FileType of value NotFound.  An error status indicates</span></span><br><span class="line"><span class="comment">/// a truly exceptional condition (low-level I/O error, etc.).</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Result&lt;FileInfo&gt; <span class="title">GetFileInfo</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">/// Same, for many targets at once.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Result&lt;FileInfoVector&gt; <span class="title">GetFileInfo</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; paths)</span></span>;</span><br><span class="line"><span class="comment">/// Same, according to a selector.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The selector&#x27;s base directory will not be part of the results, even if</span></span><br><span class="line"><span class="comment">/// it exists.</span></span><br><span class="line"><span class="comment">/// If it doesn&#x27;t exist, see `FileSelector::allow_not_found`.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Result&lt;FileInfoVector&gt; <span class="title">GetFileInfo</span><span class="params">(<span class="type">const</span> FileSelector&amp; select)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Async version of GetFileInfo</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Future&lt;FileInfoVector&gt; <span class="title">GetFileInfoAsync</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; paths)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Streaming async version of GetFileInfo</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The returned generator is not async-reentrant, i.e. you need to wait for</span></span><br><span class="line"><span class="comment">/// the returned future to complete before calling the generator again.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> FileInfoGenerator <span class="title">GetFileInfoGenerator</span><span class="params">(<span class="type">const</span> FileSelector&amp; select)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里观察到有一个 <code>FileSelector</code> 接口，实际上这里也会支持一些过滤规则，然后尽量下推</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// \brief File selector for filesystem APIs</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ARROW_EXPORT</span> FileSelector &#123;</span><br><span class="line">  <span class="comment">/// The directory in which to select files.</span></span><br><span class="line">  <span class="comment">/// If the path exists but doesn&#x27;t point to a directory, this should be an error.</span></span><br><span class="line">  std::string base_dir;</span><br><span class="line">  <span class="comment">/// The behavior if `base_dir` isn&#x27;t found in the filesystem.  If false,</span></span><br><span class="line">  <span class="comment">/// an error is returned.  If true, an empty selection is returned.</span></span><br><span class="line">  <span class="type">bool</span> allow_not_found;</span><br><span class="line">  <span class="comment">/// Whether to recurse into subdirectories.</span></span><br><span class="line">  <span class="type">bool</span> recursive;</span><br><span class="line">  <span class="comment">/// The maximum number of subdirectories to recurse into.</span></span><br><span class="line">  <span class="type">int32_t</span> max_recursion;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FileSelector</span>() : <span class="built_in">allow_not_found</span>(<span class="literal">false</span>), <span class="built_in">recursive</span>(<span class="literal">false</span>), <span class="built_in">max_recursion</span>(INT32_MAX) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Dir-Operations"><a href="#Dir-Operations" class="headerlink" title="Dir Operations"></a>Dir Operations</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Create a directory and subdirectories.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This function succeeds if the directory already exists.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">CreateDir</span><span class="params">(<span class="type">const</span> std::string&amp; path, <span class="type">bool</span> recursive = <span class="literal">true</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Delete a directory and its contents, recursively.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">DeleteDir</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Delete a directory&#x27;s contents, recursively.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Like DeleteDir, but doesn&#x27;t delete the directory itself.</span></span><br><span class="line"><span class="comment">/// Passing an empty path (&quot;&quot; or &quot;/&quot;) is disallowed, see DeleteRootDirContents.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">DeleteDirContents</span><span class="params">(<span class="type">const</span> std::string&amp; path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">bool</span> missing_dir_ok = <span class="literal">false</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Async version of DeleteDirContents.</span></span><br><span class="line"><span class="keyword">virtual</span> Future&lt;&gt; <span class="built_in">DeleteDirContentsAsync</span>(<span class="type">const</span> std::string&amp; path,</span><br><span class="line">                                        <span class="type">bool</span> missing_dir_ok = <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// EXPERIMENTAL: Delete the root directory&#x27;s contents, recursively.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Implementations may decide to raise an error if this operation is</span></span><br><span class="line"><span class="comment">/// too dangerous.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> may decide to remove this if it&#x27;s deemed not useful</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">DeleteRootDirContents</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="File-and-Stream-Operations"><a href="#File-and-Stream-Operations" class="headerlink" title="File and Stream Operations"></a>File and Stream Operations</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Delete a file.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">DeleteFile</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">/// Delete many files.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The default implementation issues individual delete operations in sequence.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">DeleteFiles</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; paths)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Move / rename a file or directory.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// If the destination exists:</span></span><br><span class="line"><span class="comment">/// - if it is a non-empty directory, an error is returned</span></span><br><span class="line"><span class="comment">/// - otherwise, if it has the same type as the source, it is replaced</span></span><br><span class="line"><span class="comment">/// - otherwise, behavior is unspecified (implementation-dependent).</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Move</span><span class="params">(<span class="type">const</span> std::string&amp; src, <span class="type">const</span> std::string&amp; dest)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Copy a file.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// If the destination exists and is a directory, an error is returned.</span></span><br><span class="line"><span class="comment">/// Otherwise, it is replaced.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">CopyFile</span><span class="params">(<span class="type">const</span> std::string&amp; src, <span class="type">const</span> std::string&amp; dest)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Open an input stream for sequential reading.</span></span><br><span class="line"><span class="keyword">virtual</span> Result&lt;std::shared_ptr&lt;io::InputStream&gt;&gt; <span class="built_in">OpenInputStream</span>(</span><br><span class="line">    <span class="type">const</span> std::string&amp; path) = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/// Open an input stream for sequential reading.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This override assumes the given FileInfo validly represents the file&#x27;s</span></span><br><span class="line"><span class="comment">/// characteristics, and may optimize access depending on them (for example</span></span><br><span class="line"><span class="comment">/// avoid querying the file size or its existence).</span></span><br><span class="line"><span class="keyword">virtual</span> Result&lt;std::shared_ptr&lt;io::InputStream&gt;&gt; <span class="built_in">OpenInputStream</span>(<span class="type">const</span> FileInfo&amp; info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Open an input file for random access reading.</span></span><br><span class="line"><span class="keyword">virtual</span> Result&lt;std::shared_ptr&lt;io::RandomAccessFile&gt;&gt; <span class="built_in">OpenInputFile</span>(</span><br><span class="line">    <span class="type">const</span> std::string&amp; path) = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/// Open an input file for random access reading.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This override assumes the given FileInfo validly represents the file&#x27;s</span></span><br><span class="line"><span class="comment">/// characteristics, and may optimize access depending on them (for example</span></span><br><span class="line"><span class="comment">/// avoid querying the file size or its existence).</span></span><br><span class="line"><span class="keyword">virtual</span> Result&lt;std::shared_ptr&lt;io::RandomAccessFile&gt;&gt; <span class="built_in">OpenInputFile</span>(</span><br><span class="line">    <span class="type">const</span> FileInfo&amp; info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Async version of OpenInputStream</span></span><br><span class="line"><span class="keyword">virtual</span> Future&lt;std::shared_ptr&lt;io::InputStream&gt;&gt; <span class="built_in">OpenInputStreamAsync</span>(</span><br><span class="line">    <span class="type">const</span> std::string&amp; path);</span><br><span class="line"><span class="comment">/// Async version of OpenInputStream</span></span><br><span class="line"><span class="keyword">virtual</span> Future&lt;std::shared_ptr&lt;io::InputStream&gt;&gt; <span class="built_in">OpenInputStreamAsync</span>(</span><br><span class="line">    <span class="type">const</span> FileInfo&amp; info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Async version of OpenInputFile</span></span><br><span class="line"><span class="keyword">virtual</span> Future&lt;std::shared_ptr&lt;io::RandomAccessFile&gt;&gt; <span class="built_in">OpenInputFileAsync</span>(</span><br><span class="line">    <span class="type">const</span> std::string&amp; path);</span><br><span class="line"><span class="comment">/// Async version of OpenInputFile</span></span><br><span class="line"><span class="keyword">virtual</span> Future&lt;std::shared_ptr&lt;io::RandomAccessFile&gt;&gt; <span class="built_in">OpenInputFileAsync</span>(</span><br><span class="line">    <span class="type">const</span> FileInfo&amp; info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Open an output stream for sequential writing.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// If the target already exists, existing data is truncated.</span></span><br><span class="line"><span class="keyword">virtual</span> Result&lt;std::shared_ptr&lt;io::OutputStream&gt;&gt; <span class="built_in">OpenOutputStream</span>(</span><br><span class="line">    <span class="type">const</span> std::string&amp; path,</span><br><span class="line">    <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> KeyValueMetadata&gt;&amp; metadata) = <span class="number">0</span>;</span><br><span class="line">Result&lt;std::shared_ptr&lt;io::OutputStream&gt;&gt; <span class="built_in">OpenOutputStream</span>(<span class="type">const</span> std::string&amp; path);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Open an output stream for appending.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// If the target doesn&#x27;t exist, a new empty file is created.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Note: some filesystem implementations do not support efficient appending</span></span><br><span class="line"><span class="comment">/// to an existing file, in which case this method will return NotImplemented.</span></span><br><span class="line"><span class="comment">/// Consider writing to multiple files (using e.g. the dataset layer) instead.</span></span><br><span class="line"><span class="keyword">virtual</span> Result&lt;std::shared_ptr&lt;io::OutputStream&gt;&gt; <span class="built_in">OpenAppendStream</span>(</span><br><span class="line">    <span class="type">const</span> std::string&amp; path,</span><br><span class="line">    <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> KeyValueMetadata&gt;&amp; metadata) = <span class="number">0</span>;</span><br><span class="line">Result&lt;std::shared_ptr&lt;io::OutputStream&gt;&gt; <span class="built_in">OpenAppendStream</span>(<span class="type">const</span> std::string&amp; path);</span><br></pre></td></tr></table></figure>
<p>这里它打开文件，本身都是 Sync 或者 Async 的，而打开后的接口，可能有不同的 Sync Async 模型。根据我个人的理解，这个可能是个开发者责任制。比如某个接口在非关键路径上不是 async，就没有开发者愿意改它，然后这玩意就都是 Sync 的了。反正 Sync 是第一需要支持的东西。然后需要注意的是，似乎 <code>FileSystem</code> 这套接口使用的时候会尽量保证是 hold by <code>shared_ptr</code> 的。</p>
<p>Async 的实现目前也比较直接，应该是默认实现是包一套 <code>SubmitIO</code>，然后内部实现可以在继承的时候允许自己去做一些 hack. 这里举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DeferredFunc&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">FileSystemDefer</span><span class="params">(FileSystem* fs, <span class="type">bool</span> synchronous, DeferredFunc&amp;&amp; func)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="title">decltype</span><span class="params">(DeferNotOk(</span></span></span><br><span class="line"><span class="params"><span class="function">        fs-&gt;io_context().executor()-&gt;Submit(func, std::shared_ptr&lt;FileSystem&gt;&#123;&#125;)))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> self = fs-&gt;<span class="built_in">shared_from_this</span>();</span><br><span class="line">  <span class="keyword">if</span> (synchronous) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;DeferredFunc&gt;(func)(std::<span class="built_in">move</span>(self));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">DeferNotOk</span>(io::internal::<span class="built_in">SubmitIO</span>(</span><br><span class="line">      fs-&gt;<span class="built_in">io_context</span>(), std::forward&lt;DeferredFunc&gt;(func), std::<span class="built_in">move</span>(self)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line">Future&lt;std::shared_ptr&lt;io::InputStream&gt;&gt; FileSystem::<span class="built_in">OpenInputStreamAsync</span>(</span><br><span class="line">    <span class="type">const</span> std::string&amp; path) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">FileSystemDefer</span>(</span><br><span class="line">      <span class="keyword">this</span>, default_async_is_sync_,</span><br><span class="line">      [path](std::shared_ptr&lt;FileSystem&gt; self) &#123; <span class="keyword">return</span> self-&gt;<span class="built_in">OpenInputStream</span>(path); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么 OpenFile 需要是 async 的呢？举例子就是 S3 的 Open:</p>
<p>这里 <code>Init</code> 本身会发出一个 HeadObject，所以可能需要尽量在对应的异步线程里打开</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A RandomAccessFile that reads from a S3 object</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectInputFile</span> <span class="keyword">final</span> : <span class="keyword">public</span> io::RandomAccessFile &#123;</span><br><span class="line">  <span class="function">Status <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Issue a HEAD Object to get the content-length and ensure any</span></span><br><span class="line">    <span class="comment">// errors (e.g. file not found) don&#x27;t wait until the first Read() call.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>File 有好几个接口，这些代码本身是非常清晰的。这里接口类似 concept，每个地方是一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileIterface(Close, CloseAsync, Abort, Tell. 这里特殊说一下 CloseAsync, 因为可能文件读取也要释放一些资源的)</span><br><span class="line">Seekable(Seek)</span><br><span class="line">Writable(Write, Flush. Write 可以传入 non-owned buffer, 也可以丢个 shared_ptr&lt;Buffer&gt; 进来来避免拷贝)</span><br><span class="line">Readable(Read. Read 可以拷贝到用户的 Buffer, 也可以返回一个 shared_ptr&lt;Buffer&gt;)</span><br><span class="line">OutputStream: FileIterface</span><br><span class="line">InputStream: FileIterface, Readable (Advance, Peak, supports_zero_copy, ReadMetadata, ReadMetadataAsync)</span><br><span class="line">RandomAccessFile: InputStream, Seekable (GetStream, GetSize, ReadAt, ReadAsync, ReadManyAsync, WillNeed)</span><br><span class="line">WritableFile: OutputStream (WriteAt)</span><br><span class="line">ReadWriteFileInterface: RandomAccessFile, WritableFile</span><br></pre></td></tr></table></figure>
<p>这个部分注意一下 async 的实现即可。我们首先关注一下 S3 的 <code>CloseAsync</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;&gt; <span class="built_in">CloseAsync</span>() <span class="keyword">override</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (closed_) <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (current_part_) &#123;</span><br><span class="line">     <span class="comment">// Upload last part</span></span><br><span class="line">     <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">CommitCurrentPart</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// S3 mandates at least one part, upload an empty one if necessary</span></span><br><span class="line">   <span class="keyword">if</span> (part_number_ == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">UploadPart</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Wait for in-progress uploads to finish (if async writes are enabled)</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">FlushAsync</span>().<span class="built_in">Then</span>([<span class="keyword">this</span>]() &#123;</span><br><span class="line">     <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(<span class="keyword">auto</span> client_lock, holder_-&gt;<span class="built_in">Lock</span>());</span><br><span class="line"></span><br><span class="line">     <span class="comment">// At this point, all part uploads have finished successfully</span></span><br><span class="line">     <span class="built_in">DCHECK_GT</span>(part_number_, <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">DCHECK_EQ</span>(upload_state_-&gt;completed_parts.<span class="built_in">size</span>(),</span><br><span class="line">               <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(part_number_ - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">     S3Model::CompletedMultipartUpload completed_upload;</span><br><span class="line">     completed_upload.<span class="built_in">SetParts</span>(upload_state_-&gt;completed_parts);</span><br><span class="line">     S3Model::CompleteMultipartUploadRequest req;</span><br><span class="line">     req.<span class="built_in">SetBucket</span>(<span class="built_in">ToAwsString</span>(path_.bucket));</span><br><span class="line">     req.<span class="built_in">SetKey</span>(<span class="built_in">ToAwsString</span>(path_.key));</span><br><span class="line">     req.<span class="built_in">SetUploadId</span>(upload_id_);</span><br><span class="line">     req.<span class="built_in">SetMultipartUpload</span>(std::<span class="built_in">move</span>(completed_upload));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">auto</span> outcome =</span><br><span class="line">         client_lock.<span class="built_in">Move</span>()-&gt;<span class="built_in">CompleteMultipartUploadWithErrorFixup</span>(std::<span class="built_in">move</span>(req));</span><br><span class="line">     <span class="keyword">if</span> (!outcome.<span class="built_in">IsSuccess</span>()) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">ErrorToStatus</span>(</span><br><span class="line">           std::forward_as_tuple(<span class="string">&quot;When completing multiple part upload for key &#x27;&quot;</span>,</span><br><span class="line">                                 path_.key, <span class="string">&quot;&#x27; in bucket &#x27;&quot;</span>, path_.bucket, <span class="string">&quot;&#x27;: &quot;</span>),</span><br><span class="line">           <span class="string">&quot;CompleteMultipartUpload&quot;</span>, outcome.<span class="built_in">GetError</span>());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     holder_ = <span class="literal">nullptr</span>;</span><br><span class="line">     closed_ = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里因为完成的时候还得 <code>Flush</code> 然后发个 <code>Complete</code> 请求，所以很适合作为一个 Async。</p>
<p>对于 <code>RandomAccessFile::ReadAt</code> 来说，默认实现是个很挫的实现…，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="type">int64_t</span>&gt; <span class="title">RandomAccessFile::ReadAt</span><span class="params">(<span class="type">int64_t</span> position, <span class="type">int64_t</span> nbytes, <span class="type">void</span>* out)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(interface_impl_-&gt;lock_)</span></span>;</span><br><span class="line">  <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">Seek</span>(position));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Read</span>(nbytes, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Result&lt;std::shared_ptr&lt;Buffer&gt;&gt; RandomAccessFile::<span class="built_in">ReadAt</span>(<span class="type">int64_t</span> position,</span><br><span class="line">                                                         <span class="type">int64_t</span> nbytes) &#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(interface_impl_-&gt;lock_)</span></span>;</span><br><span class="line">  <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">Seek</span>(position));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Read</span>(nbytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>File</code> 系还有几个 Concurrency Wrapper，但在 Release 编译的时候其实是不上锁的( Concurrency Wrapper 实现了。当然，系统如果支持这样，可以做一些相对好的操作。HDFS 这样有的 client 不支持 pread 的可以走这套，但是如果走 pread 肯定可以有更好的性能.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A RandomAccessFile that reads from a S3 object</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectInputFile</span> <span class="keyword">final</span> : <span class="keyword">public</span> io::RandomAccessFile;</span><br></pre></td></tr></table></figure>
<p>这里就实现了不带锁的 pread，来加速对应的操作。</p>
<h4 id="Buffered-and-Memory-Layer"><a href="#Buffered-and-Memory-Layer" class="headerlink" title="Buffered and Memory Layer"></a>Buffered and Memory Layer</h4><p>Buffered 是 arrow 包装的一套 Buffer IO 系统，我觉得有点类似 Rust 标准库的那套 Buffer IO，然后也包装了一些 Arrow 特有的逻辑。读取的</p>
<p><code>BufferedOutputStream</code> 和 <code>BufferedInputStream</code> 是 Buffered IO 的实现，分别把输入输出 Buffer 化。</p>
<p><code>src/arrow/io/memory.h</code> 有一些用 Memory 中的 <code>Buffer</code> 或者别的东西当成输入或者输出的工具，可以在测试之类的代码很方便的使用。</p>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p><code>TransformInputStream</code> 允许用户给 inputStream 读 bytes 的时候定制一个 <code>transform</code> 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ARROW_EXPORT</span> TransformInputStream : <span class="keyword">public</span> InputStream &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> TransformFunc =</span><br><span class="line">      std::function&lt;Result&lt;std::shared_ptr&lt;Buffer&gt;&gt;(<span class="type">const</span> std::shared_ptr&lt;Buffer&gt;&amp;)&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>感觉这个得定义一个有状态的函数，比如说那种 utf8 parsing 的时候返回的 buf 肯定不一定是完整的 buf 了…</p>
<h3 id="Memory-Caching-Layer"><a href="#Memory-Caching-Layer" class="headerlink" title="Memory Caching Layer"></a>Memory Caching Layer</h3><p><code>src/arrow/io/caching.h</code> 处理了预读、缓存、IO合并的逻辑。<code>ReadRangeCache</code> 会预读并且缓存数据，它有两种形式：</p>
<ol>
<li>Lazy: 等待用户的读，来触发 IO</li>
<li>Default: 把所有 IO 发出去</li>
</ol>
<p>上面两种接口都会发送 IO 合并，然后读一个大块的时候 IO 发出去之后会缓存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ARROW_EXPORT</span> CacheOptions &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> kDefaultIdealBandwidthUtilizationFrac = <span class="number">0.9</span>;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int64_t</span> kDefaultMaxIdealRequestSizeMib = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief The maximum distance in bytes between two consecutive</span></span><br><span class="line">  <span class="comment">///   ranges; beyond this value, ranges are not combined</span></span><br><span class="line">  <span class="type">int64_t</span> hole_size_limit;</span><br><span class="line">  <span class="comment">/// \brief The maximum size in bytes of a combined range; if</span></span><br><span class="line">  <span class="comment">///   combining two consecutive ranges would produce a range of a</span></span><br><span class="line">  <span class="comment">///   size greater than this, they are not combined</span></span><br><span class="line">  <span class="type">int64_t</span> range_size_limit;</span><br><span class="line">  <span class="comment">/// \brief A lazy cache does not perform any I/O until requested.</span></span><br><span class="line">  <span class="type">bool</span> lazy;</span><br><span class="line">  <span class="comment">/// \brief The maximum number of ranges to be prefetched. This is only used</span></span><br><span class="line">  <span class="comment">///   for lazy cache to asynchronously read some ranges after reading the target range.</span></span><br><span class="line">  <span class="type">int64_t</span> prefetch_limit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> CacheOptions&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> hole_size_limit == other.hole_size_limit &amp;&amp;</span><br><span class="line">           range_size_limit == other.range_size_limit &amp;&amp; lazy == other.lazy &amp;&amp;</span><br><span class="line">           prefetch_limit == other.prefetch_limit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Construct CacheOptions from network storage metrics (e.g. S3).</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// \param[in] time_to_first_byte_millis Seek-time or Time-To-First-Byte (TTFB) in</span></span><br><span class="line">  <span class="comment">///   milliseconds, also called call setup latency of a new S3 request.</span></span><br><span class="line">  <span class="comment">///   The value is a positive integer.</span></span><br><span class="line">  <span class="comment">/// \param[in] transfer_bandwidth_mib_per_sec Data transfer Bandwidth (BW) in MiB/sec.</span></span><br><span class="line">  <span class="comment">///   The value is a positive integer.</span></span><br><span class="line">  <span class="comment">/// \param[in] ideal_bandwidth_utilization_frac Transfer bandwidth utilization fraction</span></span><br><span class="line">  <span class="comment">///   (per connection) to maximize the net data load.</span></span><br><span class="line">  <span class="comment">///   The value is a positive double precision number less than 1.</span></span><br><span class="line">  <span class="comment">/// \param[in] max_ideal_request_size_mib The maximum single data request size (in MiB)</span></span><br><span class="line">  <span class="comment">///   to maximize the net data load.</span></span><br><span class="line">  <span class="comment">///   The value is a positive integer.</span></span><br><span class="line">  <span class="comment">/// \return A new instance of CacheOptions.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> CacheOptions <span class="title">MakeFromNetworkMetrics</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">int64_t</span> time_to_first_byte_millis, <span class="type">int64_t</span> transfer_bandwidth_mib_per_sec,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">double</span> ideal_bandwidth_utilization_frac = kDefaultIdealBandwidthUtilizationFrac,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">int64_t</span> max_ideal_request_size_mib = kDefaultMaxIdealRequestSizeMib)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> CacheOptions <span class="title">Defaults</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> CacheOptions <span class="title">LazyDefaults</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里比较新颖的一个地方是 <code>MakeFromNetworkMetrics</code>, 根据网络状况生成对应的 IO 状况.</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#FileSystem"><span class="toc-number">1.</span> <span class="toc-text">FileSystem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IOContext-and-Executor"><span class="toc-number">1.1.</span> <span class="toc-text">IOContext and Executor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">文件系统的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List-%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">List 文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dir-Operations"><span class="toc-number">1.3.</span> <span class="toc-text">Dir Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-and-Stream-Operations"><span class="toc-number">1.4.</span> <span class="toc-text">File and Stream Operations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File"><span class="toc-number">2.</span> <span class="toc-text">File</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffered-and-Memory-Layer"><span class="toc-number">2.0.1.</span> <span class="toc-text">Buffered and Memory Layer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transform"><span class="toc-number">2.1.</span> <span class="toc-text">Transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Caching-Layer"><span class="toc-number">2.2.</span> <span class="toc-text">Memory Caching Layer</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&text=Arrow util: File &amp; FileSystem"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&title=Arrow util: File &amp; FileSystem"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&is_video=false&description=Arrow util: File &amp; FileSystem"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Arrow util: File &amp; FileSystem&body=Check out this article: http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&title=Arrow util: File &amp; FileSystem"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&title=Arrow util: File &amp; FileSystem"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&title=Arrow util: File &amp; FileSystem"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&title=Arrow util: File &amp; FileSystem"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&name=Arrow util: File &amp; FileSystem&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2023/08/21/Arrow-util-File-FileSystem/&t=Arrow util: File &amp; FileSystem"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2025
    mwish
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FL51GBW6JT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FL51GBW6JT');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
