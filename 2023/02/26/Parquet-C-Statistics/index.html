<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="上面一节我们讨论了 arrow 类型到 Parquet 类型的外层类型映射，我们学到的技巧是，用 arrow 的 Schema 转换成 Parquet 的 Schema，做类型映射，然后冗余一份 Parquet 的 Schema。这一节介绍的是 Types and Statistics In Parquet。这节的内容也比较 Dirty，但是还是必要的。此外，这节会涉及一些 Parquet MR">
<meta property="og:type" content="article">
<meta property="og:title" content="Parquet C++: Statistics">
<meta property="og:url" content="http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/index.html">
<meta property="og:site_name" content="风空之岛">
<meta property="og:description" content="上面一节我们讨论了 arrow 类型到 Parquet 类型的外层类型映射，我们学到的技巧是，用 arrow 的 Schema 转换成 Parquet 的 Schema，做类型映射，然后冗余一份 Parquet 的 Schema。这一节介绍的是 Types and Statistics In Parquet。这节的内容也比较 Dirty，但是还是必要的。此外，这节会涉及一些 Parquet MR">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-26T08:45:00.000Z">
<meta property="article:modified_time" content="2023-02-26T08:43:31.427Z">
<meta property="article:author" content="mwish">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/logo.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico">
        
      
    
    <!-- title -->
    <title>Parquet C++: Statistics</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/03/05/Storage-in-AP-Systems/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/02/18/Parquet-C-from-schema-to-schema/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&text=Parquet C++: Statistics"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&title=Parquet C++: Statistics"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&is_video=false&description=Parquet C++: Statistics"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Parquet C++: Statistics&body=Check out this article: http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&title=Parquet C++: Statistics"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&title=Parquet C++: Statistics"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&title=Parquet C++: Statistics"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&title=Parquet C++: Statistics"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&name=Parquet C++: Statistics&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&t=Parquet C++: Statistics"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Parquet-Standard"><span class="toc-number">1.</span> <span class="toc-text">Parquet Standard</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Statistics"><span class="toc-number">1.1.</span> <span class="toc-text">Statistics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Statistic-Dictionary-amp-Corner-Cases"><span class="toc-number">1.2.</span> <span class="toc-text">Statistic: Dictionary &amp; Corner Cases</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0-%E5%86%99"><span class="toc-number">1.3.1.</span> <span class="toc-text">C++ 实现: 写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SortOrder"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">SortOrder</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0-%E8%AF%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">C++ 实现: 读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PageStats-amp-ColumnIndex"><span class="toc-number">2.</span> <span class="toc-text">PageStats &amp; ColumnIndex</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Parquet C++: Statistics
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">mwish</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-02-26T08:45:00.000Z" itemprop="datePublished">2023-02-26</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>上面一节我们讨论了 arrow 类型到 Parquet 类型的外层类型映射，我们学到的技巧是，用 arrow 的 Schema 转换成 Parquet 的 Schema，做类型映射，然后冗余一份 Parquet 的 Schema。这一节介绍的是 Types and Statistics In Parquet。这节的内容也比较 Dirty，但是还是必要的。此外，这节会涉及一些 Parquet MR 的代码，因为它的代码是「好 / 对」的。arrow Schema 会有很多问题，我也会尝试修复这些问题。</p>
<p>此外，这节只涉及标准的、协议上的 Statistics，如果用户想打洞，这篇文章也可以提供一些 arrow 的外挂。</p>
<h2 id="Parquet-Standard"><a href="#Parquet-Standard" class="headerlink" title="Parquet Standard"></a>Parquet Standard</h2><h3 id="Statistics"><a href="#Statistics" class="headerlink" title="Statistics"></a>Statistics</h3><p>Parquet 协议上本身会带有一些 Statistics，分成多部分：</p>
<p><code>Statistics</code> 结构(我在下面删掉了兼容性对应的部分，但是实际代码是要处理的)</p>
<ol>
<li>这个地方的 <code>max_value</code> 和 <code>min_value</code> 都是 Parquet 内部的编码。根据 <code>ColumnOrder</code> 决定，什么是 ColumnOrder 呢？之后介绍</li>
<li><code>null_count</code> 是个非常奇怪的东西，需要注意的是 <strong>这个地方是 Parquet 内部，而不是用户层面的语义</strong>。意思就是，在 max-rep-level &gt; 1 的场景下，你用 max-rep-level 就会有奇怪的问题了</li>
<li><code>distinct_count</code> 稍微好理解一点，但需要注意这个对 null 的包含的情况</li>
<li>这里所有字段都是 optional 的，Statistics 本身也是 Optional 的</li>
</ol>
<p>请看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Statistics per row group and per page</span></span><br><span class="line"><span class="comment"> * All fields are optional.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Statistics</span> &#123;</span><br><span class="line">   <span class="comment">/** count of null value in the column */</span></span><br><span class="line">   <span class="number">3</span>: optional i64 null_count;</span><br><span class="line">   <span class="comment">/** count of distinct values occurring */</span></span><br><span class="line">   <span class="number">4</span>: optional i64 distinct_count;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Min and max values for the column, determined by its ColumnOrder.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Values are encoded using PLAIN encoding, except that variable-length byte</span></span><br><span class="line"><span class="comment">    * arrays do not include a length prefix.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="number">5</span>: optional binary max_value;</span><br><span class="line">   <span class="number">6</span>: optional binary min_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，这里会有两个地方持有 Statistics: Page Header 和 ColumnChunkMetadata:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Data page header (这里是 data page v1 的 header, v2 也有, 懒得贴了, 不过 dict 没有, 只有 num_values) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DataPageHeader</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Optional statistics for the data in this page**/</span></span><br><span class="line">  <span class="number">5</span>: optional Statistics statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description for column metadata</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ColumnMetaData</span> &#123;</span></span><br><span class="line">  <span class="comment">/** Type of this column **/</span></span><br><span class="line">  <span class="number">1</span>: required Type type</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Set of all encodings used for this column. The purpose is to validate</span></span><br><span class="line"><span class="comment">   * whether we can decode those pages. **/</span></span><br><span class="line">  <span class="number">2</span>: required <span class="built_in">list</span>&lt;Encoding&gt; encodings</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Path in schema **/</span></span><br><span class="line">  <span class="number">3</span>: required <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; path_in_schema</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** optional statistics for this column chunk */</span></span><br><span class="line">  <span class="number">12</span>: optional Statistics statistics;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Set of all encodings used for pages in this column chunk.</span></span><br><span class="line"><span class="comment">   * This information can be used to determine if all data pages are</span></span><br><span class="line"><span class="comment">   * dictionary encoded for example **/</span></span><br><span class="line">  <span class="number">13</span>: optional <span class="built_in">list</span>&lt;PageEncodingStats&gt; encoding_stats;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会发现，我多留了个 <code>encoding_stats</code>，这是什么呢？别急后面会讲。还记得之前说的吗？这些 Statistics 本身会受 Schema 控制，这个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description for file metadata</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line">  <span class="comment">/** Parquet schema for this file.  This schema contains metadata for all the columns.</span></span><br><span class="line"><span class="comment">   * The schema is represented as a tree with a single root.  The nodes of the tree</span></span><br><span class="line"><span class="comment">   * are flattened to a list by doing a depth-first traversal.</span></span><br><span class="line"><span class="comment">   * The column metadata contains the path in the schema for that column which can be</span></span><br><span class="line"><span class="comment">   * used to map columns to nodes in the schema.</span></span><br><span class="line"><span class="comment">   * The first element is the root **/</span></span><br><span class="line">  <span class="number">2</span>: required <span class="built_in">list</span>&lt;SchemaElement&gt; schema;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Optional key/value metadata **/</span></span><br><span class="line">  <span class="number">5</span>: optional <span class="built_in">list</span>&lt;KeyValue&gt; key_value_metadata</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** String for application that wrote this file.  This should be in the format</span></span><br><span class="line"><span class="comment">   * &lt;Application&gt; version &lt;App Version&gt; (build &lt;App Build Hash&gt;).</span></span><br><span class="line"><span class="comment">   * e.g. impala version 1.0 (build 6cf94d29b2b7115df4de2c06e2ab4326d721eb55)</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="number">6</span>: optional <span class="built_in">string</span> created_by</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sort order used for the min_value and max_value fields in the Statistics</span></span><br><span class="line"><span class="comment">   * objects and the min_values and max_values fields in the ColumnIndex</span></span><br><span class="line"><span class="comment">   * objects of each column in this file. Sort orders are listed in the order</span></span><br><span class="line"><span class="comment">   * matching the columns in the schema. The indexes are not necessary the same</span></span><br><span class="line"><span class="comment">   * though, because only leaf nodes of the schema are represented in the list</span></span><br><span class="line"><span class="comment">   * of sort orders.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Without column_orders, the meaning of the min_value and max_value fields</span></span><br><span class="line"><span class="comment">   * in the Statistics object and the ColumnIndex object is undefined. To ensure</span></span><br><span class="line"><span class="comment">   * well-defined behaviour, if these fields are written to a Parquet file,</span></span><br><span class="line"><span class="comment">   * column_orders must be written as well.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The obsolete min and max fields in the Statistics object are always sorted</span></span><br><span class="line"><span class="comment">   * by signed comparison regardless of column_orders.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="number">7</span>: optional <span class="built_in">list</span>&lt;ColumnOrder&gt; column_orders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个 <code>ColumnOrder</code>，正是对 Statistics 对应所有逻辑列的统计的总描述:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Empty struct to signal the order defined by the physical or logical type */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeDefinedOrder</span> &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Union to specify the order used for the min_value and max_value fields for a</span></span><br><span class="line"><span class="comment"> * column. This union takes the role of an enhanced enum that allows rich</span></span><br><span class="line"><span class="comment"> * elements (which will be needed for a collation-based ordering in the future).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Possible values are:</span></span><br><span class="line"><span class="comment"> * * TypeDefinedOrder - the column uses the order defined by its logical or</span></span><br><span class="line"><span class="comment"> *                      physical type (if there is no logical type).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the reader does not support the value of this union, min and max stats</span></span><br><span class="line"><span class="comment"> * for this column should be ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">ColumnOrder</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The sort orders for logical types are:</span></span><br><span class="line"><span class="comment">   *   UTF8 - unsigned byte-wise comparison</span></span><br><span class="line"><span class="comment">   *   INT8 - signed comparison</span></span><br><span class="line"><span class="comment">   *   INT16 - signed comparison</span></span><br><span class="line"><span class="comment">   *   INT32 - signed comparison</span></span><br><span class="line"><span class="comment">   *   INT64 - signed comparison</span></span><br><span class="line"><span class="comment">   *   UINT8 - unsigned comparison</span></span><br><span class="line"><span class="comment">   *   UINT16 - unsigned comparison</span></span><br><span class="line"><span class="comment">   *   UINT32 - unsigned comparison</span></span><br><span class="line"><span class="comment">   *   UINT64 - unsigned comparison</span></span><br><span class="line"><span class="comment">   *   DECIMAL - signed comparison of the represented value</span></span><br><span class="line"><span class="comment">   *   DATE - signed comparison</span></span><br><span class="line"><span class="comment">   *   TIME_MILLIS - signed comparison</span></span><br><span class="line"><span class="comment">   *   TIME_MICROS - signed comparison</span></span><br><span class="line"><span class="comment">   *   TIMESTAMP_MILLIS - signed comparison</span></span><br><span class="line"><span class="comment">   *   TIMESTAMP_MICROS - signed comparison</span></span><br><span class="line"><span class="comment">   *   INTERVAL - unsigned comparison</span></span><br><span class="line"><span class="comment">   *   JSON - unsigned byte-wise comparison</span></span><br><span class="line"><span class="comment">   *   BSON - unsigned byte-wise comparison</span></span><br><span class="line"><span class="comment">   *   ENUM - unsigned byte-wise comparison</span></span><br><span class="line"><span class="comment">   *   LIST - undefined</span></span><br><span class="line"><span class="comment">   *   MAP - undefined</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * In the absence of logical types, the sort order is determined by the physical type:</span></span><br><span class="line"><span class="comment">   *   BOOLEAN - false, true</span></span><br><span class="line"><span class="comment">   *   INT32 - signed comparison</span></span><br><span class="line"><span class="comment">   *   INT64 - signed comparison</span></span><br><span class="line"><span class="comment">   *   INT96 (only used for legacy timestamps) - undefined</span></span><br><span class="line"><span class="comment">   *   FLOAT - signed comparison of the represented value (*)</span></span><br><span class="line"><span class="comment">   *   DOUBLE - signed comparison of the represented value (*)</span></span><br><span class="line"><span class="comment">   *   BYTE_ARRAY - unsigned byte-wise comparison</span></span><br><span class="line"><span class="comment">   *   FIXED_LEN_BYTE_ARRAY - unsigned byte-wise comparison</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * (*) Because the sorting order is not specified properly for floating</span></span><br><span class="line"><span class="comment">   *     point values (relations vs. total ordering) the following</span></span><br><span class="line"><span class="comment">   *     compatibility rules should be applied when reading statistics:</span></span><br><span class="line"><span class="comment">   *     - If the min is a NaN, it should be ignored.</span></span><br><span class="line"><span class="comment">   *     - If the max is a NaN, it should be ignored.</span></span><br><span class="line"><span class="comment">   *     - If the min is +0, the row group may contain -0 values as well.</span></span><br><span class="line"><span class="comment">   *     - If the max is -0, the row group may contain +0 values as well.</span></span><br><span class="line"><span class="comment">   *     - When looking for NaN values, min and max should be ignored.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   *     When writing statistics the following rules should be followed:</span></span><br><span class="line"><span class="comment">   *     - NaNs should not be written to min or max statistics fields.</span></span><br><span class="line"><span class="comment">   *     - If the computed max value is zero (whether negative or positive),</span></span><br><span class="line"><span class="comment">   *       `+0.0` should be written into the max statistics field.</span></span><br><span class="line"><span class="comment">   *     - If the computed min value is zero (whether negative or positive),</span></span><br><span class="line"><span class="comment">   *       `-0.0` should be written into the min statistics field.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="number">1</span>: TypeDefinedOrder TYPE_ORDER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块内容比较大，我们可以看作 <strong>标准目前只实现了 TypeDefinedOrder</strong>，可以理解成，会以下面的 def 来挑选 order:</p>
<ul>
<li>LogicalType (或者 ConvertedType) 的 Order</li>
<li>Physical 的 Order (In the absence of logical types, the sort order is determined by the physical type)</li>
<li>对于 float，这里特殊处理了 NaN 的 Order，这里我这几天正好碰到一个类似的 issue:<ul>
<li><a target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/PARQUET-2249">https://issues.apache.org/jira/browse/PARQUET-2249</a></li>
</ul>
</li>
</ul>
<p>我们可以做出如下<strong>总结</strong>：</p>
<ol>
<li><code>FileMetadata</code> 上有 Schema，同时也有 <code>column_orders</code><ol>
<li>Order 按照 LogicalType, Type 来定义</li>
</ol>
</li>
<li><code>ColumnChunkMetadata</code> 和 <code>Page</code> 上都有对应的 Statistics，Statistics 本身的 Order 遵循 <code>FileMetadata</code>. Statistics 本身和上面的内容都是 optional 的</li>
</ol>
<h3 id="Statistic-Dictionary-amp-Corner-Cases"><a href="#Statistic-Dictionary-amp-Corner-Cases" class="headerlink" title="Statistic: Dictionary &amp; Corner Cases"></a>Statistic: Dictionary &amp; Corner Cases</h3><p>你肯定觉得之前已经讲过 Statistics 了，但是之前其实还确实了一部分。我们知道 Page 有 min-max，那么：</p>
<ol>
<li>字典页面的 Min-Max 是怎么处理的呢？</li>
<li>字典页面的 Layout 是什么样子的呢？</li>
<li>Null 之类的，会不会进 ndv 呢？</li>
</ol>
<p>我们可以介绍一些 Parquet 字典格式的黑暗部分了。这里可以先简单翻阅一下 Parquet 的 Encoding 部分：<a target="_blank" rel="noopener" href="https://github.com/apache/parquet-format/blob/master/Encodings.md#dictionary-encoding-plain_dictionary--2-and-rle_dictionary--8">https://github.com/apache/parquet-format/blob/master/Encodings.md#dictionary-encoding-plain_dictionary--2-and-rle_dictionary--8</a></p>
<p>这里会发现，字典有编码 <code>PLAIN_DICTIONARY</code> 和 <code>RLE_DICTIONARY</code>.</p>
<ul>
<li>PLAIN_DICTIONARY: 所有页面都是 <code>PLAIN_DICTIONARY</code> 标头，在 format-1.0 中使用</li>
<li>RLE_DICTIONARY: 字典(index)页是 <code>PLAIN</code>, Data 页面是 <code>RLE_DICTIONARY</code></li>
</ul>
<p>实际上，我们可以看下 Parquet 的 Properties:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ParquetVersion::type <span class="title">version</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> parquet_version_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">created_by</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> parquet_created_by_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">page_checksum_enabled</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> page_checksum_enabled_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Encoding::type <span class="title">dictionary_index_encoding</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parquet_version_ == ParquetVersion::PARQUET_1_0) &#123;</span><br><span class="line">    <span class="keyword">return</span> Encoding::PLAIN_DICTIONARY;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Encoding::RLE_DICTIONARY;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Encoding::type <span class="title">dictionary_page_encoding</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parquet_version_ == ParquetVersion::PARQUET_1_0) &#123;</span><br><span class="line">    <span class="keyword">return</span> Encoding::PLAIN_DICTIONARY;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Encoding::PLAIN;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么字典的 Statistics 是什么样子的呢？这部分我们可以在实现里学习，不过，在标准中，我们可以直接论断：</p>
<ul>
<li>字典数据页的 Statistics 和非字典数据页的 Statistics 逻辑上是一样的，此外，因为借用了字典，它能更好的去收集 ndv</li>
<li>字典索引页根本没有 Statistics</li>
</ul>
<p>那么 NaN 呢？实际上 NaN 并非 null，也是一种（根据 IEEE 754，可能是两种）values。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们之前提到了，Parquet Spec 有 Physical 的 type (<code>Type</code>) 和 LogicalType (<code>LogicalType</code> 和兼容 parquet-format-v1 的 <code>ConvertedType</code>)。这个 Type 会有对应的 <code>ColumnOrder</code>。接下来我们要把这坨代码映射到 C++ 上。这部分在 Parquet C++ 实现上还是比较残缺的，我们也会尽量比对 Java 版本的实现。</p>
<p>实现分为两个部分: 读，写</p>
<h4 id="C-实现-写"><a href="#C-实现-写" class="headerlink" title="C++ 实现: 写"></a>C++ 实现: 写</h4><p>这里分为好几层：</p>
<ol>
<li>Encoding 层之上：怎么支持 Statistics</li>
<li>Page 的 Statistics</li>
<li>ColumnChunk 层的 Statistics</li>
<li>元信息收集</li>
</ol>
<p>首先，我们从 Comparator 类型讲起，讲讲他为啥好 / 不好.</p>
<p>Comparator 类型的构成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator (创建的工厂)</span><br><span class="line">- TypedComparator (Compare, GetMinMax, GetMinMaxSpaced)</span><br><span class="line">  - TypedComparatorImpl</span><br><span class="line">    + ComparatorHelper&lt;Type, bool is_signed&gt;</span><br></pre></td></tr></table></figure>
<p>这块东西相对比较简单，我们可以关注一下 signed 和 unsigned 的实现。他们由 <code>SortOrder</code> 指定。<code>SortOrder</code> 是上层的概念，我们之后会介绍。我们先介绍整数比较：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnsignedCompareHelperBase</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> T = <span class="keyword">typename</span> DType::c_type;</span><br><span class="line">  <span class="keyword">using</span> UCType = <span class="keyword">typename</span> std::make_unsigned&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">static_assert</span>(!std::is_same&lt;T, UCType&gt;::value, <span class="string">&quot;T is unsigned&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(T) == <span class="built_in">sizeof</span>(UCType), <span class="string">&quot;T and UCType not the same size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> according to the C++ spec, unsigned-to-signed conversion is</span></span><br><span class="line">  <span class="comment">// implementation-defined if the original value does not fit in the signed type</span></span><br><span class="line">  <span class="comment">// (i.e., two&#x27;s complement cannot be assumed even on mainstream machines,</span></span><br><span class="line">  <span class="comment">// because the compiler may decide otherwise).  Hence the use of `SafeCopy`</span></span><br><span class="line">  <span class="comment">// below for deterministic bit-casting.</span></span><br><span class="line">  <span class="comment">// (see &quot;Integer conversions&quot; in</span></span><br><span class="line">  <span class="comment">//  https://en.cppreference.com/w/cpp/language/implicit_conversion)</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> T <span class="title">DefaultMin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">SafeCopy</span>&lt;T&gt;(std::numeric_limits&lt;UCType&gt;::<span class="built_in">max</span>()); &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">const</span> T <span class="title">DefaultMax</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Compare</span><span class="params">(<span class="type">int</span> type_length, T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SafeCopy</span>&lt;UCType&gt;(a) &lt; <span class="built_in">SafeCopy</span>&lt;UCType&gt;(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> T <span class="title">Min</span><span class="params">(<span class="type">int</span> type_length, T a, T b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Compare</span>(type_length, a, b) ? a : b; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> T <span class="title">Max</span><span class="params">(<span class="type">int</span> type_length, T a, T b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Compare</span>(type_length, a, b) ? b : a; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为 <code>DType::c_type</code> 对应是 signed, 所以这里操作了一套 unsigned 来处理。</p>
<p>那么，还有个比较 trickey 的地方是 INT96 的比较，不过 INT96 已经 deprecated 了，我就偷懒了。重点介绍一下浮点数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DType, <span class="type">bool</span> is_signed&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CompareHelper</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> T = <span class="keyword">typename</span> DType::c_type;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">static_assert</span>(!std::is_unsigned&lt;T&gt;::value || std::is_same&lt;T, <span class="type">bool</span>&gt;::value,</span><br><span class="line">                <span class="string">&quot;T is an unsigned numeric&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> T <span class="title">DefaultMin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::numeric_limits&lt;T&gt;::<span class="built_in">max</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> T <span class="title">DefaultMax</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::numeric_limits&lt;T&gt;::<span class="built_in">lowest</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MSVC17 fix, isnan is not overloaded for IntegralType as per C++11</span></span><br><span class="line">  <span class="comment">// standard requirements.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1 = T&gt;</span><br><span class="line">  <span class="type">static</span> ::arrow::<span class="type">enable_if_t</span>&lt;std::is_floating_point&lt;T1&gt;::value, T&gt; <span class="built_in">Coalesce</span>(T val,</span><br><span class="line">                                                                             T fallback) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">isnan</span>(val) ? fallback : val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1 = T&gt;</span><br><span class="line">  <span class="type">static</span> ::arrow::<span class="type">enable_if_t</span>&lt;!std::is_floating_point&lt;T1&gt;::value, T&gt; <span class="built_in">Coalesce</span>(</span><br><span class="line">      T val, T fallback) &#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Compare</span><span class="params">(<span class="type">int</span> type_length, <span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> T <span class="title">Min</span><span class="params">(<span class="type">int</span> type_length, T a, T b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b ? a : b; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> T <span class="title">Max</span><span class="params">(<span class="type">int</span> type_length, T a, T b)</span> </span>&#123; <span class="keyword">return</span> a &lt; b ? b : a; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个地方用一个 Coalesce 来强制干掉 NaN. 关于浮点数操作，可以看 Spec：</p>
<ul>
<li>IEEE 754 - 2019 浮点算数标准 - nicholaswilde的文章 - 知乎 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/480834719">https://zhuanlan.zhihu.com/p/480834719</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/38798791/nan-comparison-rule-in-c-c">https://stackoverflow.com/questions/38798791/nan-comparison-rule-in-c-c</a></li>
<li>注意一下标准库提供的几个抽象，下列可以简单说一下<ul>
<li><code>max</code>: 最大值</li>
<li><code>min</code>: 对浮点数来说是最小的正数</li>
<li><code>lowest</code> 最小（非 NaN）值</li>
<li><code>denorm_min</code> ，可以表示最靠近 0 的数</li>
</ul>
</li>
</ul>
<p>这个地方封装了一层后，最后我们回到上层的 <code>Make</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Comparator&gt; <span class="title">Comparator::Make</span><span class="params">(Type::type physical_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             SortOrder::type sort_order,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">int</span> type_length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (SortOrder::SIGNED == sort_order) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (physical_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> Type::BOOLEAN:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">true</span>, BooleanType&gt;&gt;();</span><br><span class="line">      <span class="keyword">case</span> Type::INT32:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">true</span>, Int32Type&gt;&gt;();</span><br><span class="line">      <span class="keyword">case</span> Type::INT64:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">true</span>, Int64Type&gt;&gt;();</span><br><span class="line">      <span class="keyword">case</span> Type::INT96:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">true</span>, Int96Type&gt;&gt;();</span><br><span class="line">      <span class="keyword">case</span> Type::FLOAT:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">true</span>, FloatType&gt;&gt;();</span><br><span class="line">      <span class="keyword">case</span> Type::DOUBLE:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">true</span>, DoubleType&gt;&gt;();</span><br><span class="line">      <span class="keyword">case</span> Type::BYTE_ARRAY:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">true</span>, ByteArrayType&gt;&gt;();</span><br><span class="line">      <span class="keyword">case</span> Type::FIXED_LEN_BYTE_ARRAY:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">true</span>, FLBAType&gt;&gt;(type_length);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        ParquetException::<span class="built_in">NYI</span>(<span class="string">&quot;Signed Compare not implemented&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SortOrder::UNSIGNED == sort_order) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (physical_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> Type::INT32:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">false</span>, Int32Type&gt;&gt;();</span><br><span class="line">      <span class="keyword">case</span> Type::INT64:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">false</span>, Int64Type&gt;&gt;();</span><br><span class="line">      <span class="keyword">case</span> Type::INT96:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">false</span>, Int96Type&gt;&gt;();</span><br><span class="line">      <span class="keyword">case</span> Type::BYTE_ARRAY:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">false</span>, ByteArrayType&gt;&gt;();</span><br><span class="line">      <span class="keyword">case</span> Type::FIXED_LEN_BYTE_ARRAY:</span><br><span class="line">        <span class="keyword">return</span> std::make_shared&lt;TypedComparatorImpl&lt;<span class="literal">false</span>, FLBAType&gt;&gt;(type_length);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        ParquetException::<span class="built_in">NYI</span>(<span class="string">&quot;Unsigned Compare not implemented&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">ParquetException</span>(<span class="string">&quot;UNKNOWN Sort Order&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有 <code>SortOrder</code> 的东西，是创建不出 Comparator 的，这个地方可以留意一下。我们回到 Statistics，它的多层级类似 Comparator。它对外会走一个叫做 <code>EncodedStatistics</code> 的东西，它算是 thrift <code>Statistics</code> 的一个包装，用户不需要直接和 <code>Statistics</code> 打交道。（这玩意不包括 num_values…但是 num_values 需要靠 Statistics 收集）。</p>
<p>它的内部结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Statistics (nullCount, minmax, Encode)</span><br><span class="line">- TypedStatistics</span><br><span class="line">  - TypedStatisticsImpl</span><br><span class="line">    + TypedComparator</span><br></pre></td></tr></table></figure>
<p>如果创建失败，比如 ColumnDescriptor 没有 SortOrder, 这玩意根本创建不出来。它可以根据 arrow 写入来更新内部的状态。</p>
<p>关于更新状态，这里也可以看作是一个联动的状态：</p>
<p>更新的时候：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair&lt;T, T&gt; <span class="title">GetMinMax</span><span class="params">(<span class="type">const</span> T* values, <span class="type">int64_t</span> length)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_GT</span>(length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  T min = Helper::<span class="built_in">DefaultMin</span>();</span><br><span class="line">  T max = Helper::<span class="built_in">DefaultMax</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int64_t</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> val = <span class="built_in">SafeLoad</span>(values + i);</span><br><span class="line">    min = Helper::<span class="built_in">Min</span>(type_length_, min, Helper::<span class="built_in">Coalesce</span>(val, Helper::<span class="built_in">DefaultMin</span>()));</span><br><span class="line">    max = Helper::<span class="built_in">Max</span>(type_length_, max, Helper::<span class="built_in">Coalesce</span>(val, Helper::<span class="built_in">DefaultMax</span>()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;min, max&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置的时候：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In case of floating point types, the following rules are applied (as per</span></span><br><span class="line"><span class="comment">// upstream parquet-mr):</span></span><br><span class="line"><span class="comment">// - If any of min/max is NaN, return nothing.</span></span><br><span class="line"><span class="comment">// - If min is 0.0f, replace with -0.0f</span></span><br><span class="line"><span class="comment">// - If max is -0.0f, replace with 0.0f</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">::arrow::<span class="type">enable_if_t</span>&lt;std::is_floating_point&lt;T&gt;::value, optional&lt;std::pair&lt;T, T&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">CleanStatistic</span>(std::pair&lt;T, T&gt; min_max) &#123;</span><br><span class="line">  T min = min_max.first;</span><br><span class="line">  T max = min_max.second;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ignore if one of the value is nan.</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">isnan</span>(min) || std::<span class="built_in">isnan</span>(max)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ::std::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (min == std::numeric_limits&lt;T&gt;::<span class="built_in">max</span>() &amp;&amp; max == std::numeric_limits&lt;T&gt;::<span class="built_in">lowest</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> ::std::<span class="literal">nullopt</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  T zero&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (min == zero &amp;&amp; !std::<span class="built_in">signbit</span>(min)) &#123;</span><br><span class="line">    min = -min;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (max == zero &amp;&amp; std::<span class="built_in">signbit</span>(max)) &#123;</span><br><span class="line">    max = -max;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;&#123;min, max&#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetMinMaxPair</span><span class="params">(std::pair&lt;T, T&gt; min_max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CleanStatistic can return a nullopt in case of erroneous values, e.g. NaN</span></span><br><span class="line">    <span class="keyword">auto</span> maybe_min_max = <span class="built_in">CleanStatistic</span>(min_max);</span><br><span class="line">    <span class="keyword">if</span> (!maybe_min_max) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> min = maybe_min_max.<span class="built_in">value</span>().first;</span><br><span class="line">    <span class="keyword">auto</span> max = maybe_min_max.<span class="built_in">value</span>().second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!has_min_max_) &#123;</span><br><span class="line">      has_min_max_ = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">Copy</span>(min, &amp;min_, min_buffer_.<span class="built_in">get</span>());</span><br><span class="line">      <span class="built_in">Copy</span>(max, &amp;max_, max_buffer_.<span class="built_in">get</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">Copy</span>(comparator_-&gt;<span class="built_in">Compare</span>(min_, min) ? min_ : min, &amp;min_, min_buffer_.<span class="built_in">get</span>());</span><br><span class="line">      <span class="built_in">Copy</span>(comparator_-&gt;<span class="built_in">Compare</span>(max_, max) ? max : max_, &amp;max_, max_buffer_.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在这个层面上，我们就能很好理解 min-max 了。</p>
<h5 id="SortOrder"><a href="#SortOrder" class="headerlink" title="SortOrder"></a>SortOrder</h5><p>我们上节介绍 Schema 的时候没介绍 SortOrder，因为 Parquet Standard 里面没有这个东西（有叫 sort_order 的别的东西）。这个是 C++ Parquet 内部实现 order 用的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SortOrder::type <span class="title">sort_order</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> la = <span class="built_in">logical_type</span>();</span><br><span class="line">  <span class="keyword">auto</span> pt = <span class="built_in">physical_type</span>();</span><br><span class="line">  <span class="keyword">return</span> la ? <span class="built_in">GetSortOrder</span>(la, pt) : <span class="built_in">GetSortOrder</span>(<span class="built_in">converted_type</span>(), pt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里相当于 spec 里面的 <code>TypeDefinedOrder</code>，实现上当成了多份 SIGNED, UNSIGNED, UNKNOWN. <code>LogicalType</code> 都会定义自己的 SortOrder，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogicalType</span>::Impl::Int <span class="keyword">final</span> : <span class="keyword">public</span> LogicalType::Impl::Compatible,</span><br><span class="line">                                     <span class="keyword">public</span> LogicalType::Impl::Applicable &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">IntLogicalType</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_applicable</span><span class="params">(parquet::Type::type primitive_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int32_t</span> primitive_length = <span class="number">-1</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_compatible</span><span class="params">(ConvertedType::type converted_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                     schema::DecimalMetadata converted_decimal_metadata)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">ConvertedType::type <span class="title">ToConvertedType</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      schema::DecimalMetadata* out_decimal_metadata)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">ToJSON</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">format::LogicalType <span class="title">ToThrift</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Equals</span><span class="params">(<span class="type">const</span> LogicalType&amp; other)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">bit_width</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> width_; &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_signed</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> signed_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Int</span>(<span class="type">int</span> w, <span class="type">bool</span> s)</span><br><span class="line">      : LogicalType::<span class="built_in">Impl</span>(LogicalType::Type::INT,</span><br><span class="line">                          (s ? SortOrder::SIGNED : SortOrder::UNSIGNED)),</span><br><span class="line">        <span class="built_in">width_</span>(w),</span><br><span class="line">        <span class="built_in">signed_</span>(s) &#123;&#125;</span><br><span class="line">  <span class="type">int</span> width_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> signed_ = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也有一些类型，比如 VOID，对应的 Statistics 是 undefined.</p>
<p>目前的实现有个问题，如果是 undefined (甚至是类型标志奇怪了一些)，就会产生 comparator 生成的异常，然后无法产生 statistics。这些会影响 interval 相关的类型。</p>
<p>在最终写入的时候，会有两种 statistics:</p>
<ol>
<li><code>page_statistics</code>: 每个页面上的</li>
<li><code>column_statistics</code>: 汇总的 statistics.</li>
</ol>
<p>在创建的时候，内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TypedColumnWriterImpl</span>(ColumnChunkMetaDataBuilder* metadata,</span><br><span class="line">                      std::unique_ptr&lt;PageWriter&gt; pager, <span class="type">const</span> <span class="type">bool</span> use_dictionary,</span><br><span class="line">                      Encoding::type encoding, <span class="type">const</span> WriterProperties* properties) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (properties-&gt;<span class="built_in">statistics_enabled</span>(descr_-&gt;<span class="built_in">path</span>()) &amp;&amp;</span><br><span class="line">      (SortOrder::UNKNOWN != descr_-&gt;<span class="built_in">sort_order</span>())) &#123;</span><br><span class="line">    page_statistics_ = <span class="built_in">MakeStatistics</span>&lt;DType&gt;(descr_, allocator_);</span><br><span class="line">    chunk_statistics_ = <span class="built_in">MakeStatistics</span>&lt;DType&gt;(descr_, allocator_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每个页面会收集 page statistics，然后写入：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EncodedStatistics <span class="title">Encode</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  EncodedStatistics s;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">HasMinMax</span>()) &#123;</span><br><span class="line">    s.<span class="built_in">set_min</span>(<span class="keyword">this</span>-&gt;<span class="built_in">EncodeMin</span>());</span><br><span class="line">    s.<span class="built_in">set_max</span>(<span class="keyword">this</span>-&gt;<span class="built_in">EncodeMax</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">HasNullCount</span>()) &#123;</span><br><span class="line">    s.<span class="built_in">set_null_count</span>(<span class="keyword">this</span>-&gt;<span class="built_in">null_count</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">EncodedStatistics <span class="title">GetPageStatistics</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">   EncodedStatistics result;</span><br><span class="line">   <span class="keyword">if</span> (page_statistics_) result = page_statistics_-&gt;<span class="built_in">Encode</span>();</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 具体写入</span></span><br><span class="line"> EncodedStatistics page_stats = <span class="built_in">GetPageStatistics</span>();</span><br><span class="line"> page_stats.<span class="built_in">ApplyStatSizeLimits</span>(properties_-&gt;<span class="built_in">max_statistics_size</span>(descr_-&gt;<span class="built_in">path</span>()));</span><br><span class="line"> page_stats.<span class="built_in">set_is_signed</span>(SortOrder::SIGNED == descr_-&gt;<span class="built_in">sort_order</span>());</span><br><span class="line"> <span class="built_in">ResetPageStatistics</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">std::unique_ptr&lt;DataPage&gt; page_ptr = std::<span class="built_in">make_unique</span>&lt;DataPageV1&gt;(</span><br><span class="line"> 	compressed_data_copy, num_values, encoding_, Encoding::RLE, Encoding::RLE,</span><br><span class="line"> 	uncompressed_size, page_stats);</span><br></pre></td></tr></table></figure>
<p>最后，借助 <code>ToThrift</code> 转化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> format::Statistics <span class="title">ToThrift</span><span class="params">(<span class="type">const</span> EncodedStatistics&amp; stats)</span> </span>&#123;</span><br><span class="line">  format::Statistics statistics;</span><br><span class="line">  <span class="keyword">if</span> (stats.has_min) &#123;</span><br><span class="line">    statistics.__set_min_value(stats.<span class="built_in">min</span>());</span><br><span class="line">    <span class="comment">// If the order is SIGNED, then the old min value must be set too.</span></span><br><span class="line">    <span class="comment">// This for backward compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (stats.<span class="built_in">is_signed</span>()) &#123;</span><br><span class="line">      statistics.__set_min(stats.<span class="built_in">min</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stats.has_max) &#123;</span><br><span class="line">    statistics.__set_max_value(stats.<span class="built_in">max</span>());</span><br><span class="line">    <span class="comment">// If the order is SIGNED, then the old max value must be set too.</span></span><br><span class="line">    <span class="comment">// This for backward compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (stats.<span class="built_in">is_signed</span>()) &#123;</span><br><span class="line">      statistics.__set_max(stats.<span class="built_in">max</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stats.has_null_count) &#123;</span><br><span class="line">    statistics.__set_null_count(stats.null_count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stats.has_distinct_count) &#123;</span><br><span class="line">    statistics.__set_distinct_count(stats.distinct_count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是 Page 层，ColumnChunk 层会 Merge Page 层的，直到完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ResetPageStatistics</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunk_statistics_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    chunk_statistics_-&gt;<span class="built_in">Merge</span>(*page_statistics_);</span><br><span class="line">    page_statistics_-&gt;<span class="built_in">Reset</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-实现-读"><a href="#C-实现-读" class="headerlink" title="C++ 实现: 读"></a>C++ 实现: 读</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extracts encoded statistics from V1 and V2 data page headers</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> H&gt;</span><br><span class="line"><span class="function">EncodedStatistics <span class="title">ExtractStatsFromHeader</span><span class="params">(<span class="type">const</span> H&amp; header)</span> </span>&#123;</span><br><span class="line">  EncodedStatistics page_statistics;</span><br><span class="line">  <span class="keyword">if</span> (!header.__isset.statistics) &#123;</span><br><span class="line">    <span class="keyword">return</span> page_statistics;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> format::Statistics&amp; stats = header.statistics;</span><br><span class="line">  <span class="comment">// Use the new V2 min-max statistics over the former one if it is filled</span></span><br><span class="line">  <span class="keyword">if</span> (stats.__isset.max_value || stats.__isset.min_value) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> check if the column_order is TYPE_DEFINED_ORDER.</span></span><br><span class="line">    <span class="keyword">if</span> (stats.__isset.max_value) &#123;</span><br><span class="line">      page_statistics.<span class="built_in">set_max</span>(stats.max_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stats.__isset.min_value) &#123;</span><br><span class="line">      page_statistics.<span class="built_in">set_min</span>(stats.min_value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stats.__isset.max || stats.__isset.min) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> check created_by to see if it is corrupted for some types.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> check if the sort_order is SIGNED.</span></span><br><span class="line">    <span class="keyword">if</span> (stats.__isset.max) &#123;</span><br><span class="line">      page_statistics.<span class="built_in">set_max</span>(stats.max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stats.__isset.min) &#123;</span><br><span class="line">      page_statistics.<span class="built_in">set_min</span>(stats.min);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stats.__isset.null_count) &#123;</span><br><span class="line">    page_statistics.<span class="built_in">set_null_count</span>(stats.null_count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stats.__isset.distinct_count) &#123;</span><br><span class="line">    page_statistics.<span class="built_in">set_distinct_count</span>(stats.distinct_count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> page_statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后 C++ 新版本中，有个 <code>DataPageStats</code> 用到了这个玩意。</p>
<p>实现的缺点</p>
<ul>
<li>字典页面没有收集 ndv</li>
<li>需要 comparator。LogicalType Comparator 缺失的话，会完全没有 Statistics，对 Interval 之类的类型很不友好</li>
<li>有几部分的实现感觉对读出来处理不太友好，比如 null_count / ndv</li>
</ul>
<h2 id="PageStats-amp-ColumnIndex"><a href="#PageStats-amp-ColumnIndex" class="headerlink" title="PageStats &amp; ColumnIndex"></a>PageStats &amp; ColumnIndex</h2><p>ColumnChunk 上还会有 PageStatistics:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/** Set of all encodings used for pages in this column chunk.</span><br><span class="line"> * This information can be used to determine if all data pages are</span><br><span class="line"> * dictionary encoded for example **/</span><br><span class="line">13: optional list&lt;PageEncodingStats&gt; encoding_stats;</span><br></pre></td></tr></table></figure>
<p>这个是决定内部页面的 encoding 的，可以做 Dict encoding 检测。</p>
<p>ColumnIndex 上会有一些东西，你看看就懂了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description for ColumnIndex.</span></span><br><span class="line"><span class="comment"> * Each &lt;array-field&gt;[i] refers to the page at OffsetIndex.page_locations[i]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ColumnIndex</span> &#123;</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A list of Boolean values to determine the validity of the corresponding</span></span><br><span class="line"><span class="comment">   * min and max values. If true, a page contains only null values, and writers</span></span><br><span class="line"><span class="comment">   * have to set the corresponding entries in min_values and max_values to</span></span><br><span class="line"><span class="comment">   * byte[0], so that all lists have the same length. If false, the</span></span><br><span class="line"><span class="comment">   * corresponding entries in min_values and max_values must be valid.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="number">1</span>: required <span class="built_in">list</span>&lt;<span class="type">bool</span>&gt; null_pages</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Two lists containing lower and upper bounds for the values of each page</span></span><br><span class="line"><span class="comment">   * determined by the ColumnOrder of the column. These may be the actual</span></span><br><span class="line"><span class="comment">   * minimum and maximum values found on a page, but can also be (more compact)</span></span><br><span class="line"><span class="comment">   * values that do not exist on a page. For example, instead of storing &quot;&quot;Blart</span></span><br><span class="line"><span class="comment">   * Versenwald III&quot;, a writer may set min_values[i]=&quot;B&quot;, max_values[i]=&quot;C&quot;.</span></span><br><span class="line"><span class="comment">   * Such more compact values must still be valid values within the column&#x27;s</span></span><br><span class="line"><span class="comment">   * logical type. Readers must make sure that list entries are populated before</span></span><br><span class="line"><span class="comment">   * using them by inspecting null_pages.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="number">2</span>: required <span class="built_in">list</span>&lt;binary&gt; min_values</span><br><span class="line">  <span class="number">3</span>: required <span class="built_in">list</span>&lt;binary&gt; max_values</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Stores whether both min_values and max_values are ordered and if so, in</span></span><br><span class="line"><span class="comment">   * which direction. This allows readers to perform binary searches in both</span></span><br><span class="line"><span class="comment">   * lists. Readers cannot assume that max_values[i] &lt;= min_values[i+1], even</span></span><br><span class="line"><span class="comment">   * if the lists are ordered.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="number">4</span>: required BoundaryOrder boundary_order</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** A list containing the number of null values for each page **/</span></span><br><span class="line">  <span class="number">5</span>: optional <span class="built_in">list</span>&lt;i64&gt; null_counts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个问题，就是对 NaN 的处理，这块正在 RFC 处理中：<a target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/PARQUET-2249">https://issues.apache.org/jira/browse/PARQUET-2249</a> .</p>
<p>其他很多部分其实也依赖 PageStatistics 的收集和隐含的 SortOrder。哎，这下令人唏嘘了</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Parquet-Standard"><span class="toc-number">1.</span> <span class="toc-text">Parquet Standard</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Statistics"><span class="toc-number">1.1.</span> <span class="toc-text">Statistics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Statistic-Dictionary-amp-Corner-Cases"><span class="toc-number">1.2.</span> <span class="toc-text">Statistic: Dictionary &amp; Corner Cases</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0-%E5%86%99"><span class="toc-number">1.3.1.</span> <span class="toc-text">C++ 实现: 写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SortOrder"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">SortOrder</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0-%E8%AF%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">C++ 实现: 读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PageStats-amp-ColumnIndex"><span class="toc-number">2.</span> <span class="toc-text">PageStats &amp; ColumnIndex</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&text=Parquet C++: Statistics"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&title=Parquet C++: Statistics"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&is_video=false&description=Parquet C++: Statistics"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Parquet C++: Statistics&body=Check out this article: http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&title=Parquet C++: Statistics"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&title=Parquet C++: Statistics"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&title=Parquet C++: Statistics"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&title=Parquet C++: Statistics"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&name=Parquet C++: Statistics&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2023/02/26/Parquet-C-Statistics/&t=Parquet C++: Statistics"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2024
    mwish
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FL51GBW6JT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FL51GBW6JT');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
