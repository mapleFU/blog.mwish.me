<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="bthread 是一个用户态的 Fiber 库，它的入口在 incubator-brpc&#x2F;src&#x2F;bthread，它对外提供下面一组 API:  以不同优先级和不同的调度参数创建 bthread 线程 提供了 rwlock, barrier, mutex, condvar 之类的 bthread 同步原语 bthread local 相关的配置  我们以 bthread_start_backgro">
<meta property="og:type" content="article">
<meta property="og:title" content="bthread 调度的机制">
<meta property="og:url" content="http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="风空之岛">
<meta property="og:description" content="bthread 是一个用户态的 Fiber 库，它的入口在 incubator-brpc&#x2F;src&#x2F;bthread，它对外提供下面一组 API:  以不同优先级和不同的调度参数创建 bthread 线程 提供了 rwlock, barrier, mutex, condvar 之类的 bthread 同步原语 bthread local 相关的配置  我们以 bthread_start_backgro">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-30T03:45:52.000Z">
<meta property="article:modified_time" content="2022-07-19T12:23:50.571Z">
<meta property="article:author" content="mwish">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/logo.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico">
        
      
    
    <!-- title -->
    <title>bthread 调度的机制</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2022/04/06/xv6-labs-2021-report/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/03/21/Notes-BigTable/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&text=bthread 调度的机制"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&title=bthread 调度的机制"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&is_video=false&description=bthread 调度的机制"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=bthread 调度的机制&body=Check out this article: http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&title=bthread 调度的机制"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&title=bthread 调度的机制"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&title=bthread 调度的机制"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&title=bthread 调度的机制"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&name=bthread 调度的机制&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&t=bthread 调度的机制"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TaskControl-TaskGroup-%E5%92%8C-Queue"><span class="toc-number">1.</span> <span class="toc-text">TaskControl, TaskGroup 和 Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TaskGroup-%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C-bthread-%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">TaskGroup 是怎么运行 bthread 的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sched-to"><span class="toc-number">2.1.</span> <span class="toc-text">sched_to</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sched-to-%E5%85%B7%E4%BD%93%E9%80%BB%E8%BE%91"><span class="toc-number">2.1.1.</span> <span class="toc-text">sched_to 具体逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ending-sched"><span class="toc-number">2.2.</span> <span class="toc-text">ending_sched</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        bthread 调度的机制
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">mwish</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-03-30T03:45:52.000Z" itemprop="datePublished">2022-03-30</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>bthread 是一个用户态的 <code>Fiber</code> 库，它的入口在 <code>incubator-brpc/src/bthread</code>，它对外提供下面一组 API:</p>
<ul>
<li>以不同优先级和不同的调度参数创建 bthread 线程</li>
<li>提供了 rwlock, barrier, mutex, condvar 之类的 bthread 同步原语</li>
<li>bthread local 相关的配置</li>
</ul>
<p>我们以 <code>bthread_start_background</code>为例, 这里介绍一下 bthread 调度相关的机制。</p>
<h2 id="TaskControl-TaskGroup-和-Queue"><a href="#TaskControl-TaskGroup-和-Queue" class="headerlink" title="TaskControl, TaskGroup 和 Queue"></a>TaskControl, TaskGroup 和 Queue</h2><p><code>TaskControl</code> 是一个全局唯一的中心控制器，用来做 bthread 相关的调度。<code>TaskGroup</code> 是物理工作线程的调度上下文。他们通过 Queue 来通信。</p>
<p>下面是一些全局共有的上下文：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BAIDU_CASSERT</span>(<span class="built_in">sizeof</span>(TaskControl*) == <span class="built_in">sizeof</span>(butil::atomic&lt;TaskControl*&gt;), atomic_size_match);</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> g_task_control_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">// Referenced in rpc, needs to be extern.</span></span><br><span class="line"><span class="comment">// Notice that we can&#x27;t declare the variable as atomic&lt;TaskControl*&gt; which</span></span><br><span class="line"><span class="comment">// are not constructed before main().</span></span><br><span class="line">TaskControl* g_task_control = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> BAIDU_THREAD_LOCAL TaskGroup* tls_task_group;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">void</span> <span class="params">(*g_worker_startfn)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们晚点看看 <code>TaskControl</code> 的创建，这里直接看 <code>bthread_start_background</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bthread_start_background</span><span class="params">(<span class="type">bthread_t</span>* __restrict tid,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> <span class="type">bthread_attr_t</span>* __restrict attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">void</span> * (*fn)(<span class="type">void</span>*),</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">void</span>* __restrict arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到 TaskGroup, 这个对应的 thread 本身是 worker.</span></span><br><span class="line">  	<span class="comment">// 可能是 bthread 创建子线程.</span></span><br><span class="line">    bthread::TaskGroup* g = bthread::tls_task_group;</span><br><span class="line">    <span class="keyword">if</span> (g) &#123;</span><br><span class="line">        <span class="comment">// start from worker</span></span><br><span class="line">        <span class="keyword">return</span> g-&gt;<span class="built_in">start_background</span>&lt;<span class="literal">false</span>&gt;(tid, attr, fn, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bthread::<span class="built_in">start_from_non_worker</span>(tid, attr, fn, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先从 <code>start_from_non_worker</code> 开始看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 non_worker 开始进行调度, 如果这里 attr 标记了 `no_signal`, 里面会走到 REMOTE = true.</span></span><br><span class="line"><span class="function">BUTIL_FORCE_INLINE <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">start_from_non_worker</span><span class="params">(<span class="type">bthread_t</span>* __restrict tid,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> <span class="type">bthread_attr_t</span>* __restrict attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">void</span> * (*fn)(<span class="type">void</span>*),</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">void</span>* __restrict arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到全局的 TaskControl.</span></span><br><span class="line">    TaskControl* c = <span class="built_in">get_or_new_task_control</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == c) &#123;</span><br><span class="line">        <span class="keyword">return</span> ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (attr != <span class="literal">NULL</span> &amp;&amp; (attr-&gt;flags &amp; BTHREAD_NOSIGNAL)) &#123;</span><br><span class="line">        <span class="comment">// Remember the TaskGroup to insert NOSIGNAL tasks for 2 reasons:</span></span><br><span class="line">        <span class="comment">// 1. NOSIGNAL is often for creating many bthreads in batch,</span></span><br><span class="line">        <span class="comment">//    inserting into the same TaskGroup maximizes the batch.</span></span><br><span class="line">        <span class="comment">// 2. bthread_flush() needs to know which TaskGroup to flush.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 这里相当于记忆化, 如果是 no_signal 会倾向于丢到一个 TaskGroup.</span></span><br><span class="line">        TaskGroup* g = tls_task_group_nosignal;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == g) &#123;</span><br><span class="line">            g = c-&gt;<span class="built_in">choose_one_group</span>();</span><br><span class="line">            tls_task_group_nosignal = g;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g-&gt;<span class="built_in">start_background</span>&lt;<span class="literal">true</span>&gt;(tid, attr, fn, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则会选中一个 TaskGroup 发送.</span></span><br><span class="line">    <span class="keyword">return</span> c-&gt;<span class="built_in">choose_one_group</span>()-&gt;<span class="built_in">start_background</span>&lt;<span class="literal">true</span>&gt;(</span><br><span class="line">        tid, attr, fn, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们再看看 <code>choose_one_group</code> 是什么逻辑，哦就是个 random 啊：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 fastrand, 随机选择一个 Group</span></span><br><span class="line"><span class="function">TaskGroup* <span class="title">TaskControl::choose_one_group</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> ngroup = _ngroup.<span class="built_in">load</span>(butil::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (ngroup != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _groups[butil::<span class="built_in">fast_rand_less_than</span>(ngroup)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CHECK</span>(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Impossible: ngroup is 0&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看 <code>start_background</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里分成两部分, 一部分从对象池获取并初始化一个 TaskMeta, 然后 dispatch 给</span></span><br><span class="line"><span class="comment">// ready_to_run 系列的函数实际运行.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> REMOTE&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TaskGroup::start_background</span><span class="params">(<span class="type">bthread_t</span>* __restrict th,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> <span class="type">bthread_attr_t</span>* __restrict attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">void</span> * (*fn)(<span class="type">void</span>*),</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">void</span>* __restrict arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(!fn, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> start_ns = butil::<span class="built_in">cpuwide_time_ns</span>();</span><br><span class="line">  	<span class="comment">// 强制带一个 attr.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bthread_attr_t</span> using_attr = (attr ? *attr : BTHREAD_ATTR_NORMAL);</span><br><span class="line">    butil::ResourceId&lt;TaskMeta&gt; slot;</span><br><span class="line">    TaskMeta* m = butil::<span class="built_in">get_resource</span>(&amp;slot);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(!m, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"> 		<span class="comment">// 初始化 bthread 的状态.</span></span><br><span class="line">    <span class="built_in">CHECK</span>(m-&gt;current_waiter.<span class="built_in">load</span>(butil::memory_order_relaxed) == <span class="literal">NULL</span>);</span><br><span class="line">    m-&gt;stop = <span class="literal">false</span>;</span><br><span class="line">    m-&gt;interrupted = <span class="literal">false</span>;</span><br><span class="line">    m-&gt;about_to_quit = <span class="literal">false</span>;</span><br><span class="line">    m-&gt;fn = fn;</span><br><span class="line">    m-&gt;arg = arg;</span><br><span class="line">    <span class="built_in">CHECK</span>(m-&gt;stack == <span class="literal">NULL</span>);</span><br><span class="line">    m-&gt;attr = using_attr;</span><br><span class="line">    m-&gt;local_storage = LOCAL_STORAGE_INIT;</span><br><span class="line">    m-&gt;cpuwide_start_ns = start_ns;</span><br><span class="line">    m-&gt;stat = EMPTY_STAT;</span><br><span class="line">    m-&gt;tid = <span class="built_in">make_tid</span>(*m-&gt;version_butex, slot);</span><br><span class="line">    *th = m-&gt;tid;</span><br><span class="line">    <span class="keyword">if</span> (using_attr.flags &amp; BTHREAD_LOG_START_AND_FINISH) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Started bthread &quot;</span> &lt;&lt; m-&gt;tid;</span><br><span class="line">    &#125;</span><br><span class="line">    _control-&gt;_nbthreads &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (REMOTE) &#123;</span><br><span class="line">        <span class="built_in">ready_to_run_remote</span>(m-&gt;tid, (using_attr.flags &amp; BTHREAD_NOSIGNAL));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ready_to_run</span>(m-&gt;tid, (using_attr.flags &amp; BTHREAD_NOSIGNAL));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反正没有构造函数还是蛮丑的。<code>REMOTE</code> 表示是否调用的函数自身也跑在这个 <code>TaskGroup</code> 下面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试 push 到 rq 中, 如果队列满了, 说明创建了太多任务, 会需要 sleep 一下.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TaskGroup::push_rq</span><span class="params">(<span class="type">bthread_t</span> tid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_rq.<span class="built_in">push</span>(tid)) &#123;</span><br><span class="line">        <span class="comment">// Created too many bthreads: a promising approach is to insert the</span></span><br><span class="line">        <span class="comment">// task into another TaskGroup, but we don&#x27;t use it because:</span></span><br><span class="line">        <span class="comment">// * There&#x27;re already many bthreads to run, inserting the bthread</span></span><br><span class="line">        <span class="comment">//   into other TaskGroup does not help.</span></span><br><span class="line">        <span class="comment">// * Insertions into other TaskGroups perform worse when all workers</span></span><br><span class="line">        <span class="comment">//   are busy at creating bthreads (proved by test_input_messenger in</span></span><br><span class="line">        <span class="comment">//   brpc)</span></span><br><span class="line">        <span class="built_in">flush_nosignal_tasks</span>();</span><br><span class="line">        <span class="built_in">LOG_EVERY_SECOND</span>(ERROR) &lt;&lt; <span class="string">&quot;_rq is full, capacity=&quot;</span> &lt;&lt; _rq.<span class="built_in">capacity</span>();</span><br><span class="line">        <span class="comment">// TODO(gejun): May cause deadlock when all workers are spinning here.</span></span><br><span class="line">        <span class="comment">// A better solution is to pop and run existing bthreads, however which</span></span><br><span class="line">        <span class="comment">// make set_remained()-callbacks do context switches and need extensive</span></span><br><span class="line">        <span class="comment">// reviews on related code.</span></span><br><span class="line">        ::<span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskGroup::ready_to_run</span><span class="params">(<span class="type">bthread_t</span> tid, <span class="type">bool</span> nosignal)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">push_rq</span>(tid);</span><br><span class="line">    <span class="keyword">if</span> (nosignal) &#123;</span><br><span class="line">        ++_num_nosignal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signal 应该是 batch signal 的.</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> additional_signal = _num_nosignal;</span><br><span class="line">        _num_nosignal = <span class="number">0</span>;</span><br><span class="line">        _nsignaled += <span class="number">1</span> + additional_signal;</span><br><span class="line">        _control-&gt;<span class="built_in">signal_task</span>(<span class="number">1</span> + additional_signal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_rq</code> 是一个 <code>WorkStealingQueue&lt;bthread_t&gt;</code>, 这个 queue 提供了 <code>push</code> <code>pop</code> 和 <code>steal</code>, 特殊的, <code>push</code> 和 <code>pop</code> 不可能并行, 但是可能有一堆 <code>steal</code> 在和他们并行.</p>
<p>这里 <code>signal_task</code> 会根据任务的数量，来对 <code>ParkingLot</code> 调用对应的 signal, 这里会走到 <code>futex</code> 那一套上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskControl::signal_task</span><span class="params">(<span class="type">int</span> num_task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num_task &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO(gejun): Current algorithm does not guarantee enough threads will</span></span><br><span class="line">    <span class="comment">// be created to match caller&#x27;s requests. But in another side, there&#x27;s also</span></span><br><span class="line">    <span class="comment">// many useless signalings according to current impl. Capping the concurrency</span></span><br><span class="line">    <span class="comment">// is a good balance between performance and timeliness of scheduling.</span></span><br><span class="line">    <span class="keyword">if</span> (num_task &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        num_task = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选中一个 ParkingLot.</span></span><br><span class="line">    <span class="comment">// 这里要寻找 1-2 个 worker 来唤醒.</span></span><br><span class="line">    <span class="type">int</span> start_index = butil::<span class="built_in">fmix64</span>(<span class="built_in">pthread_numeric_id</span>()) % PARKING_LOT_NUM;</span><br><span class="line">    num_task -= _pl[start_index].<span class="built_in">signal</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num_task &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; PARKING_LOT_NUM &amp;&amp; num_task &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++start_index &gt;= PARKING_LOT_NUM) &#123;</span><br><span class="line">                start_index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num_task -= _pl[start_index].<span class="built_in">signal</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还有任务(感觉概率很小), 可能需要动态调度 worker.</span></span><br><span class="line">    <span class="keyword">if</span> (num_task &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        FLAGS_bthread_min_concurrency &gt; <span class="number">0</span> &amp;&amp;    <span class="comment">// test min_concurrency for performance</span></span><br><span class="line">        _concurrency.<span class="built_in">load</span>(butil::memory_order_relaxed) &lt; FLAGS_bthread_concurrency) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Reduce this lock</span></span><br><span class="line">        <span class="built_in">BAIDU_SCOPED_LOCK</span>(g_task_control_mutex);</span><br><span class="line">        <span class="keyword">if</span> (_concurrency.<span class="built_in">load</span>(butil::memory_order_acquire) &lt; FLAGS_bthread_concurrency) &#123;</span><br><span class="line">            <span class="built_in">add_workers</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好，后台这块就丢进任务池子就没事了.</p>
<p>这里再注意一下 <code>ready_to_run_remote</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskGroup::ready_to_run_remote</span><span class="params">(<span class="type">bthread_t</span> tid, <span class="type">bool</span> nosignal)</span> </span>&#123;</span><br><span class="line">    _remote_rq._mutex.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">while</span> (!_remote_rq.<span class="built_in">push_locked</span>(tid)) &#123;</span><br><span class="line">        <span class="built_in">flush_nosignal_tasks_remote_locked</span>(_remote_rq._mutex);</span><br><span class="line">        <span class="built_in">LOG_EVERY_SECOND</span>(ERROR) &lt;&lt; <span class="string">&quot;_remote_rq is full, capacity=&quot;</span></span><br><span class="line">                                &lt;&lt; _remote_rq.<span class="built_in">capacity</span>();</span><br><span class="line">        ::<span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">        _remote_rq._mutex.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nosignal) &#123;</span><br><span class="line">        ++_remote_num_nosignal;</span><br><span class="line">        _remote_rq._mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> additional_signal = _remote_num_nosignal;</span><br><span class="line">        _remote_num_nosignal = <span class="number">0</span>;</span><br><span class="line">        _remote_nsignaled += <span class="number">1</span> + additional_signal;</span><br><span class="line">        _remote_rq._mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        _control-&gt;<span class="built_in">signal_task</span>(<span class="number">1</span> + additional_signal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会塞到 <code>_remote_rq</code> 中. 逻辑和之前 <code>_rq</code> 其实差不多。</p>
<h2 id="TaskGroup-是怎么运行-bthread-的"><a href="#TaskGroup-是怎么运行-bthread-的" class="headerlink" title="TaskGroup 是怎么运行 bthread 的"></a>TaskGroup 是怎么运行 bthread 的</h2><p>还记得<code>TaskControl::signal_task</code> 调用了 <code>add_workers</code> 吗，这里实际上跟进去就是 <code>TaskGroup</code> 具体的逻辑了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pthread_create</span>(&amp;_workers[i + old_concurency], <span class="literal">NULL</span>, worker_thread, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>显然，我们要看 <code>worker_thread</code> 了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">TaskControl::worker_thread</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">run_worker_startfn</span>();    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BAIDU_INTERNAL</span></span><br><span class="line">    logging::ComlogInitializer comlog_initializer;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 里面拿到了 task_control, 然后会创建一个 TaskGroup 挂在物理线程 TLS 下.</span></span><br><span class="line">    TaskControl* c = <span class="built_in">static_cast</span>&lt;TaskControl*&gt;(arg);</span><br><span class="line">    TaskGroup* g = c-&gt;<span class="built_in">create_group</span>();</span><br><span class="line">    TaskStatistics stat;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == g) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(ERROR) &lt;&lt; <span class="string">&quot;Fail to create TaskGroup in pthread=&quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BT_VLOG &lt;&lt; <span class="string">&quot;Created worker=&quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot; bthread=&quot;</span> &lt;&lt; g-&gt;<span class="built_in">main_tid</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定物理线程的任务</span></span><br><span class="line">    tls_task_group = g;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nworkers 统计量增加</span></span><br><span class="line">    c-&gt;_nworkers &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    g-&gt;<span class="built_in">run_main_task</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁自身</span></span><br><span class="line"></span><br><span class="line">    stat = g-&gt;<span class="built_in">main_stat</span>();</span><br><span class="line">    BT_VLOG &lt;&lt; <span class="string">&quot;Destroying worker=&quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; bthread=&quot;</span></span><br><span class="line">            &lt;&lt; g-&gt;<span class="built_in">main_tid</span>() &lt;&lt; <span class="string">&quot; idle=&quot;</span> &lt;&lt; stat.cputime_ns / <span class="number">1000000.0</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;ms uptime=&quot;</span> &lt;&lt; g-&gt;<span class="built_in">current_uptime_ns</span>() / <span class="number">1000000.0</span> &lt;&lt; <span class="string">&quot;ms&quot;</span>;</span><br><span class="line">    tls_task_group = <span class="literal">NULL</span>;</span><br><span class="line">    g-&gt;<span class="built_in">destroy_self</span>();</span><br><span class="line">    c-&gt;_nworkers &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面 <code>TaskGroup::run_main_task</code> 了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物理线程的主要循环.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskGroup::run_main_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">bvar::PassiveStatus&lt;<span class="type">double</span>&gt; <span class="title">cumulated_cputime</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        get_cumulated_cputime_from_this, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    std::unique_ptr&lt;bvar::PerSecond&lt;bvar::PassiveStatus&lt;<span class="type">double</span>&gt; &gt; &gt; usage_bvar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到对应自身对应的 TaskGroup 对象, 这里不需要操作它</span></span><br><span class="line">    TaskGroup* dummy = <span class="keyword">this</span>;</span><br><span class="line">    <span class="type">bthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait_task 会等待下一个任务, 如果返回值为 0, 就退出</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">wait_task</span>(&amp;tid)) &#123;</span><br><span class="line">        <span class="comment">// 运行完下一个任务.</span></span><br><span class="line">        TaskGroup::<span class="built_in">sched_to</span>(&amp;dummy, tid);</span><br><span class="line">        <span class="built_in">DCHECK_EQ</span>(<span class="keyword">this</span>, dummy);</span><br><span class="line">        <span class="built_in">DCHECK_EQ</span>(_cur_meta-&gt;stack, _main_stack);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sched_to 只是运行单个任务,</span></span><br><span class="line">        <span class="keyword">if</span> (_cur_meta-&gt;tid != _main_tid) &#123;</span><br><span class="line">            TaskGroup::<span class="built_in">task_runner</span>(<span class="number">1</span><span class="comment">/*skip remained*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一些相关的配置, 记录 CPU-Time</span></span><br><span class="line">        <span class="keyword">if</span> (FLAGS_show_per_worker_usage_in_vars &amp;&amp; !usage_bvar) &#123;</span><br><span class="line">            <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(OS_MACOSX)</span></span><br><span class="line">            <span class="built_in">snprintf</span>(name, <span class="built_in">sizeof</span>(name), <span class="string">&quot;bthread_worker_usage_%&quot;</span> PRIu64,</span><br><span class="line">                     <span class="built_in">pthread_numeric_id</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="built_in">snprintf</span>(name, <span class="built_in">sizeof</span>(name), <span class="string">&quot;bthread_worker_usage_%ld&quot;</span>,</span><br><span class="line">                     (<span class="type">long</span>)<span class="built_in">syscall</span>(SYS_gettid));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            usage_bvar.<span class="built_in">reset</span>(<span class="keyword">new</span> bvar::PerSecond&lt;bvar::PassiveStatus&lt;<span class="type">double</span>&gt; &gt;</span><br><span class="line">                             (name, &amp;cumulated_cputime, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don&#x27;t forget to add elapse of last wait_task.</span></span><br><span class="line">    <span class="built_in">current_task</span>()-&gt;stat.cputime_ns += butil::<span class="built_in">cpuwide_time_ns</span>() - _last_run_ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几个关键点：</p>
<ol>
<li><code>wait_task</code></li>
<li><code>TaskGroup::sched_to</code></li>
<li><code>TaskGroup::task_runner</code></li>
</ol>
<p>第一个 <code>wait_task</code> 可以和之前的联动：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TaskGroup::wait_task</span><span class="params">(<span class="type">bthread_t</span>* tid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BTHREAD_DONT_SAVE_PARKING_STATE</span></span><br><span class="line">        <span class="comment">// 如果 stop 了, 就润走.</span></span><br><span class="line">        <span class="keyword">if</span> (_last_pl_state.<span class="built_in">stopped</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待有任务, 需要 signal 等方式来调用.</span></span><br><span class="line">        _pl-&gt;<span class="built_in">wait</span>(_last_pl_state);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">steal_task</span>(tid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">const</span> ParkingLot::State st = _pl-&gt;<span class="built_in">get_state</span>();</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">stopped</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">steal_task</span>(tid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _pl-&gt;<span class="built_in">wait</span>(st);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 remote_rq 中 steal 任务.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">steal_task</span><span class="params">(<span class="type">bthread_t</span>* tid)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_remote_rq.<span class="built_in">pop</span>(tid)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BTHREAD_DONT_SAVE_PARKING_STATE</span></span><br><span class="line">  _last_pl_state = _pl-&gt;<span class="built_in">get_state</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> _control-&gt;<span class="built_in">steal_task</span>(tid, &amp;_steal_seed, _steal_offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>TaskControl::steal_task</code> 会分别从 <code>_rq</code> 和 <code>_remote_rq</code> 拿：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TaskControl::steal_task</span><span class="params">(<span class="type">bthread_t</span>* tid, <span class="type">size_t</span>* seed, <span class="type">size_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1: Acquiring fence is paired with releasing fence in _add_group to</span></span><br><span class="line">    <span class="comment">// avoid accessing uninitialized slot of _groups.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> ngroup = _ngroup.<span class="built_in">load</span>(butil::memory_order_acquire<span class="comment">/*1*/</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == ngroup) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Don&#x27;t return inside `for&#x27; iteration since we need to update |seed|</span></span><br><span class="line">    <span class="type">bool</span> stolen = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">size_t</span> s = *seed;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ngroup; ++i, s += offset) &#123;</span><br><span class="line">        TaskGroup* g = _groups[s % ngroup];</span><br><span class="line">        <span class="comment">// g is possibly NULL because of concurrent _destroy_group</span></span><br><span class="line">        <span class="keyword">if</span> (g) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g-&gt;_rq.<span class="built_in">steal</span>(tid)) &#123;</span><br><span class="line">                stolen = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g-&gt;_remote_rq.<span class="built_in">pop</span>(tid)) &#123;</span><br><span class="line">                stolen = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *seed = s;</span><br><span class="line">    <span class="keyword">return</span> stolen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sched-to"><a href="#sched-to" class="headerlink" title="sched_to"></a>sched_to</h3><p>这是最重要的函数了，涉及了具体 Fiber 的运行、切栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TaskGroup::sched_to</span><span class="params">(TaskGroup** pg, <span class="type">bthread_t</span> next_tid)</span> </span>&#123;</span><br><span class="line">    TaskMeta* next_meta = <span class="built_in">address_meta</span>(next_tid);</span><br><span class="line">    <span class="keyword">if</span> (next_meta-&gt;stack == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ContextualStack* stk = <span class="built_in">get_stack</span>(next_meta-&gt;<span class="built_in">stack_type</span>(), task_runner);</span><br><span class="line">        <span class="keyword">if</span> (stk) &#123;</span><br><span class="line">            next_meta-&gt;<span class="built_in">set_stack</span>(stk);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// stack_type is BTHREAD_STACKTYPE_PTHREAD or out of memory,</span></span><br><span class="line">            <span class="comment">// In latter case, attr is forced to be BTHREAD_STACKTYPE_PTHREAD.</span></span><br><span class="line">            <span class="comment">// This basically means that if we can&#x27;t allocate stack, run</span></span><br><span class="line">            <span class="comment">// the task in pthread directly.</span></span><br><span class="line">            next_meta-&gt;attr.stack_type = BTHREAD_STACKTYPE_PTHREAD;</span><br><span class="line">            next_meta-&gt;<span class="built_in">set_stack</span>((*pg)-&gt;_main_stack);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Update now_ns only when wait_task did yield.</span></span><br><span class="line">    <span class="built_in">sched_to</span>(pg, next_meta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get_stack</code> 会拿到一个栈，这里还是由对象池申请的定长对象。这里 <code>task_runner</code> 函数负责具体运行。</p>
<p>这里需要着重看一下 <code>bthread_make_fcontext</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">StackStorage</span> &#123;</span><br><span class="line">     <span class="type">int</span> stacksize;</span><br><span class="line">     <span class="type">int</span> guardsize;</span><br><span class="line">    <span class="comment">// Assume stack grows upwards.</span></span><br><span class="line">    <span class="comment">// http://www.boost.org/doc/libs/1_55_0/libs/context/doc/html/context/stack.html</span></span><br><span class="line">    <span class="type">void</span>* bottom;</span><br><span class="line">    <span class="type">unsigned</span> valgrind_stack_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clears all members.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">zeroize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stacksize = <span class="number">0</span>;</span><br><span class="line">        guardsize = <span class="number">0</span>;</span><br><span class="line">        bottom = <span class="literal">NULL</span>;</span><br><span class="line">        valgrind_stack_id = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Allocate a piece of stack.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">allocate_stack_storage</span><span class="params">(StackStorage* s, <span class="type">int</span> stacksize, <span class="type">int</span> guardsize)</span></span>;</span><br><span class="line"><span class="comment">// Deallocate a piece of stack. Parameters MUST be returned or set by the</span></span><br><span class="line"><span class="comment">// corresponding allocate_stack_storage() otherwise behavior is undefined.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate_stack_storage</span><span class="params">(StackStorage* s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">StackType</span> &#123;</span><br><span class="line">    STACK_TYPE_MAIN = <span class="number">0</span>,</span><br><span class="line">    STACK_TYPE_PTHREAD = BTHREAD_STACKTYPE_PTHREAD,</span><br><span class="line">    STACK_TYPE_SMALL = BTHREAD_STACKTYPE_SMALL,</span><br><span class="line">    STACK_TYPE_NORMAL = BTHREAD_STACKTYPE_NORMAL,</span><br><span class="line">    STACK_TYPE_LARGE = BTHREAD_STACKTYPE_LARGE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContextualStack</span> &#123;</span><br><span class="line">    <span class="type">bthread_fcontext_t</span> context;</span><br><span class="line">    StackType stacktype;</span><br><span class="line">    StackStorage storage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> StackClass&gt; <span class="keyword">struct</span> <span class="title class_">StackFactory</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Wrapper</span> : <span class="keyword">public</span> ContextualStack &#123;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Wrapper</span><span class="params">(<span class="type">void</span> (*entry)(<span class="type">intptr_t</span>))</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">allocate_stack_storage</span>(&amp;storage, *StackClass::stack_size_flag,</span><br><span class="line">                                       FLAGS_guard_page_size) != <span class="number">0</span>) &#123;</span><br><span class="line">                storage.<span class="built_in">zeroize</span>();</span><br><span class="line">                context = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建一个带有 entry 的 fcontext, 到时候会回退.</span></span><br><span class="line">            context = <span class="built_in">bthread_make_fcontext</span>(storage.bottom, storage.stacksize, entry);</span><br><span class="line">            stacktype = (StackType)StackClass::stacktype;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Wrapper</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (context) &#123;</span><br><span class="line">                context = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">deallocate_stack_storage</span>(&amp;storage);</span><br><span class="line">                storage.<span class="built_in">zeroize</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> ContextualStack* <span class="title">get_stack</span><span class="params">(<span class="type">void</span> (*entry)(<span class="type">intptr_t</span>))</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> butil::<span class="built_in">get_object</span>&lt;Wrapper&gt;(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">return_stack</span><span class="params">(ContextualStack* sc)</span> </span>&#123;</span><br><span class="line">        butil::<span class="built_in">return_object</span>(<span class="built_in">static_cast</span>&lt;Wrapper*&gt;(sc));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>话说回来，之前写 xv6 lab 的时候踩过一个栈增长的坑，x86 栈是自上而下增长的，栈的 bottom 在一个高地址，所以 <code>allocate_stack_storage</code> 注意一下这个 <code>bottom</code> 是 <code>malloc() + STACK_SIZE</code>.</p>
<p><code>bthread_make_fcontext</code> 基本上是从 <code>boost::Context</code> 偷来的，我们这直接看看 boost 的 RISC-V 代码：<a target="_blank" rel="noopener" href="https://github.com/boostorg/context/blob/develop/src/asm/make_riscv64_sysv_elf_gas.S">https://github.com/boostorg/context/blob/develop/src/asm/make_riscv64_sysv_elf_gas.S</a></p>
<p>这里有两个要注意的地方：</p>
<ol>
<li>只保存了 callee-saved 的寄存器，因为 caller saved 我们之后会看到</li>
<li><code>ra</code> 设置成了 <code>_exit</code>，这个是做一个兜底，如果 <code>fiber</code> 结尾不调度给别的 fiber 或者返回 main, 这里就会直接 exit.</li>
</ol>
<p>我们和 <code>task_runner</code> 联动看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际运行 task 在 task_runner 内, TaskMeta 任务执行的时候也会包装这么一层.</span></span><br><span class="line"><span class="comment">// 它有两个调用源: bthread 的栈里调用, TaskGroup 在 run_main_task 里调用.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// m-&gt;fn 的函数可能会调 起 bthread 的任务、bthread_usleep.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskGroup::task_runner</span><span class="params">(<span class="type">intptr_t</span> skip_remained)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> tls_task_group is volatile since tasks are moved around</span></span><br><span class="line">    <span class="comment">//       different groups.</span></span><br><span class="line">    TaskGroup* g = tls_task_group;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!skip_remained) &#123;</span><br><span class="line">        <span class="keyword">while</span> (g-&gt;_last_context_remained) &#123;</span><br><span class="line">            RemainedFn fn = g-&gt;_last_context_remained;</span><br><span class="line">            g-&gt;_last_context_remained = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">fn</span>(g-&gt;_last_context_remained_arg);</span><br><span class="line">            g = tls_task_group;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">        --g-&gt;_sched_recursive_guard;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// A task can be stopped before it gets running, in which case</span></span><br><span class="line">        <span class="comment">// we may skip user function, but that may confuse user:</span></span><br><span class="line">        <span class="comment">// Most tasks have variables to remember running result of the task,</span></span><br><span class="line">        <span class="comment">// which is often initialized to values indicating success. If an</span></span><br><span class="line">        <span class="comment">// user function is never called, the variables will be unchanged</span></span><br><span class="line">        <span class="comment">// however they&#x27;d better reflect failures because the task is stopped</span></span><br><span class="line">        <span class="comment">// abnormally.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Meta and identifier of the task is persistent in this run.</span></span><br><span class="line">        TaskMeta* <span class="type">const</span> m = g-&gt;_cur_meta;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FLAGS_show_bthread_creation_in_vars) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> the thread triggering exposure of pending time may spend</span></span><br><span class="line">            <span class="comment">// considerable time because a single bvar::LatencyRecorder</span></span><br><span class="line">            <span class="comment">// contains many bvar.</span></span><br><span class="line">            g-&gt;_control-&gt;<span class="built_in">exposed_pending_time</span>() &lt;&lt;</span><br><span class="line">                (butil::<span class="built_in">cpuwide_time_ns</span>() - m-&gt;cpuwide_start_ns) / <span class="number">1000L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not catch exceptions except ExitException which is for implementing</span></span><br><span class="line">        <span class="comment">// bthread_exit(). User code is intended to crash when an exception is</span></span><br><span class="line">        <span class="comment">// not caught explicitly. This is consistent with other threading</span></span><br><span class="line">        <span class="comment">// libraries.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目前这里应该都是 0, 嘻嘻.</span></span><br><span class="line">        <span class="type">void</span>* thread_return;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行 m-&gt;fn().</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread_return = m-&gt;<span class="built_in">fn</span>(m-&gt;arg);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (ExitException&amp; e) &#123;</span><br><span class="line">            thread_return = e.<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Group is probably changed</span></span><br><span class="line">        g = tls_task_group;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Save thread_return</span></span><br><span class="line">        (<span class="type">void</span>)thread_return;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging must be done before returning the keytable, since the logging lib</span></span><br><span class="line">        <span class="comment">// use bthread local storage internally, or will cause memory leak.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> the time from quiting fn to here is not counted into cputime</span></span><br><span class="line">        <span class="keyword">if</span> (m-&gt;attr.flags &amp; BTHREAD_LOG_START_AND_FINISH) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Finished bthread &quot;</span> &lt;&lt; m-&gt;tid &lt;&lt; <span class="string">&quot;, cputime=&quot;</span></span><br><span class="line">                      &lt;&lt; m-&gt;stat.cputime_ns / <span class="number">1000000.0</span> &lt;&lt; <span class="string">&quot;ms&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clean tls variables, must be done before changing version_butex</span></span><br><span class="line">        <span class="comment">// otherwise another thread just joined this thread may not see side</span></span><br><span class="line">        <span class="comment">// effects of destructing tls variables.</span></span><br><span class="line">        KeyTable* kt = tls_bls.keytable;</span><br><span class="line">        <span class="keyword">if</span> (kt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">return_keytable</span>(m-&gt;attr.keytable_pool, kt);</span><br><span class="line">            <span class="comment">// After deletion: tls may be set during deletion.</span></span><br><span class="line">            tls_bls.keytable = <span class="literal">NULL</span>;</span><br><span class="line">            m-&gt;local_storage.keytable = <span class="literal">NULL</span>; <span class="comment">// optional</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Increase the version and wake up all joiners, if resulting version</span></span><br><span class="line">        <span class="comment">// is 0, change it to 1 to make bthread_t never be 0. Any access</span></span><br><span class="line">        <span class="comment">// or join to the bthread after changing version will be rejected.</span></span><br><span class="line">        <span class="comment">// The spinlock is for visibility of TaskGroup::get_attr.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">BAIDU_SCOPED_LOCK</span>(m-&gt;version_lock);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == ++*m-&gt;version_butex) &#123;</span><br><span class="line">                ++*m-&gt;version_butex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">butex_wake_except</span>(m-&gt;version_butex, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        g-&gt;_control-&gt;_nbthreads &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 这个设置一个回收掉 m 的 callback.</span></span><br><span class="line">        g-&gt;<span class="built_in">set_remained</span>(TaskGroup::_release_last_context, m);</span><br><span class="line">        <span class="comment">// task_group 完成一次调度.</span></span><br><span class="line">        <span class="built_in">ending_sched</span>(&amp;g);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (g-&gt;_cur_meta-&gt;tid != g-&gt;_main_tid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Was called from a pthread and we don&#x27;t have BTHREAD_STACKTYPE_PTHREAD</span></span><br><span class="line">    <span class="comment">// tasks to run, quit for more tasks.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数是整个 bthread 调度的核中核，我们理一下：</p>
<ol>
<li>拿到现有 <code>TaskGroup</code> ，即现有 worker </li>
<li>执行 <code>_last_context_remained</code>，清理掉 <code>TaskGroup</code> 上一次执行对应的资源</li>
<li>在循环中，拿到 bthread 栈对应的 meta，这是需要执行的对象</li>
<li>运行 <code>m-&gt;fn()</code>，这里是真正的逻辑<ol>
<li>需要注意的是，<code>m-&gt;fn()</code> 运行的时候，可能发生上下文切换，比如 <code>m-&gt;fn()</code> 里面调用了 <code>bthread_usleep</code>.</li>
</ol>
</li>
<li>清理上下文</li>
<li>调用 <code>ending_sched</code></li>
</ol>
<p><code>(3)</code> 这就是用户给 <code>bthread_start_background</code> 任务具体被执行的 point 了！</p>
<h4 id="sched-to-具体逻辑"><a href="#sched-to-具体逻辑" class="headerlink" title="sched_to 具体逻辑"></a>sched_to 具体逻辑</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskGroup::sched_to</span><span class="params">(TaskGroup** pg, TaskMeta* next_meta)</span> </span>&#123;</span><br><span class="line">    TaskGroup* g = *pg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="keyword">if</span> ((++g-&gt;_sched_recursive_guard) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Recursively(&quot;</span> &lt;&lt; g-&gt;_sched_recursive_guard - <span class="number">1</span></span><br><span class="line">                   &lt;&lt; <span class="string">&quot;) call sched_to(&quot;</span> &lt;&lt; g &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// Save errno so that errno is bthread-specific.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> saved_errno = errno;</span><br><span class="line">    <span class="type">void</span>* saved_unique_user_ptr = tls_unique_user_ptr;</span><br><span class="line"></span><br><span class="line">    TaskMeta* <span class="type">const</span> cur_meta = g-&gt;_cur_meta;</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> now = butil::<span class="built_in">cpuwide_time_ns</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> elp_ns = now - g-&gt;_last_run_ns;</span><br><span class="line">    g-&gt;_last_run_ns = now;</span><br><span class="line">    cur_meta-&gt;stat.cputime_ns += elp_ns;</span><br><span class="line">    <span class="keyword">if</span> (cur_meta-&gt;tid != g-&gt;<span class="built_in">main_tid</span>()) &#123;</span><br><span class="line">        g-&gt;_cumulated_cputime_ns += elp_ns;</span><br><span class="line">    &#125;</span><br><span class="line">    ++cur_meta-&gt;stat.nswitch;</span><br><span class="line">    ++ g-&gt;_nswitch;</span><br><span class="line">    <span class="comment">// Switch to the task</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(next_meta != cur_meta, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 这里把 _cur_meta 设置成要执行的 cur_meta.</span></span><br><span class="line">        g-&gt;_cur_meta = next_meta;</span><br><span class="line">        <span class="comment">// Switch tls_bls</span></span><br><span class="line">        cur_meta-&gt;local_storage = tls_bls;</span><br><span class="line">        tls_bls = next_meta-&gt;local_storage;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Logging must be done after switching the local storage, since the logging lib</span></span><br><span class="line">        <span class="comment">// use bthread local storage internally, or will cause memory leak.</span></span><br><span class="line">        <span class="keyword">if</span> ((cur_meta-&gt;attr.flags &amp; BTHREAD_LOG_CONTEXT_SWITCH) ||</span><br><span class="line">            (next_meta-&gt;attr.flags &amp; BTHREAD_LOG_CONTEXT_SWITCH)) &#123;</span><br><span class="line">            <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Switch bthread: &quot;</span> &lt;&lt; cur_meta-&gt;tid &lt;&lt; <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">                      &lt;&lt; next_meta-&gt;tid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur_meta-&gt;stack != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next_meta-&gt;stack != cur_meta-&gt;stack) &#123;</span><br><span class="line">                <span class="built_in">jump_stack</span>(cur_meta-&gt;stack, next_meta-&gt;stack);</span><br><span class="line">                <span class="comment">// probably went to another group, need to assign g again.</span></span><br><span class="line">                g = tls_task_group;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// else pthread_task is switching to another pthread_task, sc</span></span><br><span class="line">                <span class="comment">// can only equal when they&#x27;re both _main_stack</span></span><br><span class="line">                <span class="built_in">CHECK</span>(cur_meta-&gt;stack == g-&gt;_main_stack);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else because of ending_sched(including pthread_task-&gt;pthread_task)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(FATAL) &lt;&lt; <span class="string">&quot;bthread=&quot;</span> &lt;&lt; g-&gt;<span class="built_in">current_tid</span>() &lt;&lt; <span class="string">&quot; sched_to itself!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (g-&gt;_last_context_remained) &#123;</span><br><span class="line">        RemainedFn fn = g-&gt;_last_context_remained;</span><br><span class="line">        g-&gt;_last_context_remained = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">fn</span>(g-&gt;_last_context_remained_arg);</span><br><span class="line">        g = tls_task_group;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore errno</span></span><br><span class="line">    errno = saved_errno;</span><br><span class="line">    tls_unique_user_ptr = saved_unique_user_ptr;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    --g-&gt;_sched_recursive_guard;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    *pg = g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>sched_to</code> 中，我们要先理解 <code>jump_stack</code> 才能理解 <code>sched_to</code>, <code>jump_stack</code> 也是 <code>boost::Context</code> 抄来的：<a target="_blank" rel="noopener" href="https://github.com/boostorg/context/blob/develop/src/asm/jump_riscv64_sysv_elf_gas.S">https://github.com/boostorg/context/blob/develop/src/asm/jump_riscv64_sysv_elf_gas.S</a></p>
<ol>
<li>保存所有 callee-saved registers</li>
<li>把 ra 设置成需要 jump 到的目标</li>
<li>恢复所有新的 called-saved registers</li>
</ol>
<p>那么，我们假设有多个 <code>bthread</code>,  <code>TaskGroup</code> 的 worker 调用了 <code>sched_to</code>, 然后系统会挑选第一个 bthread 来执行。假设执行完了，这里又回回到这个调度点。同时，<code>TaskGroup::sched_to</code> 这个函数在 <code>jump_stack</code> 前后可能被不同的线程执行！</p>
<p>知道这个，再看一些上下文代码就会清晰很多了。</p>
<h3 id="ending-sched"><a href="#ending-sched" class="headerlink" title="ending_sched"></a>ending_sched</h3><p>bthread 调度的时候，实际上如果 <code>task_runner</code> 在 bthread 中调用，那么它不会退出，只会随着 <code>ending_sched</code> 切到别的上下文。<code>ending_sched</code> 在这里做了 bthread 的调度和回收工作。可能在 <code>ending_sched</code> 结束后，bthread 就运行一个新的栈了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个调度完成了, 尝试调度运行到下一组 task.</span></span><br><span class="line"><span class="comment">// 这里通过 TaskGroup::task_runner 来包装了一层 Task, 它可能又在 task_runner 被调用.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskGroup::ending_sched</span><span class="params">(TaskGroup** pg)</span> </span>&#123;</span><br><span class="line">    TaskGroup* g = *pg;</span><br><span class="line">    <span class="type">bthread_t</span> next_tid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Find next task to run, if none, switch to idle thread of the group.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    BTHREAD_FAIR_WSQ 会有帮助吗?</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BTHREAD_FAIR_WSQ</span></span><br><span class="line">    <span class="comment">// When BTHREAD_FAIR_WSQ is defined, profiling shows that cpu cost of</span></span><br><span class="line">    <span class="comment">// WSQ::steal() in example/multi_threaded_echo_c++ changes from 1.9%</span></span><br><span class="line">    <span class="comment">// to 2.9%</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> popped = g-&gt;_rq.<span class="built_in">pop</span>(&amp;next_tid);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> popped = g-&gt;_rq.<span class="built_in">steal</span>(&amp;next_tid);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单控制一下, 如果 rq 没有, remote 也没有, 才会设置成 main_tid.</span></span><br><span class="line">    <span class="comment">// 这就要等待唤醒了.</span></span><br><span class="line">    <span class="keyword">if</span> (!popped &amp;&amp; !g-&gt;<span class="built_in">steal_task</span>(&amp;next_tid)) &#123;</span><br><span class="line">        <span class="comment">// Jump to main task if there&#x27;s no task to run.</span></span><br><span class="line">        next_tid = g-&gt;_main_tid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到现有的 meta, 可能之后要被回收了.</span></span><br><span class="line">    TaskMeta* <span class="type">const</span> cur_meta = g-&gt;_cur_meta;</span><br><span class="line">    <span class="comment">// 定下下一个需要跳转的栈</span></span><br><span class="line">    TaskMeta* next_meta = <span class="built_in">address_meta</span>(next_tid);</span><br><span class="line">    <span class="comment">// 需要创建栈.</span></span><br><span class="line">    <span class="keyword">if</span> (next_meta-&gt;stack == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next_meta-&gt;<span class="built_in">stack_type</span>() == cur_meta-&gt;<span class="built_in">stack_type</span>()) &#123;</span><br><span class="line">            <span class="comment">// also works with pthread_task scheduling to pthread_task, the</span></span><br><span class="line">            <span class="comment">// transferred stack is just _main_stack.</span></span><br><span class="line">            next_meta-&gt;<span class="built_in">set_stack</span>(cur_meta-&gt;<span class="built_in">release_stack</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 Stack,</span></span><br><span class="line">            ContextualStack* stk = <span class="built_in">get_stack</span>(next_meta-&gt;<span class="built_in">stack_type</span>(), task_runner);</span><br><span class="line">            <span class="keyword">if</span> (stk) &#123;</span><br><span class="line">                next_meta-&gt;<span class="built_in">set_stack</span>(stk);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// stack_type is BTHREAD_STACKTYPE_PTHREAD or out of memory,</span></span><br><span class="line">                <span class="comment">// In latter case, attr is forced to be BTHREAD_STACKTYPE_PTHREAD.</span></span><br><span class="line">                <span class="comment">// This basically means that if we can&#x27;t allocate stack, run</span></span><br><span class="line">                <span class="comment">// the task in pthread directly.</span></span><br><span class="line">                next_meta-&gt;attr.stack_type = BTHREAD_STACKTYPE_PTHREAD;</span><br><span class="line">                next_meta-&gt;<span class="built_in">set_stack</span>(g-&gt;_main_stack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sched_to</span>(pg, next_meta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个问题是，<code>fcontext</code> 的 <code>ra</code> 是 <code>_exit</code>，这里不会出现碰到结尾直接退出的问题吗？答案是 <code>ending_sched</code> 的时候，直接把你这个栈给准备灭了，等下一次调度到别的地方的时候，直接把你这个整个栈换了。这样就不会走到 <code>_exit</code> 啦~</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TaskControl-TaskGroup-%E5%92%8C-Queue"><span class="toc-number">1.</span> <span class="toc-text">TaskControl, TaskGroup 和 Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TaskGroup-%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C-bthread-%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">TaskGroup 是怎么运行 bthread 的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sched-to"><span class="toc-number">2.1.</span> <span class="toc-text">sched_to</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sched-to-%E5%85%B7%E4%BD%93%E9%80%BB%E8%BE%91"><span class="toc-number">2.1.1.</span> <span class="toc-text">sched_to 具体逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ending-sched"><span class="toc-number">2.2.</span> <span class="toc-text">ending_sched</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&text=bthread 调度的机制"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&title=bthread 调度的机制"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&is_video=false&description=bthread 调度的机制"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=bthread 调度的机制&body=Check out this article: http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&title=bthread 调度的机制"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&title=bthread 调度的机制"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&title=bthread 调度的机制"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&title=bthread 调度的机制"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&name=bthread 调度的机制&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2022/03/30/bthread-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%9C%BA%E5%88%B6/&t=bthread 调度的机制"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2024
    mwish
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FL51GBW6JT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FL51GBW6JT');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
