<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="arrow 代码库包含了 Parquet 的 C++ 官方实现，尽管 impala 之类的第三方实现处理的功能要多一些，但是 back to basics，看看 parquet 这个也不是一件坏事。 需要声明的是，如 Velox 所说，使用 Parquet 来访问 IO 本身也需要一些复杂的项目。这些部分可能包括：  谓词下推 IO 访问 Lazy Decoding 全局字典  具体可以参考 ab">
<meta property="og:type" content="article">
<meta property="og:title" content="Parquet Part2: arrow Parquet and levels">
<meta property="og:url" content="http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/index.html">
<meta property="og:site_name" content="风空之岛">
<meta property="og:description" content="arrow 代码库包含了 Parquet 的 C++ 官方实现，尽管 impala 之类的第三方实现处理的功能要多一些，但是 back to basics，看看 parquet 这个也不是一件坏事。 需要声明的是，如 Velox 所说，使用 Parquet 来访问 IO 本身也需要一些复杂的项目。这些部分可能包括：  谓词下推 IO 访问 Lazy Decoding 全局字典  具体可以参考 ab">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.mwish.me/blog-image/D113AFDFF7CD13071A3A407B9CED5CC3.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/83EE405A-49D0-4A4A-89E7-9BB222B2505E.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/3139E767-4789-4593-B147-B2618FE224F7.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/C865616E-E6CF-47FD-8440-A0F5E5EF8F47.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/0A39F9FA-54F7-4E5A-8FBC-FAD7AB5FE42B.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/49EB35E6-7864-49CA-B433-FB985F598909.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/parquet-c1.jpg">
<meta property="og:image" content="https://image.mwish.me/blog-image/parquet-c2.jpg">
<meta property="og:image" content="https://image.mwish.me/blog-image/parquet-c2-1.jpg">
<meta property="og:image" content="https://image.mwish.me/blog-image/parquet-c3-0.jpg">
<meta property="og:image" content="https://image.mwish.me/blog-image/parquet-c3-1.jpg">
<meta property="og:image" content="https://image.mwish.me/blog-image/parquet-c4-0.jpg">
<meta property="article:published_time" content="2022-10-04T08:15:00.000Z">
<meta property="article:modified_time" content="2022-10-11T16:40:16.112Z">
<meta property="article:author" content="mwish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.mwish.me/blog-image/D113AFDFF7CD13071A3A407B9CED5CC3.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/logo.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico">
        
      
    
    <!-- title -->
    <title>Parquet Part2: arrow Parquet and levels</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2022/10/19/Parquet-Part3-read-rep-and-def-levels/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/09/18/futures-promise-executors-continuation/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&text=Parquet Part2: arrow Parquet and levels"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&title=Parquet Part2: arrow Parquet and levels"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&is_video=false&description=Parquet Part2: arrow Parquet and levels"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Parquet Part2: arrow Parquet and levels&body=Check out this article: http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&title=Parquet Part2: arrow Parquet and levels"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&title=Parquet Part2: arrow Parquet and levels"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&title=Parquet Part2: arrow Parquet and levels"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&title=Parquet Part2: arrow Parquet and levels"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&name=Parquet Part2: arrow Parquet and levels&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&t=Parquet Part2: arrow Parquet and levels"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrow-cheatsheet"><span class="toc-number">1.</span> <span class="toc-text">Arrow cheatsheet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Array"><span class="toc-number">1.1.</span> <span class="toc-text">Array</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rep-Level-and-Def-Levels"><span class="toc-number">2.</span> <span class="toc-text">Rep Level and Def Levels</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PathBuilder-%E6%9E%84%E5%BB%BA-Node-%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.</span> <span class="toc-text">PathBuilder: 构建 Node 阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%88%B6%E7%BA%A7%E5%88%AB-null"><span class="toc-number">2.1.1.</span> <span class="toc-text">处理父级别 null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-struct"><span class="toc-number">2.1.2.</span> <span class="toc-text">访问 struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-ListArray"><span class="toc-number">2.1.3.</span> <span class="toc-text">访问 ListArray</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9"><span class="toc-number">2.1.4.</span> <span class="toc-text">访问叶子结点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Write-%E9%98%B6%E6%AE%B5"><span class="toc-number">2.2.</span> <span class="toc-text">Write 阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WritePath-%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">WritePath 的算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">具体实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Samples-for-write"><span class="toc-number">3.</span> <span class="toc-text">Samples for write</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-1-i32"><span class="toc-number">3.1.</span> <span class="toc-text">Case 1: i32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-2-optional-i32"><span class="toc-number">3.2.</span> <span class="toc-text">Case 2: optional i32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-3-array-lt-i32-4-gt"><span class="toc-number">3.3.</span> <span class="toc-text">Case 3: array&lt;i32, 4&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Case-3-1-array-lt-optional-i32-4-gt"><span class="toc-number">3.3.1.</span> <span class="toc-text">Case 3-1: array&lt;optional i32, 4&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-List-lt-int32-gt"><span class="toc-number">3.4.</span> <span class="toc-text">Case: List&lt;int32&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-4-optional-array-lt-optional-i32-4-gt"><span class="toc-number">3.5.</span> <span class="toc-text">Case 4: optional array&lt;optional i32, 4&gt;</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Parquet Part2: arrow Parquet and levels
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">mwish</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-10-04T08:15:00.000Z" itemprop="datePublished">2022-10-04</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>arrow 代码库包含了 Parquet 的 C++ 官方实现，尽管 impala 之类的第三方实现处理的功能要多一些，但是 back to basics，看看 parquet 这个也不是一件坏事。</p>
<p>需要声明的是，如 Velox 所说，使用 Parquet 来访问 IO 本身也需要一些复杂的项目。这些部分可能包括：</p>
<ol>
<li>谓词下推</li>
<li>IO 访问</li>
<li>Lazy Decoding</li>
<li>全局字典</li>
</ol>
<p>具体可以参考 abadi 的论文，其实没什么难的，工程上基本上也没啥花头，嗯写就是了。这些可能之后介绍的时候会讲，先就跳过吧。我们直接进入正题：Parquet 的 arrow 官方实现。</p>
<p>这一版本实现有一些须知：</p>
<ol>
<li>数据来源是 arrow (通常是 <code>arrow::Array</code>)，schema 也来自 arrow。</li>
<li>parquet 官方的 thrift 在：<a target="_blank" rel="noopener" href="https://github.com/apache/parquet-format/blob/master/src/main/thrift/parquet.thrift">https://github.com/apache/parquet-format/blob/master/src/main/thrift/parquet.thrift</a> 。arrow 包装了一层访问层，位于 <code>src/parquet/metadata.h</code>。内部实现放在 <code>parquet/thrift_internal.h</code></li>
<li>对文件的访问包含在了 <code>src/parquet/platform.h</code>，其中，<code>::arrow::io::InputStream</code> 是对输入流的抽象、<code>::arrow::io::RandomAccessFile</code> 是对输入文件的抽象。关于这些，相关的内容实现在 <code>arrow/io</code> 下，部分实现者比如 mmap 文件、hdfs 文件。而 arrow 还有一套文件系统的抽象，比如 <code>arrow/filesystem</code>，实现了 <code>s3</code> 和 <code>local</code> 的文件系统抽象（不知道为啥 <code>HadoopFileSystem</code> 在目前版本没有放到 filesystem 下）。</li>
<li>输出被包装在 <code>::arrow::io::BufferOutputStream</code> 中，这个也支持 mmap, s3, hdfs 等</li>
<li>加密、默认值、配置值相关的配置在 <code>properties.h</code> 里面</li>
</ol>
<p>上面都是配置的逻辑。arrow 的代码实现大量采用了 pimpl 的逻辑，有一堆:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XXX</span> &#123;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Contents</span> &#123;...&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> std::unique_ptr&lt;Contents&gt; contents_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这样的 sb 逻辑</p>
<h2 id="Arrow-cheatsheet"><a href="#Arrow-cheatsheet" class="headerlink" title="Arrow cheatsheet"></a>Arrow cheatsheet</h2><p>虽然我们主题不是介绍 Arrow，不过可以简单介绍一下 arrow 的类型系统，提供一些简单的 cheatsheet。具体对 arrow 介绍估计也不多。</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>Array 是其中最基本的类型，大概是「列式数组」的概念，支持 null、嵌套、变长、数组格式等。另外，可以从代码层面注意一下，这里的字符串 Buffer 可能并不需要 owned，但是需要是连续的，几个部分需要在同一个 buffer 里，之间没有 padding。数据因为需要 $O(1)$ 找到位置，所以是 null 的地方会是一个 undefined 的值，但是要占着内存。</p>
<p>下面的内容有两个来源：</p>
<ol>
<li>官方的 format，很快可以读完，大概30分钟：<a target="_blank" rel="noopener" href="https://arrow.apache.org/docs/format/Columnar.html#fixed-size-list-layout">https://arrow.apache.org/docs/format/Columnar.html#fixed-size-list-layout</a> </li>
<li>In-Memory Analytics with Apache Arrow 第一章，这里的图片非常好。</li>
</ol>
<p><img src="https://image.mwish.me/blog-image/D113AFDFF7CD13071A3A407B9CED5CC3.png" alt="D113AFDFF7CD13071A3A407B9CED5CC3"></p>
<p>Build Blocks:</p>
<ol>
<li>Array lengths: 标准建议使用 64 bytes 的 i64，但是 32 bytes (i32) 也符合标准。文章提到如果元素特别多，建议拆分成多个 i32 可以表示的数组</li>
<li>Buffer<ol>
<li>官方建议按照 64 bytes 来对齐 Buffer，这方便使用 SIMD 和开启一些 SIMD 上的优化。目前 AVX512 寄存器宽度是 512 bits。</li>
</ol>
</li>
<li>null count / Validity bitmaps: null count  表示元素是 null 的个数，是 0 的时候可以不需要 validity bitmaps。如果非 0，可能有一个 64 bytes padding 的 bitmap。bitmap 按照 LSB 定义，大于 64B 的内容</li>
</ol>
<p>具体例子可以看看下图：</p>
<p><img src="https://image.mwish.me/blog-image/83EE405A-49D0-4A4A-89E7-9BB222B2505E.png" alt="83EE405A-49D0-4A4A-89E7-9BB222B2505E"></p>
<p><img src="https://image.mwish.me/blog-image/3139E767-4789-4593-B147-B2618FE224F7.png" alt="3139E767-4789-4593-B147-B2618FE224F7"></p>
<p>需要特别注意的是一些有「嵌套」性质的结构，举例子：<code>List&lt;T&gt;</code>, <code>List&lt;List&lt;T&gt;&gt;</code>，<code>Struct</code>：</p>
<p>嵌套逻辑中，我们需要小小的关注一下「父级是 null」是怎么处理的，在 Array 中，这个靠父级别 null 来解决。在 struct 中，这个靠父级别 null — 子级别 null 来区分。可以看到，这个比 dremel 那种还是简单了很多的。</p>
<p><img src="https://image.mwish.me/blog-image/C865616E-E6CF-47FD-8440-A0F5E5EF8F47.png" alt="C865616E-E6CF-47FD-8440-A0F5E5EF8F47"></p>
<p><img src="https://image.mwish.me/blog-image/0A39F9FA-54F7-4E5A-8FBC-FAD7AB5FE42B.png" alt="0A39F9FA-54F7-4E5A-8FBC-FAD7AB5FE42B"></p>
<p>额外需要提的是字典，它们会有指向字典的逻辑：</p>
<p><img src="https://image.mwish.me/blog-image/49EB35E6-7864-49CA-B433-FB985F598909.png" alt="49EB35E6-7864-49CA-B433-FB985F598909"></p>
<h2 id="Rep-Level-and-Def-Levels"><a href="#Rep-Level-and-Def-Levels" class="headerlink" title="Rep Level and Def Levels"></a>Rep Level and Def Levels</h2><p>理论讲了还是没意思，看代码吧</p>
<p>代码入口：</p>
<p>这是一个 Level Builder，外层的使用入口在：</p>
<ol>
<li><code>ArrowColumnWriterV2::Make</code>，创建对应的 <code>MultipathLevelBuilder</code>. <code>ArrowColumnWriterV2</code> 是某个具体的列的 writer。这个地方，Writer 会分 chunk 拿到不同的 Array，构建对应的 <code>MultipathLevelBuilder</code></li>
<li><code>MultipathLevelBuilder</code> 写入会返回一个 <code>MultipathLevelBuilderResult</code>，上层根据这个拿到 <code>rep-level</code> 和 <code>def-level</code>，然后写入</li>
</ol>
<p>下面简单看一下这些接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// \brief Result for a single leaf array when running the builder on the</span></span><br><span class="line"><span class="comment">/// its root.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MultipathLevelBuilderResult</span> &#123;</span><br><span class="line">  <span class="comment">/// \brief The Array containing only the values to write (after all nesting has</span></span><br><span class="line">  <span class="comment">/// been processed.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// No additional processing is done on this array (it is copied as is when</span></span><br><span class="line">  <span class="comment">/// visited via a DFS).</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// leaf_array 是写入页面的整个 array, 即整列的数据</span></span><br><span class="line">  std::shared_ptr&lt;::arrow::Array&gt; leaf_array;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Might be null.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int16_t</span>* def_levels = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief  Might be null.</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int16_t</span>* rep_levels = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Number of items (int16_t) contained in def/rep_levels when present.</span></span><br><span class="line">  <span class="comment">/// def-level 和 rep-level 长度是一样的, 所以需要一个 level 来提示</span></span><br><span class="line">  <span class="type">int64_t</span> def_rep_level_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Contains element ranges of the required visiting on the</span></span><br><span class="line">  <span class="comment">/// descendants of the final list ancestor for any leaf node.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// The algorithm will attempt to consolidate visited ranges into</span></span><br><span class="line">  <span class="comment">/// the smallest number possible.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// This data is necessary to pass along because after producing</span></span><br><span class="line">  <span class="comment">/// def-rep levels for each leaf array it is impossible to determine</span></span><br><span class="line">  <span class="comment">/// which values have to be sent to parquet when a null list value</span></span><br><span class="line">  <span class="comment">/// in a nullable ListArray is non-empty.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// This allows for the parquet writing to determine which values ultimately</span></span><br><span class="line">  <span class="comment">/// needs to be written.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// 写入的内容在 `leaf_array` 中的范围</span></span><br><span class="line">  std::vector&lt;ElementRange&gt; post_list_visited_elements;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Whether the leaf array is nullable.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// leaf 是否是 nullable 的</span></span><br><span class="line">  <span class="type">bool</span> leaf_is_nullable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后用 <code>Write</code> 接口去走 callback，来往 writer 写入数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteColumnChunk</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;ChunkedArray&gt;&amp; data, <span class="type">int64_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int64_t</span> size)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arrow_properties_-&gt;<span class="built_in">engine_version</span>() == ArrowWriterProperties::V2 ||</span><br><span class="line">      arrow_properties_-&gt;<span class="built_in">engine_version</span>() == ArrowWriterProperties::V1) &#123;</span><br><span class="line">    <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(</span><br><span class="line">        std::unique_ptr&lt;ArrowColumnWriterV2&gt; writer,</span><br><span class="line">        ArrowColumnWriterV2::<span class="built_in">Make</span>(*data, offset, size, schema_manifest_,</span><br><span class="line">                                  row_group_writer_));</span><br><span class="line">    <span class="keyword">return</span> writer-&gt;<span class="built_in">Write</span>(&amp;column_write_context_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">NotImplemented</span>(<span class="string">&quot;Unknown engine version.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writes out all leaf parquet columns to the RowGroupWriter that this</span></span><br><span class="line"><span class="comment">// object was constructed with.  Each leaf column is written fully before</span></span><br><span class="line"><span class="comment">// the next column is written (i.e. no buffering is assumed).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Columns are written in DFS order.</span></span><br><span class="line"><span class="function">Status <span class="title">Write</span><span class="params">(ArrowWriteContext* ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> leaf_idx = <span class="number">0</span>; leaf_idx &lt; leaf_count_; leaf_idx++) &#123;</span><br><span class="line">    ColumnWriter* column_writer;</span><br><span class="line">    <span class="built_in">PARQUET_CATCH_NOT_OK</span>(column_writer = row_group_writer_-&gt;<span class="built_in">NextColumn</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; level_builder : level_builders_) &#123;</span><br><span class="line">      <span class="built_in">RETURN_NOT_OK</span>(level_builder-&gt;<span class="built_in">Write</span>(</span><br><span class="line">          leaf_idx, ctx, [&amp;](<span class="type">const</span> MultipathLevelBuilderResult&amp; result) &#123;</span><br><span class="line">            <span class="type">size_t</span> visited_component_size = result.post_list_visited_elements.<span class="built_in">size</span>();</span><br><span class="line">            <span class="built_in">DCHECK_GT</span>(visited_component_size, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (visited_component_size != <span class="number">1</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> Status::<span class="built_in">NotImplemented</span>(</span><br><span class="line">                  <span class="string">&quot;Lists with non-zero length null components are not supported&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">const</span> ElementRange&amp; range = result.post_list_visited_elements[<span class="number">0</span>];</span><br><span class="line">            std::shared_ptr&lt;Array&gt; values_array =</span><br><span class="line">                result.leaf_array-&gt;<span class="built_in">Slice</span>(range.start, range.<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> column_writer-&gt;<span class="built_in">WriteArrow</span>(result.def_levels, result.rep_levels,</span><br><span class="line">                                             result.def_rep_level_count, *values_array,</span><br><span class="line">                                             ctx, result.leaf_is_nullable);</span><br><span class="line">          &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PARQUET_CATCH_NOT_OK</span>(column_writer-&gt;<span class="built_in">Close</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这里走了 <code>MultipathLevelBuilder::Write</code>，然后里面走了回调，回调函数的参数就是之前提到的 <code>MultipathLevelBuilderResult</code>。这个函数给没有 rep-level 和 def-level 的输入加上了这两个 level，之后 <code>ColumnWriter</code> 就可以拿到 def-level, rep-level 和值去写了。那么，这里的关键应该就是 rep-level 和 def-level 是怎么构建的了。</p>
<p>这部分关键的内容在 <code>parquet/arrow/path_internal.cc</code> 下面。我们简单介绍一下对应的算法：</p>
<ol>
<li>输入是对应的 arrow Array 和相关的 schema</li>
<li>dfs 的方式推断出，「这个地方最大的 def-level 是什么，rep-level 是什么」</li>
<li>拿到用户的输入 array，进行计算</li>
</ol>
<p>在步骤 (2)，arrow 会根据输入数据构建出树，有两种节点：</p>
<ol>
<li>ListNode / StructNode / MapNode: 有子节点且非终止的节点</li>
<li>TerminalNode: 终止的节点。这里包括 <code>AllNullsTerminalNode</code>(所有成员都是 null）、<code>AllPresentTerminalNode</code>（全都有，且父级别没有 null 的节点），<code>NullableTerminalNode</code> 可能有 null 但不去为 null</li>
</ol>
<p>一般来说，可以理解 <code>TerminalNode</code> 为叶子结点，而其它节点为非叶子结点，但是也有一些特殊情况，比如父级就发现全部是 null 了，这里也可能是个 <code>TerminalNode</code>。</p>
<p>每个 <code>Node</code> 有一个 <code>Run</code> 方法，作为 (3) 需要的函数，但是参数并不相同，Node 之间也不是继承关系，而是组合关系，由 <code>variant</code> 包装：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Contains static information derived from traversing the schema.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PathInfo</span> &#123;</span><br><span class="line">  <span class="comment">// The vectors are expected to the same length info.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note index order matters here.</span></span><br><span class="line">  <span class="keyword">using</span> Node =</span><br><span class="line">      std::variant&lt;NullableTerminalNode, ListNode, LargeListNode, FixedSizeListNode,</span><br><span class="line">                   NullableNode, AllPresentTerminalNode, AllNullsTerminalNode&gt;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Node&gt; path;</span><br><span class="line">  std::shared_ptr&lt;Array&gt; primitive_array;</span><br><span class="line">  <span class="type">int16_t</span> max_def_level = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int16_t</span> max_rep_level = <span class="number">0</span>;</span><br><span class="line">  <span class="type">bool</span> has_dictionary = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> leaf_is_nullable = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看看上面的 <code>PathInfo</code>，这里的目标就是构建一个这样的 <code>PathInfo</code>.</p>
<h3 id="PathBuilder-构建-Node-阶段"><a href="#PathBuilder-构建-Node-阶段" class="headerlink" title="PathBuilder: 构建 Node 阶段"></a>PathBuilder: 构建 Node 阶段</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">::arrow::Result&lt;std::unique_ptr&lt;MultipathLevelBuilder&gt;&gt; MultipathLevelBuilder::<span class="built_in">Make</span>(</span><br><span class="line">    <span class="type">const</span> ::arrow::Array&amp; array, <span class="type">bool</span> array_field_nullable) &#123;</span><br><span class="line">  <span class="keyword">auto</span> constructor = std::<span class="built_in">make_unique</span>&lt;PathBuilder&gt;(array_field_nullable);</span><br><span class="line">  <span class="comment">// 递归分发给 PathBuilder 访问 arrow array, 捞到对应的 schema. 这里 leaf count 可能不止 1.</span></span><br><span class="line">  <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">VisitArrayInline</span>(array, constructor.<span class="built_in">get</span>()));</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;MultipathLevelBuilderImpl&gt;(array.<span class="built_in">data</span>(),</span><br><span class="line">                                                     std::<span class="built_in">move</span>(constructor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，这里创建了一个 <code>PathBuilder</code>，然后访问了 <code>VisitArrayInline</code>，这里相当于自己定义了一个访问 array 的方法</p>
<p><code>PathBuilder</code> 提供了 <code>Visit(不同的 Array)</code> 的方法，能够完成动态分发。不过进入具体访问方式前，先来看看它的成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PathBuilder</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PathBuilder</span><span class="params">(<span class="type">bool</span> start_nullable)</span> : nullable_in_parent_(start_nullable) &#123;</span>&#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  PathInfo info_;</span><br><span class="line">  std::vector&lt;PathInfo&gt; paths_;</span><br><span class="line">  <span class="type">bool</span> nullable_in_parent_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>nullable_in_parent_</code> 这个是表示，任何父亲的这个字段是否可能是 null。在代码里，丢给 PathBuilder 这玩意是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> nullable_root = <span class="built_in">HasNullableRoot</span>(schema_manifest, schema_field);</span><br><span class="line"><span class="keyword">if</span> (leaf_offset == <span class="number">0</span>) &#123;</span><br><span class="line">  is_nullable = nullable_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个看上去是 <code>HasNullableRoot</code>，但是丢给 path 的一般都是 root 的直接儿子，所以这里表示的就是 <code>parent</code> 的这个字段可能不可能是 null。</p>
<h4 id="处理父级别-null"><a href="#处理父级别-null" class="headerlink" title="处理父级别 null"></a>处理父级别 null</h4><p>有一个很常见的函数是 <code>MaybeAddNullable</code>，我们来看看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加对应的 def-level,</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaybeAddNullable</span><span class="params">(<span class="type">const</span> Array&amp; array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!nullable_in_parent_) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  info_.max_def_level++;</span><br><span class="line">  <span class="comment">// We don&#x27;t use null_count() because if the null_count isn&#x27;t known</span></span><br><span class="line">  <span class="comment">// and the array does in fact contain nulls, we will end up</span></span><br><span class="line">  <span class="comment">// traversing the null bitmap twice (once here and once when calculating</span></span><br><span class="line">  <span class="comment">// rep/def levels). Because this isn&#x27;t terminal this might not be</span></span><br><span class="line">  <span class="comment">// the right decision for structs that share the same nullable</span></span><br><span class="line">  <span class="comment">// parents.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">LazyNoNulls</span>(array)) &#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t add anything because there won&#x27;t be any point checking</span></span><br><span class="line">    <span class="comment">// null values for the array.  There will always be at least</span></span><br><span class="line">    <span class="comment">// one more array to handle nullability.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 反正都没了，不如 terminal 了</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">LazyNullCount</span>(array) == array.<span class="built_in">length</span>()) &#123;</span><br><span class="line">    info_.path.<span class="built_in">emplace_back</span>(<span class="built_in">AllNullsTerminalNode</span>(info_.max_def_level - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  info_.path.<span class="built_in">emplace_back</span>(</span><br><span class="line">      <span class="built_in">NullableNode</span>(array.<span class="built_in">null_bitmap_data</span>(), array.<span class="built_in">offset</span>(),</span><br><span class="line">                   <span class="comment">/* def_level_if_null = */</span> info_.max_def_level - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里如果是父级 null，就会增加 <code>max_def_level</code>，然后添加对应的节点项。</p>
<h4 id="访问-struct"><a href="#访问-struct" class="headerlink" title="访问 struct"></a>访问 struct</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Visit</span><span class="params">(<span class="type">const</span> ::arrow::StructArray&amp; array)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">MaybeAddNullable</span>(array);</span><br><span class="line">  PathInfo info_backup = info_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; array.<span class="built_in">num_fields</span>(); x++) &#123;</span><br><span class="line">    nullable_in_parent_ = array.<span class="built_in">type</span>()-&gt;<span class="built_in">field</span>(x)-&gt;<span class="built_in">nullable</span>();</span><br><span class="line">    <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">VisitInline</span>(*array.<span class="built_in">field</span>(x)));</span><br><span class="line">    info_ = info_backup;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里代码应该非常好理解，就是递归访问。</p>
<h4 id="访问-ListArray"><a href="#访问-ListArray" class="headerlink" title="访问 ListArray"></a>访问 ListArray</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">::arrow::<span class="type">enable_if_t</span>&lt;std::is_same&lt;::arrow::ListArray, T&gt;::value ||</span><br><span class="line">                         std::is_same&lt;::arrow::LargeListArray, T&gt;::value,</span><br><span class="line">                     Status&gt;</span><br><span class="line"><span class="built_in">Visit</span>(<span class="type">const</span> T&amp; array) &#123;</span><br><span class="line">  <span class="comment">// 处理父级别带来的 def, 和自身场景</span></span><br><span class="line">  <span class="comment">// 对于 parquet 的 list, 这里相当于两组标记:</span></span><br><span class="line">  <span class="comment">// List &#123;</span></span><br><span class="line">  <span class="comment">//   repeatable member</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// 这两层都是 rep/def 哦～</span></span><br><span class="line">  <span class="built_in">MaybeAddNullable</span>(array);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Increment necessary due to empty lists.</span></span><br><span class="line">  info_.max_def_level++;</span><br><span class="line">  info_.max_rep_level++;</span><br><span class="line">  <span class="comment">// raw_value_offsets() accounts for any slice offset.</span></span><br><span class="line">  ListPathNode&lt;VarRangeSelector&lt;<span class="keyword">typename</span> T::offset_type&gt;&gt; <span class="built_in">node</span>(</span><br><span class="line">      VarRangeSelector&lt;<span class="keyword">typename</span> T::offset_type&gt;&#123;array.<span class="built_in">raw_value_offsets</span>()&#125;,</span><br><span class="line">      info_.max_rep_level, info_.max_def_level - <span class="number">1</span>);</span><br><span class="line">  info_.path.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(node));</span><br><span class="line">  nullable_in_parent_ = array.<span class="built_in">list_type</span>()-&gt;<span class="built_in">value_field</span>()-&gt;<span class="built_in">nullable</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">VisitInline</span>(*array.<span class="built_in">values</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>max_rep_level</code> 和 <code>max_def_level - 1</code> 得回顾一下上一篇博客了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RangeSelector&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListPathNode</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ListPathNode</span>(RangeSelector selector, <span class="type">int16_t</span> rep_lev, <span class="type">int16_t</span> def_level_if_empty)</span><br><span class="line">      : <span class="built_in">selector_</span>(std::<span class="built_in">move</span>(selector)),</span><br><span class="line">        <span class="built_in">prev_rep_level_</span>(rep_lev - <span class="number">1</span>),</span><br><span class="line">        <span class="built_in">rep_level_</span>(rep_lev),</span><br><span class="line">        <span class="built_in">def_level_if_empty_</span>(def_level_if_empty) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>VarRangeSelector</code> 则持有了 array 元素的 offsets，还记得前面的 <code>ListArray</code> 的图吗？</p>
<h4 id="访问叶子结点"><a href="#访问叶子结点" class="headerlink" title="访问叶子结点"></a>访问叶子结点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 是平坦的 array, 可以当作找到了某个叶子.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">::arrow::<span class="type">enable_if_t</span>&lt;std::is_base_of&lt;::arrow::FlatArray, T&gt;::value, Status&gt; <span class="built_in">Visit</span>(</span><br><span class="line">    <span class="type">const</span> T&amp; array) &#123;</span><br><span class="line">  <span class="comment">// 在叶子层面加上 terminal info.</span></span><br><span class="line">  <span class="built_in">AddTerminalInfo</span>(array);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的重点是 <code>AddTerminalInfo</code>，添加了对应的 <code>TerminalNode</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddTerminalInfo</span><span class="params">(<span class="type">const</span> T&amp; array)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里, leaf_is_nullable 经由 parent 实现, 表示「父级别的这个字段可能是 nullable」的。</span></span><br><span class="line">  info_.leaf_is_nullable = nullable_in_parent_;</span><br><span class="line">  <span class="keyword">if</span> (nullable_in_parent_) &#123;</span><br><span class="line">    info_.max_def_level++; <span class="comment">// (加上)这一层的 def-level</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意: rep-level 在底层是不会处理的，都是上层处理的。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// We don&#x27;t use null_count() because if the null_count isn&#x27;t known</span></span><br><span class="line">  <span class="comment">// and the array does in fact contain nulls, we will end up</span></span><br><span class="line">  <span class="comment">// traversing the null bitmap twice (once here and once when calculating</span></span><br><span class="line">  <span class="comment">// rep/def levels).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 处理: 没有 null, 都是 null, 可以为 null 的 case. 把这个加入 info_.path 中.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">LazyNoNulls</span>(array)) &#123;</span><br><span class="line">    info_.path.<span class="built_in">emplace_back</span>(AllPresentTerminalNode&#123;info_.max_def_level&#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">LazyNullCount</span>(array) == array.<span class="built_in">length</span>()) &#123;</span><br><span class="line">    info_.path.<span class="built_in">emplace_back</span>(<span class="built_in">AllNullsTerminalNode</span>(info_.max_def_level - <span class="number">1</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    info_.path.<span class="built_in">emplace_back</span>(<span class="built_in">NullableTerminalNode</span>(array.<span class="built_in">null_bitmap_data</span>(),</span><br><span class="line">                                                 array.<span class="built_in">offset</span>(), info_.max_def_level));</span><br><span class="line">  &#125;</span><br><span class="line">  info_.primitive_array = std::<span class="built_in">make_shared</span>&lt;T&gt;(array.<span class="built_in">data</span>());</span><br><span class="line">  <span class="comment">// 真正处理这个 dfs path, 把 fixup 的结果加入 paths. 这里面会处理 rep-level.</span></span><br><span class="line">  paths_.<span class="built_in">push_back</span>(<span class="built_in">Fixup</span>(info_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>Fixup</code> 是处理 rep-level 的函数，我们再看看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FIXUP 会处理 rep-level.</span></span><br><span class="line"><span class="function">PathInfo <span class="title">Fixup</span><span class="params">(PathInfo info)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We only need to fixup the path if there were repeated</span></span><br><span class="line">  <span class="comment">// elements on it.</span></span><br><span class="line">  <span class="keyword">if</span> (info.max_rep_level == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">  &#125;</span><br><span class="line">  FixupVisitor visitor;</span><br><span class="line">  visitor.max_rep_level = info.max_rep_level;</span><br><span class="line">  <span class="keyword">if</span> (visitor.max_rep_level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    visitor.rep_level_if_null = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从 0-最后的顺序访问, 变更 visitor, 这个地方会把最上层的 rep-level 带下来.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> x = <span class="number">0</span>; x &lt; info.path.<span class="built_in">size</span>(); x++) &#123;</span><br><span class="line">    std::<span class="built_in">visit</span>(visitor, info.path[x]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FixupVisitor</span> &#123;</span><br><span class="line">  <span class="type">int</span> max_rep_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int16_t</span> rep_level_if_null = kLevelNotSet; <span class="comment">// (第一个) 为 null 的时候, 需要处理 rep-level 的.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遇到了中间的会找到 rep-level</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">HandleListNode</span><span class="params">(T&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg.<span class="built_in">rep_level</span>() == max_rep_level) &#123;</span><br><span class="line">      arg.<span class="built_in">SetLast</span>();</span><br><span class="line">      <span class="comment">// after the last list node we don&#x27;t need to fill</span></span><br><span class="line">      <span class="comment">// rep levels on null.</span></span><br><span class="line">      rep_level_if_null = kLevelNotSet;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rep_level_if_null = arg.<span class="built_in">rep_level</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode&amp; node)</span> </span>&#123; <span class="built_in">HandleListNode</span>(node); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(LargeListNode&amp; node)</span> </span>&#123; <span class="built_in">HandleListNode</span>(node); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FixedSizeListNode&amp; node)</span> </span>&#123; <span class="built_in">HandleListNode</span>(node); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For non-list intermediate nodes.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">HandleIntermediateNode</span><span class="params">(T&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rep_level_if_null != kLevelNotSet) &#123;</span><br><span class="line">      <span class="comment">// 只有 AllNullsTerminalNode 和 NullableTerminalNode 可能有这个</span></span><br><span class="line">      arg.<span class="built_in">SetRepLevelIfNull</span>(rep_level_if_null); <span class="comment">// 如果这层是空的时候，rep-level 是什么，就是找到一个父级的 rep-level</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(NullableNode&amp; arg)</span> </span>&#123; <span class="built_in">HandleIntermediateNode</span>(arg); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(AllNullsTerminalNode&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Even though no processing happens past this point we</span></span><br><span class="line">    <span class="comment">// still need to adjust it if a list occurred after an</span></span><br><span class="line">    <span class="comment">// all null array.</span></span><br><span class="line">    <span class="built_in">HandleIntermediateNode</span>(arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(NullableTerminalNode&amp;)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(AllPresentTerminalNode&amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个 <code>visitor</code> 会把 <code>rep-level-if-null</code> 给带下去。</p>
<h3 id="Write-阶段"><a href="#Write-阶段" class="headerlink" title="Write 阶段"></a>Write 阶段</h3><p>Write 阶段核心函数在 WritePath 上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">::<span class="function">arrow::Status <span class="title">Write</span><span class="params">(<span class="type">int</span> leaf_index, ArrowWriteContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">                      CallbackFunction write_leaf_callback)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_GE</span>(leaf_index, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">DCHECK_LT</span>(leaf_index, <span class="built_in">GetLeafCount</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">WritePath</span>(root_range_, &amp;path_builder_-&gt;<span class="built_in">paths</span>()[leaf_index], context,</span><br><span class="line">                   std::<span class="built_in">move</span>(write_leaf_callback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WritePath</code> 比较复杂，我们看之前先介绍一下算法：</p>
<h4 id="WritePath-的算法"><a href="#WritePath-的算法" class="headerlink" title="WritePath 的算法"></a>WritePath 的算法</h4><p>现在我们有了一组 node 栈，然后我们假设一个场景：<code>List&lt;List&lt;int&gt;&gt;</code> 和 <code>[[1, 2, null], null, [], [null, 1, 2]]</code>。这个本身不难，但是这个 def 和 rep 都是会变动的. 这个在 arrow 中大概会被实现成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListArray: [[]], valid bitmap, offsets</span><br><span class="line">  ListArray: [], valid bitmap, offsets</span><br><span class="line">     IntArray: buffer, valid bitmap, offsets</span><br></pre></td></tr></table></figure>
<p>这里会构造一个 range 栈，大概是这样的：</p>
<ol>
<li>拿到根结点</li>
<li>Nullable -&gt; List -&gt; Nullable -&gt; List -&gt; Int ，写入 1，2，null 和对应的 rep-level , def-level</li>
<li>回溯到上层，发现成员是 null，写入一个对应的 rep-level , def-level</li>
<li>发现栈有元素，到下层继续写入</li>
</ol>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>这里需要介绍 <code>Iterator</code> 类型，每一层会有一个 <code>Run</code>，拿到对应的范围。有可能：</p>
<ol>
<li><code>kDone</code> 做完了，应该向上层走</li>
<li><code>kNext</code> 应该走进下一层</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// \brief Simple result of a iterating over a column to determine values.</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IterationResult</span> &#123;</span><br><span class="line">  <span class="comment">/// Processing is done at this node. Move back up the path</span></span><br><span class="line">  <span class="comment">/// to continue processing.</span></span><br><span class="line">  kDone = <span class="number">-1</span>,</span><br><span class="line">  <span class="comment">/// Move down towards the leaf for processing.</span></span><br><span class="line">  kNext = <span class="number">1</span>,</span><br><span class="line">  <span class="comment">/// An error occurred while processing.</span></span><br><span class="line">  kError = <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们以 nullable 为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IterationResult <span class="title">Run</span><span class="params">(ElementRange* range, ElementRange* child_range,</span></span></span><br><span class="line"><span class="params"><span class="function">                    PathWriteContext* context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (new_range_) &#123;</span><br><span class="line">    <span class="comment">// Reset the reader each time we are starting fresh on a range.</span></span><br><span class="line">    <span class="comment">// We can&#x27;t rely on continuity because nulls above can</span></span><br><span class="line">    <span class="comment">// cause discontinuities.</span></span><br><span class="line">    valid_bits_reader_ = <span class="built_in">MakeReader</span>(*range);</span><br><span class="line">  &#125;</span><br><span class="line">  child_range-&gt;start = range-&gt;start;</span><br><span class="line">  ::arrow::internal::BitRun run = valid_bits_reader_.<span class="built_in">NextRun</span>();</span><br><span class="line">  <span class="keyword">if</span> (!run.set) &#123;</span><br><span class="line">    range-&gt;start += run.length;</span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(<span class="built_in">FillRepLevels</span>(run.length, rep_level_if_null_, context));</span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(context-&gt;<span class="built_in">AppendDefLevels</span>(run.length, def_level_if_null_));</span><br><span class="line">    run = valid_bits_reader_.<span class="built_in">NextRun</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (range-&gt;<span class="built_in">Empty</span>()) &#123;</span><br><span class="line">    new_range_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> kDone;</span><br><span class="line">  &#125;</span><br><span class="line">  child_range-&gt;end = child_range-&gt;start = range-&gt;start;</span><br><span class="line">  child_range-&gt;end += run.length;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK</span>(!child_range-&gt;<span class="built_in">Empty</span>());</span><br><span class="line">  range-&gt;start += child_range-&gt;<span class="built_in">Size</span>();</span><br><span class="line">  new_range_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> kNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会按情况添加 level，然后返回上一层或者暗示后面还有，走向下一层，这些 node 都是 <strong>有状态的</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Contains logic for writing a single leaf node to parquet.</span></span><br><span class="line"><span class="comment">/// This tracks the path from root to leaf.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// |writer| will be called after all of the definition/repetition</span></span><br><span class="line"><span class="comment">/// values have been calculated for root_range with the calculated</span></span><br><span class="line"><span class="comment">/// values. It is intended to abstract the complexity of writing</span></span><br><span class="line"><span class="comment">/// the levels and values to parquet.</span></span><br><span class="line"><span class="function">Status <span class="title">WritePath</span><span class="params">(ElementRange root_range, PathInfo* path_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                 ArrowWriteContext* arrow_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                 MultipathLevelBuilder::CallbackFunction writer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 栈表示为 range 栈</span></span><br><span class="line">  <span class="function">std::vector&lt;ElementRange&gt; <span class="title">stack</span><span class="params">(path_info-&gt;path.size())</span></span>;</span><br><span class="line">  MultipathLevelBuilderResult builder_result;</span><br><span class="line">  builder_result.leaf_array = path_info-&gt;primitive_array;</span><br><span class="line">  builder_result.leaf_is_nullable = path_info-&gt;leaf_is_nullable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不需要处理递归、特殊场景，嗯写就是了</span></span><br><span class="line">  <span class="keyword">if</span> (path_info-&gt;max_def_level == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// This case only occurs when there are no nullable or repeated</span></span><br><span class="line">    <span class="comment">// columns in the path from the root to leaf.</span></span><br><span class="line">    <span class="type">int64_t</span> leaf_length = builder_result.leaf_array-&gt;<span class="built_in">length</span>();</span><br><span class="line">    builder_result.def_rep_level_count = leaf_length;</span><br><span class="line">    builder_result.post_list_visited_elements.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, leaf_length&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">writer</span>(builder_result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// root_range 为行的 offset, 是最外层的 range</span></span><br><span class="line">  stack[<span class="number">0</span>] = root_range;</span><br><span class="line">  <span class="built_in">RETURN_NOT_OK</span>(</span><br><span class="line">      arrow_context-&gt;def_levels_buffer-&gt;<span class="built_in">Resize</span>(<span class="comment">/*new_size=*/</span><span class="number">0</span>, <span class="comment">/*shrink_to_fit*/</span> <span class="literal">false</span>));</span><br><span class="line">  <span class="function">PathWriteContext <span class="title">context</span><span class="params">(arrow_context-&gt;memory_pool, arrow_context-&gt;def_levels_buffer)</span></span>;</span><br><span class="line">  <span class="comment">// We should need at least this many entries so reserve the space ahead of time.</span></span><br><span class="line">  <span class="built_in">RETURN_NOT_OK</span>(context.def_levels.<span class="built_in">Reserve</span>(root_range.<span class="built_in">Size</span>()));</span><br><span class="line">  <span class="keyword">if</span> (path_info-&gt;max_rep_level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">RETURN_NOT_OK</span>(context.rep_levels.<span class="built_in">Reserve</span>(root_range.<span class="built_in">Size</span>()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> stack_base = &amp;stack[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">auto</span> stack_position = stack_base;</span><br><span class="line">  <span class="comment">// This is the main loop for calculated rep/def levels. The nodes</span></span><br><span class="line">  <span class="comment">// in the path implement a chain-of-responsibility like pattern</span></span><br><span class="line">  <span class="comment">// where each node can add some number of repetition/definition</span></span><br><span class="line">  <span class="comment">// levels to PathWriteContext and also delegate to the next node</span></span><br><span class="line">  <span class="comment">// in the path to add values. The values are added through each Run(...)</span></span><br><span class="line">  <span class="comment">// call and the choice to delegate to the next node (or return to the</span></span><br><span class="line">  <span class="comment">// previous node) is communicated by the return value of Run(...).</span></span><br><span class="line">  <span class="comment">// The loop terminates after the first node indicates all values in</span></span><br><span class="line">  <span class="comment">// |root_range| are processed.</span></span><br><span class="line">  <span class="keyword">while</span> (stack_position &gt;= stack_base) &#123;</span><br><span class="line">    PathInfo::Node&amp; node = path_info-&gt;path[stack_position - stack_base];</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      <span class="function">IterationResult <span class="title">operator</span><span class="params">()</span><span class="params">(NullableNode&amp; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="built_in">Run</span>(stack_position, stack_position + <span class="number">1</span>, context);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">IterationResult <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode&amp; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="built_in">Run</span>(stack_position, stack_position + <span class="number">1</span>, context);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">IterationResult <span class="title">operator</span><span class="params">()</span><span class="params">(NullableTerminalNode&amp; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="built_in">Run</span>(*stack_position, context);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">IterationResult <span class="title">operator</span><span class="params">()</span><span class="params">(FixedSizeListNode&amp; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="built_in">Run</span>(stack_position, stack_position + <span class="number">1</span>, context);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">IterationResult <span class="title">operator</span><span class="params">()</span><span class="params">(AllPresentTerminalNode&amp; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="built_in">Run</span>(*stack_position, context);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">IterationResult <span class="title">operator</span><span class="params">()</span><span class="params">(AllNullsTerminalNode&amp; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="built_in">Run</span>(*stack_position, context);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">IterationResult <span class="title">operator</span><span class="params">()</span><span class="params">(LargeListNode&amp; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.<span class="built_in">Run</span>(stack_position, stack_position + <span class="number">1</span>, context);</span><br><span class="line">      &#125;</span><br><span class="line">      ElementRange* stack_position;</span><br><span class="line">      PathWriteContext* context;</span><br><span class="line">    &#125; visitor = &#123;stack_position, &amp;context&#125;;</span><br><span class="line"></span><br><span class="line">    IterationResult result = std::<span class="built_in">visit</span>(visitor, node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ARROW_PREDICT_FALSE</span>(result == kError)) &#123;</span><br><span class="line">      <span class="built_in">DCHECK</span>(!context.last_status.<span class="built_in">ok</span>());</span><br><span class="line">      <span class="keyword">return</span> context.last_status;</span><br><span class="line">    &#125;</span><br><span class="line">    stack_position += <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">RETURN_NOT_OK</span>(context.last_status);</span><br><span class="line">  builder_result.def_rep_level_count = context.def_levels.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (context.rep_levels.<span class="built_in">length</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// This case only occurs when there was a repeated element that needs to be</span></span><br><span class="line">    <span class="comment">// processed.</span></span><br><span class="line">    builder_result.rep_levels = context.rep_levels.<span class="built_in">data</span>();</span><br><span class="line">    std::<span class="built_in">swap</span>(builder_result.post_list_visited_elements, context.visited_elements);</span><br><span class="line">    <span class="comment">// If it is possible when processing lists that all lists where empty. In this</span></span><br><span class="line">    <span class="comment">// case no elements would have been added to post_list_visited_elements. By</span></span><br><span class="line">    <span class="comment">// added an empty element we avoid special casing in downstream consumers.</span></span><br><span class="line">    <span class="keyword">if</span> (builder_result.post_list_visited_elements.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      builder_result.post_list_visited_elements.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    builder_result.post_list_visited_elements.<span class="built_in">push_back</span>(</span><br><span class="line">        &#123;<span class="number">0</span>, builder_result.leaf_array-&gt;<span class="built_in">length</span>()&#125;);</span><br><span class="line">    builder_result.rep_levels = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  builder_result.def_levels = context.def_levels.<span class="built_in">data</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">writer</span>(builder_result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Samples-for-write"><a href="#Samples-for-write" class="headerlink" title="Samples for write"></a>Samples for write</h2><p>总觉得我写的还是比较抽象的，所以这里尝试举几个例子，来简单介绍一下，因为之前写入的过于抽象了。</p>
<p>我们回顾一下：</p>
<ol>
<li><code>PathBuilder</code> 会根据用户的 Schema 来构建 node，这些 node 有不同的 max-rep-level 和 max-def-level，也有空缺的时候应该写入的 def-level。这里会构成一个栈</li>
<li>传递数据下来的时候，连续的数据会找到对应的栈，写对应的 def-level 和 rep-level</li>
</ol>
<p>我们下面列举的例子都是写入 1024 行数据的，我们会从简单到难来介绍写入 case 的例子</p>
<h3 id="Case-1-i32"><a href="#Case-1-i32" class="headerlink" title="Case 1: i32"></a>Case 1: i32</h3><p>我们假设有连续的 i32, 它不是 nullable 的，这个时候，arrow 对应的结构是 Fixed 的 int32 数组，没有任何 valid bitmap。</p>
<p>这个时候，<code>PathBuilder</code>在构建阶段 会构建一个下面的节点：</p>
<p><img src="https://image.mwish.me/blog-image/parquet-c1.jpg" alt="流程图 (1)"></p>
<p>在构建阶段，程序会找到这个 node，然后设置迭代的 <code>range = [0, 1024)</code>，然后遍历这个栈…</p>
<p>不，其实它不会遍历这个栈！还记得之前吗？如果字段是 <code>optional</code>，那么 max-dep + 1，如果是 <code>repeatable</code>, 那么 max-dep + 1, max-rep + 1。也就是说，程序如果检查到 <code>max-dep == 0</code>，那么说明对象都是一对一且无 null 的，这个地方就直接写入所有值了！</p>
<h3 id="Case-2-optional-i32"><a href="#Case-2-optional-i32" class="headerlink" title="Case 2: optional i32"></a>Case 2: optional i32</h3><p>我们假设有连续的 optional i32，这个时候，arrow 对应的结构是 Fixed 的 int32 数组，没有任何 valid bitmap。</p>
<p>这个时候，<code>PathBuilder</code>在构建阶段 会构建一个下面的节点：</p>
<p><img src="https://image.mwish.me/blog-image/parquet-c2.jpg" alt="流程图 (2)"></p>
<p>在构建阶段，程序会找到这个 node，然后设置迭代的 <code>range = [0, 1024)</code>，然后遍历这个栈，把 <code>[0, 1024)</code> 传给 node，这里访问 validation bitset，如果有元素，就在 def-levels 里面加入 1，否则加入 0。栈只有一层，一次解决 0-1024 所有元素。这里不存在任何 rep-level。</p>
<p>特殊情况下，如果发现数据全是 Null，会构建一个特殊的节点：</p>
<p><img src="https://image.mwish.me/blog-image/parquet-c2-1.jpg" alt="parquet-c2-1"></p>
<p>这里会写入全是 0 的 def-level，然后不写入任何 rep.</p>
<h3 id="Case-3-array-lt-i32-4-gt"><a href="#Case-3-array-lt-i32-4-gt" class="headerlink" title="Case 3: array&lt;i32, 4&gt;"></a>Case 3: <code>array&lt;i32, 4&gt;</code></h3><p>我们假设 <code>list</code> 不是 nullable 的，这个时候会怎么写入呢？我们假设可以有这样的成员：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]</span><br></pre></td></tr></table></figure>
<p>这个对应 arrow 中的 <code>FixedSizeListArray</code>，对应内容如下：</p>
<p><img src="https://image.mwish.me/blog-image/parquet-c3-0.jpg" alt="parquet-c3-0"></p>
<p>这是一个最简化的模型了，实际上可能会复杂很多，我们先不管。这里输入是 <code>range = [0, 3)</code>，然后数组对应是 <code>Int32Array = [0, 1, 2, 3, 4, 5, ... 11]</code></p>
<ol>
<li>第一层栈对应范围是 <code>[0, 3)</code></li>
<li>第一层栈找到第一个 <strong>非空</strong> 的，是第 0 个，这个时候，如果是第一次访问（开一个新列表），很显然，rep-level 会来自自己的父级。第一个元素写入 <code>prev-rep-level</code>，即 0.<ol>
<li>因为这个节点是 <code>last_list_node</code>，所以它会向后找到第一个非 empty 的 node，会在 <code>FillForLast</code> 函数找到所有对应的内容，把 rep-level 填充完毕，每遇到非空的内容，都给四个填充 <code>[0, 1, 1, 1]</code> 等。为什么是 <code>[0, 1, 1, 1]</code> 呢？第一个元素需要填充 <code>prev-rep-level</code>，其次要填充 <code>rep-level</code></li>
</ol>
</li>
<li>完毕后，这里要把 <code>[0, 3)</code> 转化为下层需要的范围，<code>FixSizeListNode</code> 对应每个子元素 size 都是 <code>4</code>，所以这里会拿到 <code>[0, 12)</code> ，作为对应的 range</li>
<li>栈开始处理 <code>AllPresentTerminalNode</code>，丢给下面的范围是 <code>[0, 12)</code>，这里都不是 null 的，就会写入具体的内容，写完具体 12 个值和对应的 def-level，即 12个 1</li>
</ol>
<p>我们回过头看下 (2)，这里：</p>
<ol>
<li>一旦新开了一个 list，一定写一个自己的 rep-level</li>
<li>如果 list 是最后一个 list ( 最后可能带来 rep-level 的地方)，它会负责写所有儿子的 rep-level</li>
</ol>
<p><strong>还有，非空 和 非 null 是不同的概念，null 会有别的地方来处理，我们之后会介绍。</strong></p>
<h4 id="Case-3-1-array-lt-optional-i32-4-gt"><a href="#Case-3-1-array-lt-optional-i32-4-gt" class="headerlink" title="Case 3-1: array&lt;optional i32, 4&gt;"></a>Case 3-1: <code>array&lt;optional i32, 4&gt;</code></h4><p>我们假设可以有这样的成员：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[0, null, 2, 3], [4, null, 6, 7], [8, null, 10, 11]]</span><br></pre></td></tr></table></figure>
<p>这下我们需要改变我们的树了！</p>
<p><img src="https://image.mwish.me/blog-image/parquet-c3-1.jpg" alt="parquet-c3-1"></p>
<p>这里 1-3 步和之前一样，4会根据节点写出自己对应的 def-level 是 1 还是 2. 类似 case 2 的场景</p>
<h3 id="Case-List-lt-int32-gt"><a href="#Case-List-lt-int32-gt" class="headerlink" title="Case: List&lt;int32&gt;"></a>Case: <code>List&lt;int32&gt;</code></h3><p>我们前面介绍了 <code>array&lt;T, 4&gt;</code>，我在画图的时候，把 node 当作 Fixed Sized 的 List，那么实际的 <code>List</code> 或者 <code>repeated</code> 会是什么样的呢？</p>
<p>这里我们可以看看对应的类型系统：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List nodes handle populating rep_level for Arrow Lists and def-level for empty lists.</span></span><br><span class="line"><span class="comment">// Nullability (both list and children) is handled by other Nodes. By</span></span><br><span class="line"><span class="comment">// construction all list nodes will be intermediate nodes (they will always be followed by</span></span><br><span class="line"><span class="comment">// at least one other node).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Type parameters:</span></span><br><span class="line"><span class="comment">//    |RangeSelector| - A strategy for determine the the range of the child node to</span></span><br><span class="line"><span class="comment">//    process.</span></span><br><span class="line"><span class="comment">//       this varies depending on the type of list (int32_t* offsets, int64_t* offsets of</span></span><br><span class="line"><span class="comment">//       fixed.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RangeSelector&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListPathNode</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ListNode = ListPathNode&lt;VarRangeSelector&lt;<span class="type">int32_t</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">using</span> LargeListNode = ListPathNode&lt;VarRangeSelector&lt;<span class="type">int64_t</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">using</span> FixedSizeListNode = ListPathNode&lt;FixedSizedRangeSelector&gt;;</span><br></pre></td></tr></table></figure>
<p>这部分实现实际上和 Parquet 关系不大，Parquet 只会知道你是 repeated，这部分是 arrow 的逻辑，回顾一下上面的图：</p>
<ol>
<li>Fixed Sized 会在元信息里面存放自己的 size</li>
<li>非 fix sized 会有个 offset 数组，用这个 offset 数组来推断自己的 size</li>
</ol>
<p>那么，我们回顾 3 的 case，看看 List 会怎么样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[0, null, 2], [], [8, null, 10, 11]]</span><br></pre></td></tr></table></figure>
<p>这里会捞到 <code>[0, null, 2]</code>，写入 rep-level <code>[0, 1, 1]</code></p>
<p>遇到 <code>[]</code> 的时候，它会跳过这个，然后<strong>写入一个 rep-level 和空缺的 def-level</strong></p>
<p><code>[8, null, 10, 11]</code> 会写入 <code>rep-level</code> <code>[0, 1, 1, 1]</code></p>
<h3 id="Case-4-optional-array-lt-optional-i32-4-gt"><a href="#Case-4-optional-array-lt-optional-i32-4-gt" class="headerlink" title="Case 4: optional array&lt;optional i32, 4&gt;"></a>Case 4: <code>optional array&lt;optional i32, 4&gt;</code></h3><p>我们假设可以有这样的成员：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[0, null, 2, 3], null, [8, null, 10, 11]]</span><br></pre></td></tr></table></figure>
<p>这下我们又需要改变我们的树了！</p>
<p><img src="https://image.mwish.me/blog-image/parquet-c4-0.jpg" alt="parquet-c4-0"></p>
<p>这里，<code>NullableNode</code> 会读取对应的 validation bitset, 然后返回给下层：</p>
<ol>
<li>根节点 range 是 <code>[0, 3)</code></li>
<li>第一次发现不是 null 的，连续的返回 <code>[0, 1)</code> 范围给下层，下层和之前的逻辑一样处理</li>
<li>第二次发现 <code>null</code>，这里需要填充 rep-level 和 def-level，分别填充两个 <code>0</code> 上去</li>
<li>发现为 <code>null</code>，再次令其填充</li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrow-cheatsheet"><span class="toc-number">1.</span> <span class="toc-text">Arrow cheatsheet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Array"><span class="toc-number">1.1.</span> <span class="toc-text">Array</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rep-Level-and-Def-Levels"><span class="toc-number">2.</span> <span class="toc-text">Rep Level and Def Levels</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PathBuilder-%E6%9E%84%E5%BB%BA-Node-%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.</span> <span class="toc-text">PathBuilder: 构建 Node 阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%88%B6%E7%BA%A7%E5%88%AB-null"><span class="toc-number">2.1.1.</span> <span class="toc-text">处理父级别 null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-struct"><span class="toc-number">2.1.2.</span> <span class="toc-text">访问 struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-ListArray"><span class="toc-number">2.1.3.</span> <span class="toc-text">访问 ListArray</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9"><span class="toc-number">2.1.4.</span> <span class="toc-text">访问叶子结点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Write-%E9%98%B6%E6%AE%B5"><span class="toc-number">2.2.</span> <span class="toc-text">Write 阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WritePath-%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">WritePath 的算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">具体实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Samples-for-write"><span class="toc-number">3.</span> <span class="toc-text">Samples for write</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-1-i32"><span class="toc-number">3.1.</span> <span class="toc-text">Case 1: i32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-2-optional-i32"><span class="toc-number">3.2.</span> <span class="toc-text">Case 2: optional i32</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-3-array-lt-i32-4-gt"><span class="toc-number">3.3.</span> <span class="toc-text">Case 3: array&lt;i32, 4&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Case-3-1-array-lt-optional-i32-4-gt"><span class="toc-number">3.3.1.</span> <span class="toc-text">Case 3-1: array&lt;optional i32, 4&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-List-lt-int32-gt"><span class="toc-number">3.4.</span> <span class="toc-text">Case: List&lt;int32&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-4-optional-array-lt-optional-i32-4-gt"><span class="toc-number">3.5.</span> <span class="toc-text">Case 4: optional array&lt;optional i32, 4&gt;</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&text=Parquet Part2: arrow Parquet and levels"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&title=Parquet Part2: arrow Parquet and levels"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&is_video=false&description=Parquet Part2: arrow Parquet and levels"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Parquet Part2: arrow Parquet and levels&body=Check out this article: http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&title=Parquet Part2: arrow Parquet and levels"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&title=Parquet Part2: arrow Parquet and levels"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&title=Parquet Part2: arrow Parquet and levels"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&title=Parquet Part2: arrow Parquet and levels"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&name=Parquet Part2: arrow Parquet and levels&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/&t=Parquet Part2: arrow Parquet and levels"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2024
    mwish
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FL51GBW6JT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FL51GBW6JT');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
