<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="之前的 Part2 介绍了 Parquet 的 rep-level, def-level 的写入. Parquet 会根据用户输入的 Array，来根据 schema 的嵌套和中间的元数据，给一个 column 的数据构建对应的栈。在运行的时候，这里会找到连续的字段，然后给定对应的 rep-level 和 def-level 来填充数据。 在写入的时候，用户会给定一个 Array，然后让 Parq">
<meta property="og:type" content="article">
<meta property="og:title" content="Parquet Part3: read rep and def levels">
<meta property="og:url" content="http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/index.html">
<meta property="og:site_name" content="风空之岛">
<meta property="og:description" content="之前的 Part2 介绍了 Parquet 的 rep-level, def-level 的写入. Parquet 会根据用户输入的 Array，来根据 schema 的嵌套和中间的元数据，给一个 column 的数据构建对应的栈。在运行的时候，这里会找到连续的字段，然后给定对应的 rep-level 和 def-level 来填充数据。 在写入的时候，用户会给定一个 Array，然后让 Parq">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-18T16:55:00.000Z">
<meta property="article:modified_time" content="2023-04-25T12:51:52.132Z">
<meta property="article:author" content="mwish">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/logo.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico">
        
      
    
    <!-- title -->
    <title>Parquet Part3: read rep and def levels</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2022/10/21/Presto-SQL-on-Everything/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/10/04/Parquet-Part2-arrow-Parquet-code-path/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&text=Parquet Part3: read rep and def levels"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&title=Parquet Part3: read rep and def levels"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&is_video=false&description=Parquet Part3: read rep and def levels"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Parquet Part3: read rep and def levels&body=Check out this article: http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&title=Parquet Part3: read rep and def levels"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&title=Parquet Part3: read rep and def levels"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&title=Parquet Part3: read rep and def levels"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&title=Parquet Part3: read rep and def levels"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&name=Parquet Part3: read rep and def levels&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&t=Parquet Part3: read rep and def levels"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-Parquet-%E4%B8%AD%E7%9A%84%E9%93%BE%E8%B7%AF"><span class="toc-number">1.</span> <span class="toc-text">读取: Parquet 中的链路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TypedRecordReader-%E7%BB%84%E7%BB%87%E6%88%90%E8%BE%93%E5%87%BA%E8%A1%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BE%93%E5%87%BA-Value"><span class="toc-number">1.1.</span> <span class="toc-text">TypedRecordReader: 组织成输出行而不是输出 Value</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parquet-arrow-%E4%BB%8E-arrow-%E6%81%A2%E5%A4%8D-Array-%E6%95%B0%E6%8D%AE"><span class="toc-number">2.</span> <span class="toc-text">parquet&#x2F;arrow: 从 arrow 恢复 Array 数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ColumnReader"><span class="toc-number">2.1.</span> <span class="toc-text">ColumnReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LeafReader"><span class="toc-number">2.2.</span> <span class="toc-text">LeafReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List-Struct"><span class="toc-number">2.3.</span> <span class="toc-text">List &#x2F; Struct</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">总结</span></a>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Parquet Part3: read rep and def levels
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">mwish</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-10-18T16:55:00.000Z" itemprop="datePublished">2022-10-19</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>之前的 Part2 介绍了 Parquet 的 rep-level, def-level 的写入. Parquet 会根据用户输入的 <code>Array</code>，来根据 schema 的嵌套和中间的元数据，给一个 column 的数据构建对应的栈。在运行的时候，这里会找到连续的字段，然后给定对应的 rep-level 和 def-level 来填充数据。</p>
<p>在写入的时候，用户会给定一个 <code>Array</code>，然后让 Parquet 把 array 中的数据序列化成 <code>rep-level</code>, <code>def-level</code> 和值，这些东西会被编码到 <code>Page</code> 中，以 <code>DATA_PAGE_V2</code> 为例：</p>
<ol>
<li>会有个 PageHeader，告诉你有没有 rep-level 和 def-level，和对应长度</li>
<li>rep-level 和 def-level 被 rle/bit-packing 编码</li>
<li>Page 可能被编码与压缩，会记录相关的内容</li>
</ol>
<p>读取的时候，这些东西也会按照 schema 解析，但是需要回过头来注意一下，读取的时候也是一个层次读取，但是需要从一组 rep-level / def-level 来恢复多层的信息了。</p>
<p>我们可以再回顾一下，<code>parquet</code> 在 arrow 项目的路径是：<code>cpp/src/parquet/</code>:</p>
<ol>
<li><code>cpp/src/parquet/</code>：目录下有基本的 parquet 的 schema 和实现，包括 Page 的处理、压缩、column 的处理，这里都是符合标准的，它会借用部分 <code>arrow</code> 的库和实现</li>
<li><code>cpp/src/parquet/arrow</code>：<code>arrow</code> 的转义层，能够把 arrow 的东西解析读、写到 parquet 上，这里的 <code>FileReader</code> 等都会包装 <code>cpp/src/parquet</code> 上的数据，然后处理 <code>rep-level</code> 和 <code>def-level</code>。<strong>上一篇博客里面 levels 的构建就是在 arrow 下面的 </strong>。</li>
</ol>
<p>Arrow 读取的对应链路大概如下：</p>
<ol>
<li><code>ParquetFileReader</code> 是最外层的数据，用 <code>ParquetFileReader::Open</code> 等相关的 api 来打开对应的文件。这里可以根据 <code>RowGroup(rgId)</code> 这个函数，创建对应的 <code>RowGroupReader</code></li>
<li><code>SerializedFile</code> 实现了 <code>ParquetFileReader::Contents</code>，具体实现了 <code>ParquetFileReader</code> 的对应逻辑，它可以加载 parquet 的 footer，然后解析 Footer。根据解析的 Footer 来加载对应的 <code>RowGroupReader</code><ol>
<li>在文件 IO 上，这里有一个 <code>::arrow::io::internal::ReadRangeCache</code> 表示对某个范围的 caching。然后有一组和这个有关的 api 表示是否缓存</li>
<li><code>ReaderProperties</code> 表示这个 Reader 的配置，比如是否使用 caching 等</li>
<li>有 <code>FileMetaData</code> 的 API，注意，这个相当于对 parquet 依赖的 thrift 生成的代码的 wrapper。Parquet 不对外暴露 thrift，而是暴露对应的自己的 API Wrapper，怎么说呢，可以说这个抽象比较好，但是性能也确实比较挫（考虑极端场景，只需要一个 count，也得把 Footer 整个解析）</li>
</ol>
</li>
<li><code>RowGroupReader</code>可以返回 <code>parquet::ColumnReader</code> 和某个 Column 的 <code>PageReader</code></li>
<li><code>SerializedRowGroup</code> 实现了 <code>RowGroupReader::Contents</code>，持有某个 RowGroup 的 MetaData</li>
<li><code>PageReader</code> 有 <code>SerializedPageReader</code> 这个实现，对外返回对应的解压之后的 <code>Page</code> 对象，这里可以是数据页、字典页面、Index Page。</li>
<li><code>parquet::ColumnReader</code> 在 <code>PageReader</code> 上包装了一层记录读取的 API，根据 <code>ReadBatch</code> 和 <code>ReadBatchSpaced</code> 之类的 api 来读取对应的数据，然后返回给上层。这里也会读取 <code>Page</code> 上的 Level，来恢复对应的记录</li>
<li><code>parquet::arrow</code> 模块会调用上文对应的东西，它有一个 <code>ColumnReader</code>，注意这个 <code>ColumnReader</code> 不要和上面 <code>ColumnReader</code> 搞混了，这是用来恢复 <code>Array</code> 的</li>
</ol>
<h3 id="读取-Parquet-中的链路"><a href="#读取-Parquet-中的链路" class="headerlink" title="读取: Parquet 中的链路"></a>读取: Parquet 中的链路</h3><p>这块读取比写入简单很多，大概是：</p>
<ol>
<li>每一列读 rep-level, def-level 自己就能恢复自己这层的数据</li>
<li>上层找到 children 的 level，然后可以恢复</li>
</ol>
<p>所有的恢复都经由 <code>ColumnReader</code>，叶子结点恢复实现在 <code>TypedRecordReader</code> 中，<code>LeafReader</code> 创建 <code>TypeRecordReader</code> 来读取。而上层在 <code>ListReader</code> 和 <code>StructReader</code> 中恢复，恢复的时候需要从子节点中挑选一个 <code>TypedRecordReader</code> 来恢复一些信息. <code>ColumnReader</code> 这个 API 只有叶子结点有。</p>
<p><code>ColumnReader</code> 的 API 非常简单，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PARQUET_EXPORT</span> ColumnReader &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ColumnReader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> std::shared_ptr&lt;ColumnReader&gt; <span class="title">Make</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> ColumnDescriptor* descr, std::unique_ptr&lt;PageReader&gt; pager,</span></span></span><br><span class="line"><span class="params"><span class="function">      ::arrow::MemoryPool* pool = ::arrow::default_memory_pool())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true if there are still values in this column.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HasNext</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Type::type <span class="title">type</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> ColumnDescriptor* <span class="title">descr</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the encoding that can be exposed by this reader. If it returns</span></span><br><span class="line">  <span class="comment">// dictionary encoding, then ReadBatchWithDictionary can be used to read data.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \note API EXPERIMENTAL</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> ExposedEncoding <span class="title">GetExposedEncoding</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">RowGroupReader</span>;</span><br><span class="line">  <span class="comment">// Set the encoding that can be exposed by this reader.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// \note API EXPERIMENTAL</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetExposedEncoding</span><span class="params">(ExposedEncoding encoding)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有一些别的结构，我们先来整理一下继承关系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 提供了 ReadBatch, ReadBatchSpaced 和 Skip, 便于用户读取某一列的具体数据.</span></span><br><span class="line"><span class="comment">/// 这个也是一个接口层, 相对 `ColumnReader` 提供了通用的接口, 这里提供了 Batch 读某个类型的接口. </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypedColumnReader</span> : <span class="keyword">public</span> ColumnReader &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 实现了从某个 decoder 来读 values, 读 rep-level 和 def-levels.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 这里也有一些列维护的信息, 比如对应的 decoder, 还有一些静态信息, 比如 Column 对应的最大的 def-level 和</span></span><br><span class="line"><span class="comment">/// rep-level, 记做 descr 和 level info.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 这里是 Column Reader, 所以处理返回对应的是 ColumnChunk, 这里会维护需要处理的 value 数量 </span></span><br><span class="line"><span class="comment">///  (ColumnMetaData 会记录 `num_values`, 代表值而非行)</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 这里也处理了 levels (rep-level 和 def-level) 的 decoder, 因为这两个和某个具体的类型是无关的.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColumnReaderImplBase</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> T = <span class="keyword">typename</span> DType::c_type;</span><br><span class="line">  <span class="keyword">using</span> DecoderType = TypedDecoder&lt;DType&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 具体的 reader 实现, 实现了 ReadBatch, ReadBatchSpaced 和 Skip.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypedColumnReaderImpl</span> : <span class="keyword">public</span> TypedColumnReader&lt;DType&gt;,</span><br><span class="line">                              <span class="keyword">public</span> ColumnReaderImplBase&lt;DType&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> T = <span class="keyword">typename</span> DType::c_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，具体实现会在 <code>TypedColumnReader</code> 和 <code>TypedColumnReaderImpl</code> 中。对外接口有 <code>Skip</code>, <code>ReadBatch</code>，有一个比较复杂的 <code>ReadBatchSpaced</code> 的接口已经 deprecated 了。</p>
<p>我们专注在 <code>ReadBatch</code> 上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// API to read values from a single column. This is a main client facing API.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TypedColumnReader</span> : <span class="keyword">public</span> ColumnReader &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> DType::c_type T;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read a batch of repetition levels, definition levels, and values from the</span></span><br><span class="line">  <span class="comment">// column.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Since null values are not stored in the values, the number of values read</span></span><br><span class="line">  <span class="comment">// may be less than the number of repetition and definition levels. With</span></span><br><span class="line">  <span class="comment">// nested data this is almost certainly true.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Set def_levels or rep_levels to nullptr if you want to skip reading them.</span></span><br><span class="line">  <span class="comment">// This is only safe if you know through some other source that there are no</span></span><br><span class="line">  <span class="comment">// undefined values.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// To fully exhaust a row group, you must read batches until the number of</span></span><br><span class="line">  <span class="comment">// values read reaches the number of stored values according to the metadata.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This API is the same for both V1 and V2 of the DataPage</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// @returns: actual number of levels read (see values_read for number of values read)</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">ReadBatch</span><span class="params">(<span class="type">int64_t</span> batch_size, <span class="type">int16_t</span>* def_levels, <span class="type">int16_t</span>* rep_levels,</span></span></span><br><span class="line"><span class="params"><span class="function">                            T* values, <span class="type">int64_t</span>* values_read)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里，会根据 <code>batch_size</code> 来填充数据，这里分为：</p>
<ol>
<li><code>def_levels</code> 和 <code>rep_levels</code>，两个 <code>i16</code> 数组，代表对应的 levels，可能没有读，这两个是等长的（不等长会抛出 exception）</li>
<li><code>values</code>，具体的值</li>
<li><code>values_read</code>, 代表具体从存储读了多少<strong>非 null 值</strong>。尽量从 rep_levels 和 def_levels 来判断这个值</li>
</ol>
<p>看看实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DType&gt;</span><br><span class="line"><span class="type">int64_t</span> TypedColumnReaderImpl&lt;DType&gt;::<span class="built_in">ReadBatch</span>(<span class="type">int64_t</span> batch_size, <span class="type">int16_t</span>* def_levels,</span><br><span class="line">                                                <span class="type">int16_t</span>* rep_levels, T* values,</span><br><span class="line">                                                <span class="type">int64_t</span>* values_read) &#123;</span><br><span class="line">  <span class="comment">// HasNext invokes ReadNewPage</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">HasNext</span>()) &#123;</span><br><span class="line">    *values_read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(wesm): keep reading data pages until batch_size is reached, or the</span></span><br><span class="line">  <span class="comment">// row group is finished</span></span><br><span class="line">  <span class="type">int64_t</span> num_def_levels = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int64_t</span> values_to_read = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 读 levels, 然后也判断出哪些是 null, 如果有 null 或者里面消费完了, 具体要读的值可能会小于 `batch_size`.</span></span><br><span class="line">  <span class="built_in">ReadLevels</span>(batch_size, def_levels, rep_levels, &amp;num_def_levels, &amp;values_to_read);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取非 null 的 value, 在没有读完这个 Page 的时候, values_read == values.</span></span><br><span class="line">  *values_read = <span class="keyword">this</span>-&gt;<span class="built_in">ReadValues</span>(values_to_read, values);</span><br><span class="line">  <span class="type">int64_t</span> total_values = std::<span class="built_in">max</span>(num_def_levels, *values_read);</span><br><span class="line">  <span class="type">int64_t</span> expected_values =</span><br><span class="line">      std::<span class="built_in">min</span>(batch_size, <span class="keyword">this</span>-&gt;num_buffered_values_ - <span class="keyword">this</span>-&gt;num_decoded_values_);</span><br><span class="line">  <span class="keyword">if</span> (total_values == <span class="number">0</span> &amp;&amp; expected_values &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;Read 0 values, expected &quot;</span> &lt;&lt; expected_values;</span><br><span class="line">    ParquetException::<span class="built_in">EofException</span>(ss.<span class="built_in">str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="built_in">ConsumeBufferedValues</span>(total_values);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> total_values;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会：</p>
<ol>
<li>根据 <code>batch_size</code> 和内部的状态，看看读多少值，然后解析对应的 <code>levels</code>。( <code>ReadLevels</code> )</li>
<li>读取对应的非 null 的 values (<code>ReadValues</code>, 里面会调用 <code>decoder-&gt;Decode</code>)</li>
<li>返回的是读的所有包括 null 的值的数目，<code>values_read</code> 会存放 <code>values</code> 中内容的长度 (<code>ConsumeBufferedValues</code> )</li>
</ol>
<p>这里我们重申一个比较 hack 的地方，就是变量名称问题，这个也涉及到一些 Decoder 内部的逻辑：</p>
<ol>
<li><code>num_buffered_values_</code>: Page 中的 <strong>values</strong> 的水位</li>
<li><code>num_decoded_values_</code>: decode 成功吐出去的 <strong>values</strong> 的水位</li>
</ol>
<p>你会发现我这里的用词是 Levels 而不是 Values…我们看看之前博客里的 <code>num_values</code> 的逻辑( <a href="https://blog.mwish.me/2022/09/18/Parquet-Part1-Basic/">https://blog.mwish.me/2022/09/18/Parquet-Part1-Basic/</a> )：</p>
<blockquote>
<p>DataPageV2 会有 <code>num_rows</code>，表示对应行的数量。<strong>在有嵌套的情况下，这个不等于 <code>num_values</code></strong>.</p>
<p>这里代表的是「包括 nulls，这个 <code>ColumnChunk</code> 对应值的数量」而非「这个 <code>ColumnChunk</code> 对应行的数量」。这个地方我说的可能有一点难理解，比如对于 <code>optional i32</code> 的平坦数据，这里等价于行数，而对于 <code>repeated &lt;optional i32&gt;</code>，这里代表内层的数量。<code>PageHeader</code> 的 <code>num_values</code> 也同理。</p>
</blockquote>
<p>这里会根据 page 来设置对应的值，同时跟 <code>HasNextInternal()</code> 这个接口联合使用，来不停 fetch page。（values, rows/record, levels 这些概念比较混乱，注意区分）。</p>
<p>这个地方解析了对应的东西，然后返回了对应的数值。当然，这里逻辑比较简单。</p>
<p>这个地方可以总结性质的放一张流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型组合:</span><br><span class="line">- ColumnReader(ColumnReaderImpl, TypedColumnReader): 包含数据 decoder, rep-level 和 def-level 的 Decoder, page reader</span><br><span class="line">- RecordReader(注册数据的 buffer, rep-level buffer, def-level buffer, page buffer)</span><br></pre></td></tr></table></figure>
<h4 id="TypedRecordReader-组织成输出行而不是输出-Value"><a href="#TypedRecordReader-组织成输出行而不是输出-Value" class="headerlink" title="TypedRecordReader: 组织成输出行而不是输出 Value"></a>TypedRecordReader: 组织成输出行而不是输出 Value</h4><p><code>TypedRecordReader</code> 提供了一组复杂一点的函数：<code>ReadRecords</code> 和 <code>ReadRecordData</code>，这个就相当于「读上层的几行」了。这个是给 <code>parquet::arrow</code> 准备的结构。</p>
<p>这套相当于把 Values 的读取交给 <code>ColumnReaderImpl</code> 层，然后在上面封装了 Row 的 Read。它相当于一个特种类型的记录组织器，能表示具体处理的「行」，而 <code>ColumnReader</code> 处理的内容是 “values”.</p>
<p>这部分相当于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> internal &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// \brief Stateful column reader that delimits semantic records for both flat</span></span><br><span class="line"><span class="comment">/// and nested columns</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \note API EXPERIMENTAL</span></span><br><span class="line"><span class="comment">/// \since 1.3.0</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RecordReader</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> std::shared_ptr&lt;RecordReader&gt; <span class="title">Make</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> ColumnDescriptor* descr, LevelInfo leaf_info,</span></span></span><br><span class="line"><span class="params"><span class="function">      ::arrow::MemoryPool* pool = ::arrow::default_memory_pool(),</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">bool</span> read_dictionary = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">RecordReader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Attempt to read indicated number of records from column chunk</span></span><br><span class="line">  <span class="comment">/// \return number of records read</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">ReadRecords</span><span class="params">(<span class="type">int64_t</span> num_records)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Pre-allocate space for data. Results in better flat read performance</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Reserve</span><span class="params">(<span class="type">int64_t</span> num_values)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Clear consumed values and repetition/definition levels as the</span></span><br><span class="line">  <span class="comment">/// result of calling ReadRecords</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Reset</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Transfer filled values buffer to caller. A new one will be</span></span><br><span class="line">  <span class="comment">/// allocated in subsequent ReadRecords calls</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;ResizableBuffer&gt; <span class="title">ReleaseValues</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Transfer filled validity bitmap buffer to caller. A new one will</span></span><br><span class="line">  <span class="comment">/// be allocated in subsequent ReadRecords calls</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::shared_ptr&lt;ResizableBuffer&gt; <span class="title">ReleaseIsValid</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Return true if the record reader has more internal data yet to</span></span><br><span class="line">  <span class="comment">/// process</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HasMoreData</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Advance record reader to the next row group</span></span><br><span class="line">  <span class="comment">/// \param[in] reader obtained from RowGroupReader::GetColumnPageReader</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetPageReader</span><span class="params">(std::unique_ptr&lt;PageReader&gt; reader)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DebugPrintState</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Decoded definition levels</span></span><br><span class="line">  <span class="function"><span class="type">int16_t</span>* <span class="title">def_levels</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int16_t</span>*&gt;(def_levels_-&gt;<span class="built_in">mutable_data</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Decoded repetition levels</span></span><br><span class="line">  <span class="function"><span class="type">int16_t</span>* <span class="title">rep_levels</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int16_t</span>*&gt;(rep_levels_-&gt;<span class="built_in">mutable_data</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Decoded values, including nulls, if any</span></span><br><span class="line">  <span class="function"><span class="type">uint8_t</span>* <span class="title">values</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> values_-&gt;<span class="built_in">mutable_data</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Number of values written including nulls (if any)</span></span><br><span class="line">  <span class="function"><span class="type">int64_t</span> <span class="title">values_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> values_written_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Number of definition / repetition levels (from those that have</span></span><br><span class="line">  <span class="comment">/// been decoded) that have been consumed inside the reader.</span></span><br><span class="line">  <span class="function"><span class="type">int64_t</span> <span class="title">levels_position</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> levels_position_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Number of definition / repetition levels that have been written</span></span><br><span class="line">  <span class="comment">/// internally in the reader</span></span><br><span class="line">  <span class="function"><span class="type">int64_t</span> <span class="title">levels_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> levels_written_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Number of nulls in the leaf</span></span><br><span class="line">  <span class="function"><span class="type">int64_t</span> <span class="title">null_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> null_count_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief True if the leaf values are nullable</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">nullable_values</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> nullable_values_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief True if reading directly as Arrow dictionary-encoded</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">read_dictionary</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> read_dictionary_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">bool</span> nullable_values_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部状态, 表示现在的记录是否是在某行的行首, 用来推进 records_read</span></span><br><span class="line">  <span class="type">bool</span> at_record_start_;</span><br><span class="line">  <span class="comment">// 读的行数的计数</span></span><br><span class="line">  <span class="type">int64_t</span> records_read_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// values 状态的记录器.</span></span><br><span class="line">  <span class="comment">// 这部分也需要处理</span></span><br><span class="line">  <span class="type">int64_t</span> values_written_;</span><br><span class="line">  <span class="type">int64_t</span> values_capacity_;</span><br><span class="line">  <span class="type">int64_t</span> null_count_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面这里提供了一个 buffer</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 解析出的 levels</span></span><br><span class="line">  <span class="type">int64_t</span> levels_written_;</span><br><span class="line">  <span class="comment">// 行 Parsing 完的 records</span></span><br><span class="line">  <span class="type">int64_t</span> levels_position_;</span><br><span class="line">  <span class="type">int64_t</span> levels_capacity_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 变长记录的 value buffer</span></span><br><span class="line">  std::shared_ptr&lt;::arrow::ResizableBuffer&gt; values_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In the case of false, don&#x27;t allocate the values buffer (when we directly read into</span></span><br><span class="line">  <span class="comment">// builder classes).</span></span><br><span class="line">  <span class="type">bool</span> uses_values_;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;::arrow::ResizableBuffer&gt; valid_bits_;</span><br><span class="line">  std::shared_ptr&lt;::arrow::ResizableBuffer&gt; def_levels_;</span><br><span class="line">  std::shared_ptr&lt;::arrow::ResizableBuffer&gt; rep_levels_;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> read_dictionary_ = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里存放了各种内容，能切换 Page 然后解析道本地的 <code>values_</code> 上，是一个有状态的读者。</p>
<p><code>TypedRecordReader::ReadRecord</code> 读出具体的数据，这个地方会根据两个 level 选择从底层读多少行。最重要的函数在 <code>ReadRecordData</code>，这个会把对应的逻辑编组成 array，然后设置 null。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return number of logical records read</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 读到 level 之后, 来读具体数据惹</span></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">ReadRecordData</span><span class="params">(<span class="type">int64_t</span> num_records)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Conservative upper bound</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int64_t</span> possible_num_values =</span><br><span class="line">      std::<span class="built_in">max</span>(num_records, levels_written_ - levels_position_);</span><br><span class="line">  <span class="built_in">ReserveValues</span>(possible_num_values);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">int64_t</span> start_levels_position = levels_position_;</span><br><span class="line"></span><br><span class="line">  <span class="type">int64_t</span> values_to_read = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int64_t</span> records_read = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;max_rep_level_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 有重复或者空的，走 delimit</span></span><br><span class="line">    records_read = <span class="built_in">DelimitRecords</span>(num_records, &amp;values_to_read);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;max_def_level_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有重复，只有可空。那么 written - position 就是数目.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No repetition levels, skip delimiting logic. Each level represents a</span></span><br><span class="line">    <span class="comment">// null or not null entry</span></span><br><span class="line">    records_read = std::<span class="built_in">min</span>(levels_written_ - levels_position_, num_records);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is advanced by DelimitRecords, which we skipped</span></span><br><span class="line">    levels_position_ += records_read;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    records_read = values_to_read = num_records;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 具体读值的逻辑</span></span><br><span class="line">  <span class="type">int64_t</span> null_count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (leaf_info_.<span class="built_in">HasNullableValues</span>()) &#123;</span><br><span class="line">    ValidityBitmapInputOutput validity_io;</span><br><span class="line">    validity_io.values_read_upper_bound = levels_position_ - start_levels_position;</span><br><span class="line">    validity_io.valid_bits = valid_bits_-&gt;<span class="built_in">mutable_data</span>();</span><br><span class="line">    validity_io.valid_bits_offset = values_written_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// def level 拆分</span></span><br><span class="line">    <span class="built_in">DefLevelsToBitmap</span>(<span class="built_in">def_levels</span>() + start_levels_position,</span><br><span class="line">                      <span class="comment">/* level 的数量 */</span> levels_position_ - start_levels_position, leaf_info_,</span><br><span class="line">                      &amp;validity_io);</span><br><span class="line">    values_to_read = validity_io.values_read - validity_io.null_count;</span><br><span class="line">    null_count = validity_io.null_count;</span><br><span class="line">    <span class="built_in">DCHECK_GE</span>(values_to_read, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ReadValuesSpaced</span>(validity_io.values_read, null_count);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DCHECK_GE</span>(values_to_read, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ReadValuesDense</span>(values_to_read);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;leaf_info_.def_level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Optional, repeated, or some mix thereof</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">ConsumeBufferedValues</span>(levels_position_ - start_levels_position);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Flat, non-repeated</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">ConsumeBufferedValues</span>(values_to_read);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Total values, including null spaces, if any</span></span><br><span class="line">  values_written_ += values_to_read + null_count;</span><br><span class="line">  null_count_ += null_count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> records_read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还是比较复杂的，本身是个多继承，<code>TypedRecordReader</code> 继承了 <code>ColumnReaderImpl</code> 和 <code>RecordReader</code>，这两个都是有状态的，状态又贼多，我觉得设计的让我看了头痛。但上面这段代码其实挺好懂的：</p>
<p>计算 <code>records_read</code> (读的行) 和 <code>values_to_read</code> 需要读的 <code>rep-level</code> 和 <code>def-level</code> 与值</p>
<ol>
<li>当 <code>max_def_level_</code> 和 <code>max_rep_level_</code> 都等于 0 的时候，schema 是平坦的，且没有值为 null，所以读的 行和记录数量都是固定的，也没有 rep-level 和 def-level</li>
<li>当 <code>max_def_level_ != 0</code> ，<code>max_rep_level_ == 0</code> 的时候，schema 是平坦的，但是有的值可能为 null，<strong>这里读取 num-record 条 def level 就行了</strong>, 可以解析这些行解析出 null，但不用处理重复的 rep/def.</li>
<li>否则，走 <code>DelimitRecords</code>，去解析行的数量. 这段应该是整个 Parquet 读流程最 hack 的一部分代码了</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Process written repetition/definition levels to reach the end of</span></span><br><span class="line"><span class="comment">// records. Process no more levels than necessary to delimit the indicated</span></span><br><span class="line"><span class="comment">// number of logical records. Updates internal state of RecordReader</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 这个函数只会发生在 rep-level 和 def-level 都在的情况下. 这里会根据内部状态 `at_record_start_` </span></span><br><span class="line"><span class="comment">//  判断是否在一个行的开头. 目标是不越过 `levels_written_` 的情况下读 `num_records` 行.</span></span><br><span class="line"><span class="comment">// 返回读的行数和 values</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// \return Number of records delimited</span></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">DelimitRecords</span><span class="params">(<span class="type">int64_t</span> num_records, <span class="type">int64_t</span>* values_seen)</span> </span>&#123;</span><br><span class="line">  <span class="type">int64_t</span> values_to_read = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int64_t</span> records_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">int16_t</span>* def_levels = <span class="keyword">this</span>-&gt;<span class="built_in">def_levels</span>() + levels_position_;</span><br><span class="line">  <span class="type">const</span> <span class="type">int16_t</span>* rep_levels = <span class="keyword">this</span>-&gt;<span class="built_in">rep_levels</span>() + levels_position_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DCHECK_GT</span>(<span class="keyword">this</span>-&gt;max_rep_level_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Count logical records and number of values to read</span></span><br><span class="line">  <span class="comment">// 读 level_position 来判断内容</span></span><br><span class="line">  <span class="comment">// 这里的逻辑会先读 rep_level, 来查一下行的变更, rep_level == 0 一定切了行, 读完了就会返回.</span></span><br><span class="line">  <span class="comment">// 然后会检查 `def_level`, 看这个是否是 null. 不是 null 就会添加 `values_to_read`.</span></span><br><span class="line">  <span class="comment">// **非 0 的 rep-level 不会被这一层处理**</span></span><br><span class="line">  <span class="keyword">while</span> (levels_position_ &lt; levels_written_) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int16_t</span> rep_level = *rep_levels++;</span><br><span class="line">    <span class="comment">// rep_level == 0 的时候, 一定是整行的开头.</span></span><br><span class="line">    <span class="keyword">if</span> (rep_level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// If at_record_start_ is true, we are seeing the start of a record</span></span><br><span class="line">      <span class="comment">// for the second time, such as after repeated calls to</span></span><br><span class="line">      <span class="comment">// DelimitRecords. In this case we must continue until we find</span></span><br><span class="line">      <span class="comment">// another record start or exhausting the ColumnChunk</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 上一次走完了这行, 就会 `!at_record_start_`.</span></span><br><span class="line">      <span class="keyword">if</span> (!at_record_start_) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;ve reached the end of a record; increment the record count.</span></span><br><span class="line">        ++records_read;</span><br><span class="line">        <span class="keyword">if</span> (records_read == num_records) &#123;</span><br><span class="line">          <span class="comment">// We&#x27;ve found the number of records we were looking for. Set</span></span><br><span class="line">          <span class="comment">// at_record_start_ to true and break</span></span><br><span class="line">          at_record_start_ = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We have decided to consume the level at this position; therefore we</span></span><br><span class="line">    <span class="comment">// must advance until we find another record boundary</span></span><br><span class="line">    at_record_start_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int16_t</span> def_level = *def_levels++;</span><br><span class="line">    <span class="keyword">if</span> (def_level == <span class="keyword">this</span>-&gt;max_def_level_) &#123;</span><br><span class="line">      ++values_to_read;</span><br><span class="line">    &#125;</span><br><span class="line">    ++levels_position_;</span><br><span class="line">  &#125;</span><br><span class="line">  *values_seen = values_to_read;</span><br><span class="line">  <span class="keyword">return</span> records_read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读完之后，这里会具体把值读到 buffer 中。如果叶子结点非 <code>null</code>，那就直接 <code>ReadValuesDense</code> 了，符合逻辑，否则的话，这里会：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体读值的逻辑</span></span><br><span class="line"><span class="type">int64_t</span> null_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (leaf_info_.<span class="built_in">HasNullableValues</span>()) &#123;</span><br><span class="line">  ValidityBitmapInputOutput validity_io;</span><br><span class="line">  validity_io.values_read_upper_bound = levels_position_ - start_levels_position;</span><br><span class="line">  validity_io.valid_bits = valid_bits_-&gt;<span class="built_in">mutable_data</span>(); <span class="comment">// 指向 `valid_bits_` 内部数组.</span></span><br><span class="line">  validity_io.valid_bits_offset = values_written_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// def level 拆分</span></span><br><span class="line">  <span class="built_in">DefLevelsToBitmap</span>(<span class="built_in">def_levels</span>() + start_levels_position,</span><br><span class="line">                    <span class="comment">/* level 的数量 */</span> levels_position_ - start_levels_position, leaf_info_,</span><br><span class="line">                    &amp;validity_io);</span><br><span class="line">  values_to_read = validity_io.values_read - validity_io.null_count;</span><br><span class="line">  null_count = validity_io.null_count;</span><br><span class="line">  <span class="built_in">DCHECK_GE</span>(values_to_read, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">ReadValuesSpaced</span>(validity_io.values_read, null_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑感觉写的…有点怪，它会根据 <code>values_read_upper_bound</code> 和 <code>valid_bits_offset</code> 来填充 <code>valid_bits</code> 和 <code>null_count</code> 和 <code>values_read</code>，这里应该相当于一个内部检查，毕竟 <code>values_read</code> 前面只有 <code>rep_level == 0, def_level != 0</code> 的时候没算过😅。这里会给出 Level，把对应的 count 用 simd 解析完，然后算到 <code>validity_io</code> 里面，然后用 <code>ReadValuesSpaced</code> 读取对应的数据。这一块状态传递非常乱，建议不改这块代码意会一下就好了。这块作者主要是 Micah Cornfield 和 Wesm，代码性能确实不错，但是写的好暴力啊。</p>
<p>总之，这里会拿到行数、<code>null_count</code> 和 <code>null-bitmap</code>，然后完成读取。</p>
<p>这里还有个比较 hack 的地方，就是 <code>levels_position_</code> 的处理，这段代码比较 hacking，它会：</p>
<ol>
<li>在底层的时候，就知道有多少行数据，record reader 解析出一个 record 数目</li>
<li>上层根据 Def-Rep 解析出 List / Map 的 size 和 nullable，恢复出上层的数据</li>
</ol>
<p>所以，解析的时候，有2个 levels:</p>
<ol>
<li>levels position: 目前读的行的 levels</li>
<li>levels written: 从 page 中捞出来的 levels</li>
</ol>
<h3 id="parquet-arrow-从-arrow-恢复-Array-数据"><a href="#parquet-arrow-从-arrow-恢复-Array-数据" class="headerlink" title="parquet/arrow: 从 arrow 恢复 Array 数据"></a>parquet/arrow: 从 arrow 恢复 Array 数据</h3><p>上面我们拿到了 api 和从 Column 中读数据的逻辑，下面这里需要从 Parquet 拿到的连续数据中恢复 arrow 的数据。对应的实现在 <code>parquet/arrow/reader</code> 中。再次提醒一下，这里 <code>namespace</code> 是 <code>parquet::arrow</code>，负责 <code>arrow</code> 一些复杂格式和 parquet 互转。</p>
<h4 id="ColumnReader"><a href="#ColumnReader" class="headerlink" title="ColumnReader"></a>ColumnReader</h4><p>头文件中，有一个 <code>ColumnReader</code>，作为读取接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// At this point, the column reader is a stream iterator. It only knows how to</span></span><br><span class="line"><span class="comment">// read the next batch of values for a particular column from the file until it</span></span><br><span class="line"><span class="comment">// runs out.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We also do not expose any internal Parquet details, such as row groups. This</span></span><br><span class="line"><span class="comment">// might change in the future.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PARQUET_EXPORT</span> ColumnReader &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ColumnReader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Scan the next array of the indicated size. The actual size of the</span></span><br><span class="line">  <span class="comment">// returned array may be less than the passed size depending how much data is</span></span><br><span class="line">  <span class="comment">// available in the file.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// When all the data in the file has been exhausted, the result is set to</span></span><br><span class="line">  <span class="comment">// nullptr.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Returns Status::OK on a successful read, including if you have exhausted</span></span><br><span class="line">  <span class="comment">// the data available in the file.</span></span><br><span class="line">  <span class="keyword">virtual</span> ::<span class="function">arrow::Status <span class="title">NextBatch</span><span class="params">(<span class="type">int64_t</span> batch_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    std::shared_ptr&lt;::arrow::ChunkedArray&gt;* out)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColumnReaderImpl</span> : <span class="keyword">public</span> ColumnReader &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">GetDefLevels</span><span class="params">(<span class="type">const</span> <span class="type">int16_t</span>** data, <span class="type">int64_t</span>* length)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">GetRepLevels</span><span class="params">(<span class="type">const</span> <span class="type">int16_t</span>** data, <span class="type">int64_t</span>* length)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::shared_ptr&lt;Field&gt; <span class="title">field</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ::<span class="function">arrow::Status <span class="title">NextBatch</span><span class="params">(<span class="type">int64_t</span> batch_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::shared_ptr&lt;::arrow::ChunkedArray&gt;* out)</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">LoadBatch</span>(batch_size));</span><br><span class="line">    <span class="built_in">RETURN_NOT_OK</span>(<span class="built_in">BuildArray</span>(batch_size, out));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; (*out)-&gt;<span class="built_in">num_chunks</span>(); x++) &#123;</span><br><span class="line">      <span class="built_in">RETURN_NOT_OK</span>((*out)-&gt;<span class="built_in">chunk</span>(x)-&gt;<span class="built_in">Validate</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ::<span class="function">arrow::Status <span class="title">LoadBatch</span><span class="params">(<span class="type">int64_t</span> num_records)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ::<span class="function">arrow::Status <span class="title">BuildArray</span><span class="params">(<span class="type">int64_t</span> length_upper_bound,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     std::shared_ptr&lt;::arrow::ChunkedArray&gt;* out)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsOrHasRepeatedChild</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里内容分为两部分:</p>
<ol>
<li><p><code>LoadBatch</code>: 利用之前讲的 <code>RecordReader</code> 来把一个 Batch 的行加载到 Values 的 Buffer 中</p>
</li>
<li><p><code>BuildArray</code>： 构建内存 array，可能会从子节点构建父节点</p>
</li>
</ol>
<p>这里其实还可能要转型，为什么要转型呢？parquet 基础类型其实没几个，比方说 int8，它也会用更大的 int 去压缩。所以这里要转型到内存的格式中</p>
<h4 id="LeafReader"><a href="#LeafReader" class="headerlink" title="LeafReader"></a>LeafReader</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Leaf reader is for primitive arrays and primitive children of nested arrays</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeafReader</span> : <span class="keyword">public</span> ColumnReaderImpl &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Status <span class="title">GetDefLevels</span><span class="params">(<span class="type">const</span> <span class="type">int16_t</span>** data, <span class="type">int64_t</span>* length)</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    *data = record_reader_-&gt;<span class="built_in">def_levels</span>();</span><br><span class="line">    *length = record_reader_-&gt;<span class="built_in">levels_position</span>();</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">GetRepLevels</span><span class="params">(<span class="type">const</span> <span class="type">int16_t</span>** data, <span class="type">int64_t</span>* length)</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    *data = record_reader_-&gt;<span class="built_in">rep_levels</span>();</span><br><span class="line">    *length = record_reader_-&gt;<span class="built_in">levels_position</span>();</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsOrHasRepeatedChild</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">final</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">LoadBatch</span><span class="params">(<span class="type">int64_t</span> records_to_read)</span> <span class="keyword">final</span></span>;</span><br><span class="line"></span><br><span class="line">  ::<span class="function">arrow::Status <span class="title">BuildArray</span><span class="params">(<span class="type">int64_t</span> length_upper_bound,</span></span></span><br><span class="line"><span class="params"><span class="function">                             std::shared_ptr&lt;::arrow::ChunkedArray&gt;* out)</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">    *out = out_;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::shared_ptr&lt;ChunkedArray&gt; out_;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NextRowGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;PageReader&gt; page_reader = input_-&gt;<span class="built_in">NextChunk</span>();</span><br><span class="line">    record_reader_-&gt;<span class="built_in">SetPageReader</span>(std::<span class="built_in">move</span>(page_reader));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;ReaderContext&gt; ctx_;</span><br><span class="line">  std::shared_ptr&lt;Field&gt; field_;</span><br><span class="line">  std::unique_ptr&lt;FileColumnIterator&gt; input_;</span><br><span class="line">  <span class="type">const</span> ColumnDescriptor* descr_;</span><br><span class="line">  std::shared_ptr&lt;RecordReader&gt; record_reader_;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我把 LoadBatch 实现摘出来了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LoadBatch</span><span class="params">(<span class="type">int64_t</span> records_to_read)</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">  BEGIN_PARQUET_CATCH_EXCEPTIONS</span><br><span class="line">  out_ = <span class="literal">nullptr</span>;</span><br><span class="line">  record_reader_-&gt;<span class="built_in">Reset</span>();</span><br><span class="line">  <span class="comment">// Pre-allocation gives much better performance for flat columns</span></span><br><span class="line">  record_reader_-&gt;<span class="built_in">Reserve</span>(records_to_read);</span><br><span class="line">  <span class="keyword">while</span> (records_to_read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!record_reader_-&gt;<span class="built_in">HasMoreData</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int64_t</span> records_read = record_reader_-&gt;<span class="built_in">ReadRecords</span>(records_to_read);</span><br><span class="line">    records_to_read -= records_read;</span><br><span class="line">    <span class="keyword">if</span> (records_read == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">NextRowGroup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">RETURN_NOT_OK</span>(</span><br><span class="line">      <span class="built_in">TransferColumnData</span>(record_reader_.<span class="built_in">get</span>(), field_, descr_, ctx_-&gt;pool, &amp;out_));</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  END_PARQUET_CATCH_EXCEPTIONS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这里会从 <code>record_reader_</code> 里面所要数据，然后切 Page 或者 row_group，直到读完或者满足 batch</li>
<li>利用 <code>TransferColumnData</code> 做转型，然后 <code>BuildArray</code> 没有任何开销</li>
</ol>
<p>它难一点的内部实现都在 <code>RecordReader</code> 了，哎，是真的又恶心又难呢…</p>
<h4 id="List-Struct"><a href="#List-Struct" class="headerlink" title="List / Struct"></a>List / Struct</h4><p>这个会找到一个靠谱的 child，然后从这里面拉 rep-level 和 def-level，来恢复对应的记录</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PARQUET_NO_EXPORT</span> StructReader : <span class="keyword">public</span> ColumnReaderImpl &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">StructReader</span><span class="params">(std::shared_ptr&lt;ReaderContext&gt; ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::shared_ptr&lt;Field&gt; filtered_field,</span></span></span><br><span class="line"><span class="params"><span class="function">                        ::parquet::internal::LevelInfo level_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::vector&lt;std::unique_ptr&lt;ColumnReaderImpl&gt;&gt; children)</span></span></span><br><span class="line"><span class="function">      : ctx_(std::move(ctx)),</span></span><br><span class="line"><span class="function">        filtered_field_(std::move(filtered_field)),</span></span><br><span class="line"><span class="function">        level_info_(level_info),</span></span><br><span class="line"><span class="function">        children_(std::move(children)) &#123;</span></span><br><span class="line">    <span class="comment">// 找到靠谱的记录，来设置一个 `def_rep_level_child_`, 即有 level 的 child.</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">LoadBatch</span><span class="params">(<span class="type">int64_t</span> records_to_read)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归让子节点 build batch</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> std::unique_ptr&lt;ColumnReaderImpl&gt;&amp; reader : children_) &#123;</span><br><span class="line">      <span class="built_in">RETURN_NOT_OK</span>(reader-&gt;<span class="built_in">LoadBatch</span>(records_to_read));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Status <span class="title">BuildArray</span><span class="params">(<span class="type">int64_t</span> length_upper_bound,</span></span></span><br><span class="line"><span class="params"><span class="function">                    std::shared_ptr&lt;ChunkedArray&gt;* out)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">Status <span class="title">GetDefLevels</span><span class="params">(<span class="type">const</span> <span class="type">int16_t</span>** data, <span class="type">int64_t</span>* length)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">Status <span class="title">GetRepLevels</span><span class="params">(<span class="type">const</span> <span class="type">int16_t</span>** data, <span class="type">int64_t</span>* length)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::shared_ptr&lt;Field&gt; <span class="title">field</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> filtered_field_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> std::shared_ptr&lt;ReaderContext&gt; ctx_;</span><br><span class="line">  <span class="type">const</span> std::shared_ptr&lt;Field&gt; filtered_field_;</span><br><span class="line">  <span class="type">const</span> ::parquet::internal::LevelInfo level_info_;</span><br><span class="line">  <span class="type">const</span> std::vector&lt;std::unique_ptr&lt;ColumnReaderImpl&gt;&gt; children_;</span><br><span class="line">  ColumnReaderImpl* def_rep_level_child_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">bool</span> has_repeated_child_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么，我们看 <code>LoadBatch</code> 就 Load 了所有子节点，所以这里重点在 <code>BuildArray</code> 上，这里用到了我们之前看到的 <code>ValidityBitmapInputOutput</code> （我之前吐槽过的，在 <code>RecordReader</code> 那块代码那）。这里搞的到一个叶子结点的 rep-level 和 def-level，然后根据这一个叶子结点的 levels 就能恢复所有的信息，这里有一些解析函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只考虑 def-level, 用于叶子结点.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefLevelsToBitmap</span><span class="params">(<span class="type">const</span> <span class="type">int16_t</span>* def_levels, <span class="type">int64_t</span> num_def_levels,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LevelInfo level_info, ValidityBitmapInputOutput* output)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// It is simpler to rely on rep_level here until PARQUET-1899 is done and the code</span></span><br><span class="line">  <span class="comment">// is deleted in a follow-up release.</span></span><br><span class="line">  <span class="keyword">if</span> (level_info.rep_level &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ARROW_HAVE_RUNTIME_BMI2)</span></span><br><span class="line">    <span class="keyword">if</span> (CpuInfo::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">HasEfficientBmi2</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">DefLevelsToBitmapBmi2WithRepeatedParent</span>(def_levels, num_def_levels,</span><br><span class="line">                                                     level_info, output);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    standard::<span class="built_in">DefLevelsToBitmapSimd</span>&lt;/*has_repeated_parent=*/<span class="literal">true</span>&gt;(</span><br><span class="line">        def_levels, num_def_levels, level_info, output);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    standard::<span class="built_in">DefLevelsToBitmapSimd</span>&lt;<span class="comment">/*has_repeated_parent=*/</span><span class="literal">false</span>&gt;(</span><br><span class="line">        def_levels, num_def_levels, level_info, output);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefRepLevelsToList</span><span class="params">(<span class="type">const</span> <span class="type">int16_t</span>* def_levels, <span class="type">const</span> <span class="type">int16_t</span>* rep_levels,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int64_t</span> num_def_levels, LevelInfo level_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                        ValidityBitmapInputOutput* output, <span class="type">int32_t</span>* offsets)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DefRepLevelsToListInfo</span>&lt;<span class="type">int32_t</span>&gt;(def_levels, rep_levels, num_def_levels, level_info,</span><br><span class="line">                                  output, offsets);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefRepLevelsToList</span><span class="params">(<span class="type">const</span> <span class="type">int16_t</span>* def_levels, <span class="type">const</span> <span class="type">int16_t</span>* rep_levels,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int64_t</span> num_def_levels, LevelInfo level_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                        ValidityBitmapInputOutput* output, <span class="type">int64_t</span>* offsets)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DefRepLevelsToListInfo</span>&lt;<span class="type">int64_t</span>&gt;(def_levels, rep_levels, num_def_levels, level_info,</span><br><span class="line">                                  output, offsets);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 def-rep 来算, 拿到叶子结点的 level 推断父亲的列表.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefRepLevelsToBitmap</span><span class="params">(<span class="type">const</span> <span class="type">int16_t</span>* def_levels, <span class="type">const</span> <span class="type">int16_t</span>* rep_levels,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">int64_t</span> num_def_levels, LevelInfo level_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ValidityBitmapInputOutput* output)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// DefReplevelsToListInfo assumes it for the actual list method and this</span></span><br><span class="line">  <span class="comment">// method is for parent structs, so we need to bump def and ref level.</span></span><br><span class="line">  level_info.rep_level += <span class="number">1</span>;</span><br><span class="line">  level_info.def_level += <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">DefRepLevelsToListInfo</span>&lt;<span class="type">int32_t</span>&gt;(def_levels, rep_levels, num_def_levels, level_info,</span><br><span class="line">                                  output, <span class="comment">/*offsets=*/</span><span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>offsets</code> 参数是给 <code>List</code> 这样内容准备的。不考虑 offset 情况下，struct 对应逻辑：</p>
<ol>
<li>当 <code>rep_levels</code> 比自身大的时候，说明是子节点在重复，skip</li>
<li>如果 rep-level 等于自身，说明在自己这层重复（对结构体是不可能的，所以不考虑）</li>
<li>如果 rep-level 小自身，说明父级重复。这里可以根据 def-level 来判断自己是否是 null</li>
</ol>
<p>我们简单看看，下面的代码删掉了 <code>offsets</code> 和 Struct 不会 touch 的逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OffsetType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefRepLevelsToListInfo</span><span class="params">(<span class="type">const</span> <span class="type">int16_t</span>* def_levels, <span class="type">const</span> <span class="type">int16_t</span>* rep_levels,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">int64_t</span> num_def_levels, LevelInfo level_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ValidityBitmapInputOutput* output, OffsetType* offsets)</span> </span>&#123;</span><br><span class="line">  OffsetType* orig_pos = offsets;</span><br><span class="line">  optional&lt;::arrow::internal::FirstTimeBitmapWriter&gt; valid_bits_writer;</span><br><span class="line">  <span class="keyword">if</span> (output-&gt;valid_bits) &#123;</span><br><span class="line">    valid_bits_writer.<span class="built_in">emplace</span>(output-&gt;valid_bits, output-&gt;valid_bits_offset,</span><br><span class="line">                              output-&gt;values_read_upper_bound);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; num_def_levels; x++) &#123;</span><br><span class="line">    <span class="comment">// Skip items that belong to empty or null ancestor lists and further nested lists.</span></span><br><span class="line">    <span class="keyword">if</span> (def_levels[x] &lt; level_info.repeated_ancestor_def_level ||</span><br><span class="line">        rep_levels[x] &gt; level_info.rep_level) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ARROW_PREDICT_FALSE</span>(</span><br><span class="line">              (valid_bits_writer.<span class="built_in">has_value</span>() &amp;&amp;</span><br><span class="line">               valid_bits_writer-&gt;<span class="built_in">position</span>() &gt;= output-&gt;values_read_upper_bound) ||</span><br><span class="line">              (offsets - orig_pos) &gt;= output-&gt;values_read_upper_bound)) &#123;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;Definition levels exceeded upper bound: &quot;</span></span><br><span class="line">           &lt;&lt; output-&gt;values_read_upper_bound;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ParquetException</span>(ss.<span class="built_in">str</span>());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (valid_bits_writer.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="comment">// the level_info def level for lists reflects element present level.</span></span><br><span class="line">        <span class="comment">// the prior level distinguishes between empty lists.</span></span><br><span class="line">        <span class="keyword">if</span> (def_levels[x] &gt;= level_info.def_level - <span class="number">1</span>) &#123;</span><br><span class="line">          valid_bits_writer-&gt;<span class="built_in">Set</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          output-&gt;null_count++;</span><br><span class="line">          valid_bits_writer-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        valid_bits_writer-&gt;<span class="built_in">Next</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (valid_bits_writer.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    valid_bits_writer-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (offsets != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    output-&gt;values_read = offsets - orig_pos;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valid_bits_writer.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    output-&gt;values_read = valid_bits_writer-&gt;<span class="built_in">position</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (output-&gt;null_count &gt; <span class="number">0</span> &amp;&amp; level_info.null_slot_usage &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">ParquetException</span>(</span><br><span class="line">        <span class="string">&quot;Null values with null_slot_usage &gt; 1 not supported.&quot;</span></span><br><span class="line">        <span class="string">&quot;(i.e. FixedSizeLists with null values are not supported)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那对于 <code>List</code> 来说，我们会需要 <code>offsets</code>，来确定它没每段偏移量是多少。而且 <code>rep-level</code> 可能等于自身，我们再来看看这个函数的完整版（一个函数贴两遍，你水字数是真的牛逼）：</p>
<p>这里注意：</p>
<ol>
<li>当 <code>rep_levels</code> 比自身大的时候，说明是子节点在重复，skip</li>
<li>如果 rep-level 等于自身，说明在自己这层重复，给 list 添加一个元素，<code>*offset += 1</code></li>
<li>如果 rep-level 小自身，说明父级重复。这里向前移动 offsets，可以根据 def-level 来判断自己是否是 null。如果自己不是 null，说明有个新成员，得添加下 offsets</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OffsetType&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DefRepLevelsToListInfo</span><span class="params">(<span class="type">const</span> <span class="type">int16_t</span>* def_levels, <span class="type">const</span> <span class="type">int16_t</span>* rep_levels,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">int64_t</span> num_def_levels, LevelInfo level_info,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ValidityBitmapInputOutput* output, OffsetType* offsets)</span> </span>&#123;</span><br><span class="line">  OffsetType* orig_pos = offsets;</span><br><span class="line">  optional&lt;::arrow::internal::FirstTimeBitmapWriter&gt; valid_bits_writer;</span><br><span class="line">  <span class="keyword">if</span> (output-&gt;valid_bits) &#123;</span><br><span class="line">    valid_bits_writer.<span class="built_in">emplace</span>(output-&gt;valid_bits, output-&gt;valid_bits_offset,</span><br><span class="line">                              output-&gt;values_read_upper_bound);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; num_def_levels; x++) &#123;</span><br><span class="line">    <span class="comment">// Skip items that belong to empty or null ancestor lists and further nested lists.</span></span><br><span class="line">    <span class="keyword">if</span> (def_levels[x] &lt; level_info.repeated_ancestor_def_level ||</span><br><span class="line">        rep_levels[x] &gt; level_info.rep_level) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rep_levels[x] == level_info.rep_level) &#123;</span><br><span class="line">      <span class="comment">// A continuation of an existing list.</span></span><br><span class="line">      <span class="comment">// offsets can be null for structs with repeated children (we don&#x27;t need to know</span></span><br><span class="line">      <span class="comment">// offsets until we get to the children).</span></span><br><span class="line">      <span class="keyword">if</span> (offsets != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ARROW_PREDICT_FALSE</span>(*offsets == std::numeric_limits&lt;OffsetType&gt;::<span class="built_in">max</span>())) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="built_in">ParquetException</span>(<span class="string">&quot;List index overflow.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *offsets += <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ARROW_PREDICT_FALSE</span>(</span><br><span class="line">              (valid_bits_writer.<span class="built_in">has_value</span>() &amp;&amp;</span><br><span class="line">               valid_bits_writer-&gt;<span class="built_in">position</span>() &gt;= output-&gt;values_read_upper_bound) ||</span><br><span class="line">              (offsets - orig_pos) &gt;= output-&gt;values_read_upper_bound)) &#123;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;Definition levels exceeded upper bound: &quot;</span></span><br><span class="line">           &lt;&lt; output-&gt;values_read_upper_bound;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">ParquetException</span>(ss.<span class="built_in">str</span>());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// current_rep &lt; list rep_level i.e. start of a list (ancestor empty lists are</span></span><br><span class="line">      <span class="comment">// filtered out above).</span></span><br><span class="line">      <span class="comment">// offsets can be null for structs with repeated children (we don&#x27;t need to know</span></span><br><span class="line">      <span class="comment">// offsets until we get to the children).</span></span><br><span class="line">      <span class="keyword">if</span> (offsets != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ++offsets;</span><br><span class="line">        <span class="comment">// Use cumulative offsets because variable size lists are more common then</span></span><br><span class="line">        <span class="comment">// fixed size lists so it should be cheaper to make these cumulative and</span></span><br><span class="line">        <span class="comment">// subtract when validating fixed size lists.</span></span><br><span class="line">        *offsets = *(offsets - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (def_levels[x] &gt;= level_info.def_level) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">ARROW_PREDICT_FALSE</span>(*offsets == std::numeric_limits&lt;OffsetType&gt;::<span class="built_in">max</span>())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">ParquetException</span>(<span class="string">&quot;List index overflow.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          *offsets += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (valid_bits_writer.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="comment">// the level_info def level for lists reflects element present level.</span></span><br><span class="line">        <span class="comment">// the prior level distinguishes between empty lists.</span></span><br><span class="line">        <span class="keyword">if</span> (def_levels[x] &gt;= level_info.def_level - <span class="number">1</span>) &#123;</span><br><span class="line">          valid_bits_writer-&gt;<span class="built_in">Set</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          output-&gt;null_count++;</span><br><span class="line">          valid_bits_writer-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        valid_bits_writer-&gt;<span class="built_in">Next</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (valid_bits_writer.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    valid_bits_writer-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (offsets != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    output-&gt;values_read = offsets - orig_pos;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valid_bits_writer.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    output-&gt;values_read = valid_bits_writer-&gt;<span class="built_in">position</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (output-&gt;null_count &gt; <span class="number">0</span> &amp;&amp; level_info.null_slot_usage &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">ParquetException</span>(</span><br><span class="line">        <span class="string">&quot;Null values with null_slot_usage &gt; 1 not supported.&quot;</span></span><br><span class="line">        <span class="string">&quot;(i.e. FixedSizeLists with null values are not supported)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章继续讲了 parquet 的 C++ 标准库怎么读取内容的。简单介绍了一下 文件 — Column 的读取流。<code>Column</code> 下面的编码这篇文章并没有涵盖。如果看不懂的话…感觉也很正常，因为感觉这块代码本身写的质量就…一般般（主要是感觉抽象程度太低了，而且抽的很令人困惑）？不过能把这套东西做出来还是蛮牛逼的，老实说我看着就头疼。这文章看懂能明白大概流程我觉得就很不错了，我也是半当笔记自己写的。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-Parquet-%E4%B8%AD%E7%9A%84%E9%93%BE%E8%B7%AF"><span class="toc-number">1.</span> <span class="toc-text">读取: Parquet 中的链路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TypedRecordReader-%E7%BB%84%E7%BB%87%E6%88%90%E8%BE%93%E5%87%BA%E8%A1%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BE%93%E5%87%BA-Value"><span class="toc-number">1.1.</span> <span class="toc-text">TypedRecordReader: 组织成输出行而不是输出 Value</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parquet-arrow-%E4%BB%8E-arrow-%E6%81%A2%E5%A4%8D-Array-%E6%95%B0%E6%8D%AE"><span class="toc-number">2.</span> <span class="toc-text">parquet&#x2F;arrow: 从 arrow 恢复 Array 数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ColumnReader"><span class="toc-number">2.1.</span> <span class="toc-text">ColumnReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LeafReader"><span class="toc-number">2.2.</span> <span class="toc-text">LeafReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List-Struct"><span class="toc-number">2.3.</span> <span class="toc-text">List &#x2F; Struct</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">总结</span></a>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&text=Parquet Part3: read rep and def levels"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&title=Parquet Part3: read rep and def levels"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&is_video=false&description=Parquet Part3: read rep and def levels"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Parquet Part3: read rep and def levels&body=Check out this article: http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&title=Parquet Part3: read rep and def levels"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&title=Parquet Part3: read rep and def levels"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&title=Parquet Part3: read rep and def levels"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&title=Parquet Part3: read rep and def levels"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&name=Parquet Part3: read rep and def levels&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2022/10/19/Parquet-Part3-read-rep-and-def-levels/&t=Parquet Part3: read rep and def levels"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2025
    mwish
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FL51GBW6JT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FL51GBW6JT');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
