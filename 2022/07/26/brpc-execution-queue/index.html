<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Execution Queue 最早是 brpc 中，多个线程往一个 fd 写数据的时候使用的，这里的需求是：  每个写应该串行的完成 会有并发的写.  Execution Queue 会接受用户投递的任务, 投递完成之后, 用户线程就直接返回了, 然后自己把任务做完, 可能要靠用户的 callback 来通知用户完成. 在内部, 任务会给给投递给它的任务组 batch, 任务 submit 给一">
<meta property="og:type" content="article">
<meta property="og:title" content="brpc bthread execution-queue">
<meta property="og:url" content="http://blog.mwish.me/2022/07/26/brpc-execution-queue/index.html">
<meta property="og:site_name" content="风空之岛">
<meta property="og:description" content="Execution Queue 最早是 brpc 中，多个线程往一个 fd 写数据的时候使用的，这里的需求是：  每个写应该串行的完成 会有并发的写.  Execution Queue 会接受用户投递的任务, 投递完成之后, 用户线程就直接返回了, 然后自己把任务做完, 可能要靠用户的 callback 来通知用户完成. 在内部, 任务会给给投递给它的任务组 batch, 任务 submit 给一">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-25T17:00:00.000Z">
<meta property="article:modified_time" content="2022-07-25T17:03:35.876Z">
<meta property="article:author" content="mwish">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/logo.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico">
        
      
    
    <!-- title -->
    <title>brpc bthread execution-queue</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2022/09/18/Parquet-Part1-Basic/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2022/07/09/Notes-on-Btree-Implements-PostgreSQL/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2022/07/26/brpc-execution-queue/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&text=brpc bthread execution-queue"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&title=brpc bthread execution-queue"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&is_video=false&description=brpc bthread execution-queue"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=brpc bthread execution-queue&body=Check out this article: http://blog.mwish.me/2022/07/26/brpc-execution-queue/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&title=brpc bthread execution-queue"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&title=brpc bthread execution-queue"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&title=brpc bthread execution-queue"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&title=brpc bthread execution-queue"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&name=brpc bthread execution-queue&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&t=brpc bthread execution-queue"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Usage"><span class="toc-number">1.</span> <span class="toc-text">Usage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Execution-Queue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.</span> <span class="toc-text">Execution Queue 的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.2.</span> <span class="toc-text">提交任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%94%A8%E6%88%B7%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E5%88%B0-lock-free-%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%88%B0%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8"><span class="toc-number">2.1.</span> <span class="toc-text">从用户提交任务到 lock-free 的添加到任务列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">2.2.</span> <span class="toc-text">特殊情况：第一次执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">高优先级任务的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%B8%8B%E4%B8%80%E4%B8%AA-batch-%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-number">2.4.</span> <span class="toc-text">组下一个 batch 的逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graceful-shutdown"><span class="toc-number">2.5.</span> <span class="toc-text">Graceful shutdown</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        brpc bthread execution-queue
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">mwish</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-07-25T17:00:00.000Z" itemprop="datePublished">2022-07-26</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>Execution Queue 最早是 brpc 中，多个线程往一个 fd 写数据的时候使用的，这里的需求是：</p>
<ol>
<li>每个写应该串行的完成</li>
<li>会有并发的写.</li>
</ol>
<p>Execution Queue 会接受用户投递的任务, 投递完成之后, 用户线程就直接返回了, 然后自己把任务做完, 可能要靠用户的 callback 来通知用户完成. 在内部, 任务会给给投递给它的任务组 batch, 任务 submit 给一个线程异步 batch 处理.</p>
<p>此外, bthread 的 execution queue 还支持 cancel 任务和调度高优先级的任务.</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p><code>src/bthread/execution_queue.h</code> 描述了如何使用 execution queue, 这些东西也可以在项目<a target="_blank" rel="noopener" href="https://github.com/apache/incubator-brpc/blob/master/docs/cn/execution_queue.md">文档</a>里看到.</p>
<p>这里可以简单介绍一下这个流程，大概要实现一个 Batch 的 <code>demo_execute</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Iterate over the given tasks</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">user_fn</span><span class="params">(T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">demo_execute</span><span class="params">(<span class="type">void</span>* meta, TaskIterator&lt;T&gt;&amp; iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (iter.<span class="built_in">is_queue_stopped</span>()) &#123;</span><br><span class="line">        <span class="comment">// destroy meta and related resources</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; iter; ++iter) &#123;</span><br><span class="line">        <span class="comment">// user_fn(*iter)</span></span><br><span class="line">        <span class="comment">// or user_fn(iter-&gt;a_member_of_T)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>T</code> 是用户定义的 task 需要处理的对象的类型。这个有点绕，因为你还要定义 <code>demo_execute</code> 来处理一个 batch 的任务，和 <code>TaskIterator</code> 交互。举个例子理解下，比如说，对于用户的 IO 写同一个 fd 的任务，brpc 定义了一个 <code>T = butil::IOBuf*</code> 的例子，来处理 IO 相关的需求. 其实这个就很好理解了吧。</p>
<h3 id="Execution-Queue-的生命周期"><a href="#Execution-Queue-的生命周期" class="headerlink" title="Execution Queue 的生命周期"></a>Execution Queue 的生命周期</h3><p>Execution Queue 本身会在 bthread 中执行，bthread 本身是有一堆参数的，queue 会有一堆参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ExecutionQueueOptions</span> &#123;</span><br><span class="line">    <span class="built_in">ExecutionQueueOptions</span>();</span><br><span class="line">    <span class="comment">// Attribute of the bthread which execute runs on</span></span><br><span class="line">    <span class="comment">// default: BTHREAD_ATTR_NORMAL</span></span><br><span class="line">    <span class="type">bthread_attr_t</span> bthread_attr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Executor that tasks run on. bthread will be used when executor = NULL.</span></span><br><span class="line">    <span class="comment">// Note that TaskOptions.in_place_if_possible = false will not work, if implementation of</span></span><br><span class="line">    <span class="comment">// Executor is in-place(synchronous).</span></span><br><span class="line">    Executor * executor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个 <code>Executor</code> 是一个 用户定义的 Executor，用户可以定义在自己的线程池之类的来执行，不过如果用户自己定义了一个 Executor，比如绑了个 folly 的 <code>Executor</code> 然后丢给 folly 执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Start a ExecutionQueue. If |options| is NULL, the queue will be created with</span></span><br><span class="line"><span class="comment">// the default options. </span></span><br><span class="line"><span class="comment">// Returns 0 on success, errno otherwise</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> type |T| can be non-POD but must be copy-constructible</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execution_queue_start</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ExecutionQueueId&lt;T&gt;* id, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> ExecutionQueueOptions* options,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> (*execute)(<span class="type">void</span>* meta, TaskIterator&lt;T&gt;&amp; iter),</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span>* meta)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execution_queue_stop</span><span class="params">(ExecutionQueueId&lt;T&gt; id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execution_queue_join</span><span class="params">(ExecutionQueueId&lt;T&gt; id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面任务有 start, stop, 和 join。基本上是一个完整的流程。<code>ExecutionQueueId&lt;T&gt;</code> 是类似 <code>bthread_id</code> 一样的引用，关于这个结构，其实可以参考 brpc 的 memory-management 文档：<a target="_blank" rel="noopener" href="https://github.com/apache/incubator-brpc/blob/master/docs/cn/memory_management.md">https://github.com/apache/incubator-brpc/blob/master/docs/cn/memory_management.md</a> 。这里基本上是 4B 地址 + 4B 版本号。</p>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>提交任务有下列的 API:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread-safe and Wait-free.</span></span><br><span class="line"><span class="comment">// Execute a task with options. e.g</span></span><br><span class="line"><span class="comment">// bthread::execution_queue_execute(queue, task, &amp;bthread::TASK_OPTIONS_URGENT)</span></span><br><span class="line"><span class="comment">// If |options| is NULL, we will use default options (normal task)</span></span><br><span class="line"><span class="comment">// If |handle| is not NULL, we will assign it with the handler of this task.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execution_queue_execute</span><span class="params">(ExecutionQueueId&lt;T&gt; id, </span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">typename</span> butil::add_const_reference&lt;T&gt;::type task,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> TaskOptions* options)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execution_queue_execute</span><span class="params">(ExecutionQueueId&lt;T&gt; id, </span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">typename</span> butil::add_const_reference&lt;T&gt;::type task,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> TaskOptions* options,</span></span></span><br><span class="line"><span class="params"><span class="function">                            TaskHandle* handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Thread safe and ABA free] Cancel the corresponding task.</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">//  -1: The task was executed or h is an invalid handle</span></span><br><span class="line"><span class="comment">//  0: Success</span></span><br><span class="line"><span class="comment">//  1: The task is executing </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execution_queue_cancel</span><span class="params">(<span class="type">const</span> TaskHandle&amp; h)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里 <code>execution_queue_execute</code> 可以传入一个参数，带上一个 <code>TaskOptions</code>，也可以拿到一个 <code>TaskHandle</code>，这个 handle 可以用来取消任务。下面在 <code>TaskOptions</code> 还有一些执行相关的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskOptions</span> &#123;</span><br><span class="line">    <span class="built_in">TaskOptions</span>();</span><br><span class="line">    <span class="built_in">TaskOptions</span>(<span class="type">bool</span> high_priority, <span class="type">bool</span> in_place_if_possible);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Executor would execute high-priority tasks in the FIFO order but before </span></span><br><span class="line">    <span class="comment">// all pending normal-priority tasks.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> We don&#x27;t guarantee any kind of real-time as there might be tasks still</span></span><br><span class="line">    <span class="comment">// in process which are uninterruptible.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Default: false </span></span><br><span class="line">    <span class="type">bool</span> high_priority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If |in_place_if_possible| is true, execution_queue_execute would call </span></span><br><span class="line">    <span class="comment">// execute immediately instead of starting a bthread if possible</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note: Running callbacks in place might cause the dead lock issue, you</span></span><br><span class="line">    <span class="comment">// should be very careful turning this flag on.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Default: false</span></span><br><span class="line">    <span class="type">bool</span> in_place_if_possible;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">static</span> TaskOptions TASK_OPTIONS_NORMAL = <span class="built_in">TaskOptions</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> TaskOptions TASK_OPTIONS_URGENT = <span class="built_in">TaskOptions</span>(<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> TaskOptions TASK_OPTIONS_INPLACE = <span class="built_in">TaskOptions</span>(<span class="literal">false</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到对应的优先级和 <code>inplace</code> ，<code>inplace</code> 会在前台执行，<code>high_priority</code> 会投递到高优执行，不过这里还满足串行化的语义。</p>
<p>这里 <code>cancel</code> 接口有点让人困惑，没有被执行的任务可以被 <code>cancel</code>，这个得对着代码来理解了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="从用户提交任务到-lock-free-的添加到任务列表"><a href="#从用户提交任务到-lock-free-的添加到任务列表" class="headerlink" title="从用户提交任务到 lock-free 的添加到任务列表"></a>从用户提交任务到 lock-free 的添加到任务列表</h3><p>这里的实现可以在 <code>execution_queue_inl.h</code> 和 <code>execution_queue.cc</code> 里面，关键类型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ExecutionQueueId</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务的状态</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TaskStatus</span> &#123;</span><br><span class="line">    UNEXECUTED = <span class="number">0</span>,</span><br><span class="line">    EXECUTING = <span class="number">1</span>,</span><br><span class="line">    EXECUTED = <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TaskNode</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutionQueueBase</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*clear_task_mem)</span><span class="params">(TaskNode*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BAIDU_CACHELINE_ALIGNMENT</span> TaskNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExecutionQueue</span> : <span class="keyword">public</span> ExecutionQueueBase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskIteratorBase</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskIterator</span> : <span class="keyword">public</span> TaskIteratorBase;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>ExecutionQueue</code> 包了一层 <code>ExecutionQueueBase</code>，<code>ExecutionQueueBase</code> 的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BAIDU_CACHELINE_ALIGNMENT</span> ExecutionQueueBase &#123;</span><br><span class="line"><span class="built_in">DISALLOW_COPY_AND_ASSIGN</span>(ExecutionQueueBase);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Forbidden</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t change the order of _head, _versioned_ref and _stopped unless you </span></span><br><span class="line">    <span class="comment">// see improvement of performance in test</span></span><br><span class="line">    butil::atomic&lt;TaskNode*&gt; BAIDU_CACHELINE_ALIGNMENT _head; <span class="comment">// FIFO 的单队列, 这是队列的尾部, 通过 cas 来 enqueue.</span></span><br><span class="line">    butil::atomic&lt;<span class="type">uint64_t</span>&gt; BAIDU_CACHELINE_ALIGNMENT _versioned_ref; <span class="comment">// 整个对列的 _versioned_ref 计数器, 用来处理 aba 问题.</span></span><br><span class="line">    butil::atomic&lt;<span class="type">bool</span>&gt; BAIDU_CACHELINE_ALIGNMENT _stopped; <span class="comment">// 队列是否被外部停止.</span></span><br><span class="line">    butil::atomic&lt;<span class="type">int64_t</span>&gt; _high_priority_tasks; <span class="comment">// 高优任务计数器, 对列和执行里有任何高优任务都会添加这个计数器.</span></span><br><span class="line">    <span class="type">uint64_t</span> _this_id;</span><br><span class="line">    <span class="type">void</span>* _meta; <span class="comment">// 用户定义的, 绑定到整个 queue 的成员, 作为 execution_func 的参数.</span></span><br><span class="line">    <span class="type">void</span>* _type_specific_function; <span class="comment">// 对应用户的 execution_func</span></span><br><span class="line">    <span class="type">execute_func_t</span> _execute_func; <span class="comment">// 用户提供的执行函数</span></span><br><span class="line">    clear_task_mem _clear_func; <span class="comment">// 清除 Task 上的东西(用户提供) 和 Task 挂的节点的内存.</span></span><br><span class="line">    ExecutionQueueOptions _options;</span><br><span class="line">    butil::atomic&lt;<span class="type">int</span>&gt;* _join_butex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ExecutionQueueBase</code> 被实现成一个类似栈的结构，我也说不清是栈还是队列，因为这个地方 enqueue 类似栈，处理类似队列。</p>
<p>这里的入口是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">execution_queue_execute</span><span class="params">(ExecutionQueueId&lt;T&gt; id, </span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">typename</span> butil::add_const_reference&lt;T&gt;::type task,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> TaskOptions* options,</span></span></span><br><span class="line"><span class="params"><span class="function">                       TaskHandle* handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> ExecutionQueue&lt;T&gt;::<span class="type">scoped_ptr_t</span> </span><br><span class="line">        ptr = ExecutionQueue&lt;T&gt;::<span class="built_in">address</span>(id);</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;<span class="built_in">execute</span>(task, options, handle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以梳理一下执行的链路：</p>
<ol>
<li><code>execution_queue_execute</code> : 用户提交任务到某个 execution queue，派发给 <code>ExecutionQueue&lt;T&gt;</code> 调用 <code>execute</code>，来具体执行</li>
<li>在 <code>ExecutionQueue&lt;T&gt;::execute</code> 中，这里会针对 <code>T</code> 创建对应的 <code>TaskNode</code>，初始化内存和资源，然后投递给 <code>ExecutionQueueBase::start_execute</code></li>
</ol>
<p>那么走到最重要的内容 <code>ExecutionQueueBase</code> 了，刚刚我们看到了，它有个 <code>head_</code> 成员，是个 <code>atomic&lt;TaskNode*&gt;</code>，然后还有 <code>_high_priority_tasks</code> 和 <code>_stopped</code> 表示 “是否有高优操作” 和 “是否被停止”。这两个配置和 <code>start_execute</code> 等函数就是这个结构的核心了。我们接着看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 创建好任务后, 会投递到 start_execute 来处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExecutionQueueBase::start_execute</span><span class="params">(TaskNode* node)</span> </span>&#123;</span><br><span class="line">    node-&gt;next = TaskNode::UNCONNECTED;</span><br><span class="line">    node-&gt;status = UNEXECUTED;</span><br><span class="line">    node-&gt;iterated = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// _high_priority_tasks 是表示正在执行的/等待的任务是否有高优先级任务.</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;high_priority) &#123;</span><br><span class="line">        <span class="comment">// Add _high_priority_tasks before pushing this task into queue to</span></span><br><span class="line">        <span class="comment">// make sure that _execute_tasks sees the newest number when this </span></span><br><span class="line">        <span class="comment">// task is in the queue. Although there might be some useless for </span></span><br><span class="line">        <span class="comment">// loops in _execute_tasks if this thread is scheduled out at this </span></span><br><span class="line">        <span class="comment">// point, we think it&#x27;s just fine.</span></span><br><span class="line">        _high_priority_tasks.<span class="built_in">fetch_add</span>(<span class="number">1</span>, butil::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到上一次的 prev_head, 这个时候, 竞选要求只有 prev_head 是 nullptr 的时候,</span></span><br><span class="line">    <span class="comment">// 才能成为 group 的 leader.</span></span><br><span class="line">    <span class="comment">// 这里如果没有成为 group 的 leader, 会在这里堆积.</span></span><br><span class="line"></span><br><span class="line">    TaskNode* <span class="type">const</span> prev_head = _head.<span class="built_in">exchange</span>(node, butil::memory_order_release);</span><br><span class="line">    <span class="keyword">if</span> (prev_head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next = prev_head;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Group 的 Leader 有权限执行任务.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Get the right to execute the task, start a bthread to avoid deadlock</span></span><br><span class="line">    <span class="comment">// or stack overflow</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 因为是 leader, 它的 next 应该是 null.</span></span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;q = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    ExecutionQueueVars* <span class="type">const</span> vars = <span class="built_in">get_execq_vars</span>();</span><br><span class="line">    vars-&gt;execq_active_count &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;in_place) &#123; <span class="comment">// 如果是 in-place, 那么在本线程(bthread) 执行.</span></span><br><span class="line">        <span class="type">int</span> niterated = <span class="number">0</span>;</span><br><span class="line">        _execute(node, node-&gt;high_priority, &amp;niterated);</span><br><span class="line">        TaskNode* tmp = node;</span><br><span class="line">        <span class="comment">// return if no more</span></span><br><span class="line">        <span class="comment">// 如果是高优任务, 那么处理一下</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;high_priority) &#123;</span><br><span class="line">            _high_priority_tasks.<span class="built_in">fetch_sub</span>(niterated, butil::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有 more_tasks, 切到别的线程执行这个 group.</span></span><br><span class="line">        <span class="keyword">if</span> (!_more_tasks(tmp, &amp;tmp, !node-&gt;iterated)) &#123;</span><br><span class="line">            vars-&gt;execq_active_count &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">            <span class="built_in">return_task_node</span>(node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 executor 来执行, 这个时候执行时候的 `node` 是队首.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == _options.executor) &#123;</span><br><span class="line">        <span class="comment">// 在后台线程中, 使用 _execute_tasks 来执行.</span></span><br><span class="line">        <span class="type">bthread_t</span> tid;</span><br><span class="line">        <span class="comment">// We start the execution thread in background instead of foreground as</span></span><br><span class="line">        <span class="comment">// we can&#x27;t determine whether the code after execute() is urgent (like</span></span><br><span class="line">        <span class="comment">// unlock a pthread_mutex_t) in which case implicit context switch may</span></span><br><span class="line">        <span class="comment">// cause undefined behavior (e.g. deadlock)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 在 background 中执行 (<span class="doctag">TODO:</span> 这个地方会丢进队列吗?)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bthread_start_background</span>(&amp;tid, &amp;_options.bthread_attr,</span><br><span class="line">                                     _execute_tasks, node) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">PLOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Fail to start bthread&quot;</span>;</span><br><span class="line">            _execute_tasks(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// submit 异步执行.</span></span><br><span class="line">        <span class="keyword">if</span> (_options.executor-&gt;<span class="built_in">submit</span>(_execute_tasks, node) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">PLOG</span>(FATAL) &lt;&lt; <span class="string">&quot;Fail to submit task&quot;</span>;</span><br><span class="line">            _execute_tasks(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码比较长，慢慢来：</p>
<ol>
<li>如果是高优任务，添加高优的 counter，执行线程会检测到这个 counter，来做一些特殊处理</li>
<li>通过 <code>_head.exchange(node, butil::memory_order_release)</code> 来向栈中推进内容，<code>_head</code> 为 0 的时候，设置成功的能够成为这个 group 的 leader，在这个 bthread 或者线程下执行，否则返回程序</li>
<li>(从这里开始都是 Leader 的行为) 根据 <code>in_place</code> 等参数，决定就地执行还是异步执行，派发给 <code>_execute_tasks</code></li>
</ol>
<p>在 <code>_execute_tasks</code> 里面有个大循环，每次会把本个 batch 尽量执行完（为什么是尽量呢，接着看）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 调用 execute 来执行对应的任务, 这是一个 static 函数, 需要合理处理高优先级任务.</span></span><br><span class="line"><span class="type">void</span>* ExecutionQueueBase::_execute_tasks(<span class="type">void</span>* arg) &#123;</span><br><span class="line">    ExecutionQueueVars* vars = <span class="built_in">get_execq_vars</span>();</span><br><span class="line">    TaskNode* head = (TaskNode*)arg;</span><br><span class="line">    ExecutionQueueBase* m = (ExecutionQueueBase*)head-&gt;q;</span><br><span class="line">    TaskNode* cur_tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> destroy_queue = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果队列头已经执行过, 那么切一个队列头(move next), 然后把之前的队列头</span></span><br><span class="line">        <span class="comment">// 处理.</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;iterated) &#123;</span><br><span class="line">            <span class="built_in">CHECK</span>(head-&gt;next != <span class="literal">NULL</span>);</span><br><span class="line">            TaskNode* saved_head = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            m-&gt;<span class="built_in">return_task_node</span>(saved_head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果有高优先级任务, 调用 _execute 直接处理高优任务, 如果没有高优任务, 调度走等待</span></span><br><span class="line">        <span class="comment">//  投递进来继续组 batch.</span></span><br><span class="line">        <span class="keyword">if</span> (m-&gt;_high_priority_tasks.<span class="built_in">load</span>(butil::memory_order_relaxed) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> nexecuted = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// Don&#x27;t care the return value (因为不会执行到 stop).</span></span><br><span class="line">            rc = m-&gt;_execute(head, <span class="literal">true</span>, &amp;nexecuted);</span><br><span class="line">            <span class="comment">// 减少对应的高优任务数量</span></span><br><span class="line">            m-&gt;_high_priority_tasks.<span class="built_in">fetch_sub</span>(</span><br><span class="line">                    nexecuted, butil::memory_order_relaxed);</span><br><span class="line">            <span class="comment">// 如果 nexecuted == 0, 调度走, 等待任务被塞到执行队列.</span></span><br><span class="line">            <span class="keyword">if</span> (nexecuted == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Some high_priority tasks are not in queue</span></span><br><span class="line">                <span class="built_in">sched_yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有高优任务, 执行现有的这批.</span></span><br><span class="line">            rc = m-&gt;_execute(head, <span class="literal">false</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否收到 stop 对象.</span></span><br><span class="line">        <span class="keyword">if</span> (rc == ESTOP) &#123;</span><br><span class="line">            destroy_queue = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Release TaskNode until uniterated task or last task</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 释放掉现在所有的执行过的内容, 不过这里只是连续释放, 直到有 uniterated 的对象.</span></span><br><span class="line">        <span class="keyword">while</span> (head-&gt;next != <span class="literal">NULL</span> &amp;&amp; head-&gt;iterated) &#123;</span><br><span class="line">            TaskNode* saved_head = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            m-&gt;<span class="built_in">return_task_node</span>(saved_head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这个 batch 的尾部.</span></span><br><span class="line">        <span class="keyword">if</span> (cur_tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (cur_tail = head; cur_tail-&gt;next != <span class="literal">NULL</span>; </span><br><span class="line">                    cur_tail = cur_tail-&gt;next) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// break when no more tasks and head has been executed</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 把加进来的和已有的组成一个新的 Batch, cur_tail 和 &amp;cur_tail 这个有点让人困惑, 因为队列要满足 FIFO 条件,</span></span><br><span class="line">        <span class="comment">// 投递进来的原本是 T3-&gt;T2-&gt;T1. 在第一个 batch 里面, T1 设置到了 head = NULL 到 head = T1, 所以 T1 是</span></span><br><span class="line">        <span class="comment">// leader, 这个时候, cur_tail == T1. old_head == T1, new_tail = &amp;T1(即 head).</span></span><br><span class="line">        <span class="comment">// 再次执行完的时候, 这个队列会变成 T3-&gt;T2, 但是执行顺序是 T2-&gt;T3, 所以, old_head 对应 T2, new_tail 也应该传入</span></span><br><span class="line">        <span class="comment">// T2.</span></span><br><span class="line">        <span class="comment">// 本来这里没有问题, 但是可能 has_uniterated == true, 需要缝合两个队列.</span></span><br><span class="line">        <span class="keyword">if</span> (!m-&gt;_more_tasks(cur_tail, &amp;cur_tail, !head-&gt;iterated)) &#123;</span><br><span class="line">            <span class="built_in">CHECK_EQ</span>(cur_tail, head);</span><br><span class="line">            <span class="built_in">CHECK</span>(head-&gt;iterated);</span><br><span class="line">            m-&gt;<span class="built_in">return_task_node</span>(head);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (destroy_queue) &#123;</span><br><span class="line">        <span class="built_in">CHECK</span>(m-&gt;_head.<span class="built_in">load</span>(butil::memory_order_relaxed) == <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">CHECK</span>(m-&gt;_stopped);</span><br><span class="line">        <span class="comment">// Add _join_butex by 2 to make it equal to the next version of the</span></span><br><span class="line">        <span class="comment">// ExecutionQueue from the same slot so that join with old id would</span></span><br><span class="line">        <span class="comment">// return immediately.</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// 1: release fence to make join sees the newest changes when it sees</span></span><br><span class="line">        <span class="comment">//    the newest _join_butex</span></span><br><span class="line">        m-&gt;_join_butex-&gt;<span class="built_in">fetch_add</span>(<span class="number">2</span>, butil::memory_order_release<span class="comment">/*1*/</span>);</span><br><span class="line">        <span class="built_in">butex_wake_all</span>(m-&gt;_join_butex);</span><br><span class="line">        vars-&gt;execq_count &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">        butil::<span class="built_in">return_resource</span>(<span class="built_in">slot_of_id</span>(m-&gt;_this_id));</span><br><span class="line">    &#125;</span><br><span class="line">    vars-&gt;execq_active_count &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个地方逻辑如下：</p>
<ol>
<li>处理已经迭代完的内容, 这里涉及 stop 之类的逻辑</li>
<li>调用 <code>_execute</code> 函数，来具体执行这个 batch</li>
<li>看看有没有没执行完的任务和最新的任务，走 <code>_more_tasks</code></li>
</ol>
<p>看客这个地方可能会怪我全部贴代码了，不过这个地方流程确实只能硬贴。因为 (2) (3) 都是有巨坑的</p>
<h3 id="特殊情况：第一次执行"><a href="#特殊情况：第一次执行" class="headerlink" title="特殊情况：第一次执行"></a>特殊情况：第一次执行</h3><p>还记得 <code>_head.exchange</code> 不，这个地方第一次设置成功的 <code>Node</code> 的 <code>next</code> 是 <code>nullptr</code>，第一次执行的时候，整个 batch 只有它一个成员。</p>
<h3 id="高优先级任务的处理"><a href="#高优先级任务的处理" class="headerlink" title="高优先级任务的处理"></a>高优先级任务的处理</h3><p>我们看到，<code>start_execute</code> 的时候，这里如果是高优任务，就会添加高优的 counter，在 <code>_execute_tasks</code> 的循环里，我们看到这里检查了高优任务:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果有高优先级任务, 调用 _execute 直接处理高优任务, 如果没有高优任务, 调度走等待</span></span><br><span class="line"><span class="comment">//  投递进来继续组 batch.</span></span><br><span class="line"><span class="keyword">if</span> (m-&gt;_high_priority_tasks.<span class="built_in">load</span>(butil::memory_order_relaxed) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> nexecuted = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Don&#x27;t care the return value (因为不会执行到 stop).</span></span><br><span class="line">    rc = m-&gt;_execute(head, <span class="literal">true</span>, &amp;nexecuted);</span><br><span class="line">    <span class="comment">// 减少对应的高优任务数量</span></span><br><span class="line">    m-&gt;_high_priority_tasks.<span class="built_in">fetch_sub</span>(</span><br><span class="line">            nexecuted, butil::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 如果 nexecuted == 0, 调度走, 等待任务被塞到执行队列.</span></span><br><span class="line">    <span class="keyword">if</span> (nexecuted == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Some high_priority tasks are not in queue</span></span><br><span class="line">        <span class="built_in">sched_yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有高优任务, 执行现有的这批.</span></span><br><span class="line">    rc = m-&gt;_execute(head, <span class="literal">false</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看看 <code>_execute</code> 函数的签名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ExecutionQueueBase::_execute(TaskNode* head, <span class="type">bool</span> high_priority, <span class="type">int</span>* niterated);</span><br></pre></td></tr></table></figure>
<p>这里可以看到，<code>_execute</code> 里面有个 <code>high_priority</code> 的标记，这个是用来干什么的呢？我们这里介绍一下，一个 Batch 只能执行一种优先级的任务，要么高要么低。如果插入了一个高优任务，它要尽量在低优先级任务之前被执行。这里可以想象一下提供给用户的模型：</p>
<ul>
<li>有两个队列，一个低优一个高优</li>
<li>executor 并非是「Batch 执行」，它是串行执行的，从高优看看有没有，有就执行，否则从低优队列取<strong>一个</strong>任务执行</li>
</ul>
<p>可以看到，这里是一个非 batch 执行的语义，这个 <code>_execute</code> 靠计数器实现了类似的语义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体执行的逻辑, start_execute -&gt; execute_task -&gt; execute.</span></span><br><span class="line"><span class="type">int</span> ExecutionQueueBase::_execute(TaskNode* head, <span class="type">bool</span> high_priority, <span class="type">int</span>* niterated) &#123;</span><br><span class="line">    <span class="comment">// 如果是一个 stop task, 那么具体执行</span></span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;stop_task) &#123;</span><br><span class="line">        <span class="built_in">CHECK</span>(head-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">        head-&gt;iterated = <span class="literal">true</span>; <span class="comment">// 设置自身为 executed.</span></span><br><span class="line">        head-&gt;status = EXECUTED;</span><br><span class="line">        <span class="comment">// 如果是 stop, 那么这里 `high_priority == false`.</span></span><br><span class="line">        <span class="function">TaskIteratorBase <span class="title">iter</span><span class="params">(<span class="literal">NULL</span>, <span class="keyword">this</span>, <span class="literal">true</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        _execute_func(_meta, _type_specific_function, iter);</span><br><span class="line">        <span class="keyword">if</span> (niterated) &#123;</span><br><span class="line">            *niterated = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ESTOP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TaskIteratorBase <span class="title">iter</span><span class="params">(head, <span class="keyword">this</span>, <span class="literal">false</span>, high_priority)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (iter) &#123;</span><br><span class="line">        _execute_func(_meta, _type_specific_function, iter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We must assign |niterated| with num_iterated even if we couldn&#x27;t peek</span></span><br><span class="line">    <span class="comment">// any task to execute at the beginning, in which case all the iterated</span></span><br><span class="line">    <span class="comment">// tasks have been cancelled at this point. And we must return the </span></span><br><span class="line">    <span class="comment">// correct num_iterated() to the caller to update the counter correctly.</span></span><br><span class="line">    <span class="keyword">if</span> (niterated) &#123;</span><br><span class="line">        *niterated = iter.<span class="built_in">num_iterated</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里比较重要的实现在 <code>TaskIteratorBase</code> 里面，这个类型实现了根据优先级来判断是否要迭代的逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递给 execute 函数的迭代器.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskIteratorBase</span> &#123;</span><br><span class="line"><span class="built_in">DISALLOW_COPY_AND_ASSIGN</span>(TaskIteratorBase);</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ExecutionQueueBase</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Returns true when the ExecutionQueue is stopped and there will never be</span></span><br><span class="line">    <span class="comment">// more tasks and you can safely release all the related resources ever </span></span><br><span class="line">    <span class="comment">// after.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_queue_stopped</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _is_stopped; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">TaskIteratorBase</span>(TaskNode* head, ExecutionQueueBase* queue,</span><br><span class="line">                     <span class="type">bool</span> is_stopped, <span class="type">bool</span> high_priority)</span><br><span class="line">        : _cur_node(head)</span><br><span class="line">        , _head(head)</span><br><span class="line">        , _q(queue)</span><br><span class="line">        , _is_stopped(is_stopped)</span><br><span class="line">        , _high_priority(high_priority)</span><br><span class="line">        , _should_break(<span class="literal">false</span>)</span><br><span class="line">        , _num_iterated(<span class="number">0</span>)</span><br><span class="line">    &#123; <span class="keyword">operator</span>++(); &#125;</span><br><span class="line">    ~<span class="built_in">TaskIteratorBase</span>();</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>++();</span><br><span class="line">    <span class="function">TaskNode* <span class="title">cur_node</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _cur_node; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num_iterated</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _num_iterated; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">should_break_for_high_priority_tasks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    TaskNode*               _cur_node;</span><br><span class="line">    TaskNode*               _head;</span><br><span class="line">    ExecutionQueueBase*     _q; <span class="comment">// 绑定的整个 queue 的对象.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注: 如果 _is_stopped == true, _high_pri 必定为 false.</span></span><br><span class="line">    <span class="type">bool</span>                    _is_stopped;</span><br><span class="line">    <span class="type">bool</span>                    _high_priority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是内部的逻辑.</span></span><br><span class="line">    <span class="type">bool</span>                    _should_break;</span><br><span class="line">    <span class="type">int</span>                     _num_iterated;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个的重点逻辑在 <code>should_break_for_high_priority_tasks</code> 里面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有高优任务需要插队.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">TaskIteratorBase::should_break_for_high_priority_tasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_high_priority &amp;&amp; </span><br><span class="line">            _q-&gt;_high_priority_tasks.<span class="built_in">load</span>(butil::memory_order_relaxed) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _should_break = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> TaskIteratorBase::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(*<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经 iter 的任务不用再处理.</span></span><br><span class="line">    <span class="keyword">if</span> (_cur_node-&gt;iterated) &#123;</span><br><span class="line">        _cur_node = _cur_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有高优任务需要插队的时候, 需要暂时 break 掉, 等待高优先级任务执行.</span></span><br><span class="line">    <span class="comment">// 如果迭代中发现有高优先级任务, 那么这里不再会执行任一个 task.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">should_break_for_high_priority_tasks</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  <span class="comment">// else the next high_priority_task would be delayed for at most one task</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有高优先级任务, 然后不是 stop.</span></span><br><span class="line">    <span class="keyword">while</span> (_cur_node &amp;&amp; !_cur_node-&gt;stop_task) &#123;</span><br><span class="line">        <span class="comment">// 如果优先级等同, 那么执行: 如果有高优先级的, 低优先级的不会被执行</span></span><br><span class="line">        <span class="keyword">if</span> (_high_priority == _cur_node-&gt;high_priority) &#123;</span><br><span class="line">            <span class="comment">// 如果没有 iterated, 那么捞出来设置一下状态, 然后返回.</span></span><br><span class="line">            <span class="keyword">if</span> (!_cur_node-&gt;iterated &amp;&amp; _cur_node-&gt;<span class="built_in">peek_to_execute</span>()) &#123;</span><br><span class="line">                ++_num_iterated;</span><br><span class="line">                _cur_node-&gt;iterated = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _num_iterated += !_cur_node-&gt;iterated;</span><br><span class="line">            _cur_node-&gt;iterated = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取下一个可执行的任务。</span></span><br><span class="line">        _cur_node = _cur_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组下一个-batch-的逻辑"><a href="#组下一个-batch-的逻辑" class="headerlink" title="组下一个 batch 的逻辑"></a>组下一个 batch 的逻辑</h3><p>组下一个 batch 的逻辑在 <code>_more_tasks</code> 中，但我们必须联动上一节，假设某个 Batch:</p>
<ol>
<li>执行低优任务，有五个任务，执行了三个发现有高优任务插队了</li>
<li>执行高优任务，有10个任务，但是只有一个高优任务</li>
</ol>
<p>这个时候，组 batch 的时候，可能自己手头上的 batch 还没执行完，用户又提交了，这就涉及到两个 batch 缝合，我们先看调用 <code>_more_tasks</code> 的地方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Release TaskNode until uniterated task or last task</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 释放掉现在所有的执行过的内容, 不过这里只是连续释放, 直到有 uniterated 的对象.</span></span><br><span class="line"><span class="keyword">while</span> (head-&gt;next != <span class="literal">NULL</span> &amp;&amp; head-&gt;iterated) &#123;</span><br><span class="line">    TaskNode* saved_head = head;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    m-&gt;<span class="built_in">return_task_node</span>(saved_head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到这个 batch 的尾部.</span></span><br><span class="line"><span class="keyword">if</span> (cur_tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (cur_tail = head; cur_tail-&gt;next != <span class="literal">NULL</span>; </span><br><span class="line">            cur_tail = cur_tail-&gt;next) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// break when no more tasks and head has been executed</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 把加进来的和已有的组成一个新的 Batch, cur_tail 和 &amp;cur_tail 这个有点让人困惑, 因为队列要满足 FIFO 条件,</span></span><br><span class="line"><span class="comment">// 投递进来的原本是 T3-&gt;T2-&gt;T1. 在第一个 batch 里面, T1 设置到了 head = NULL 到 head = T1, 所以 T1 是</span></span><br><span class="line"><span class="comment">// leader, 这个时候, cur_tail == T1. old_head == T1, new_tail = &amp;T1(即 head).</span></span><br><span class="line"><span class="comment">// 再次执行完的时候, 这个队列会变成 T3-&gt;T2, 但是执行顺序是 T2-&gt;T3, 所以, old_head 对应 T2, new_tail 也应该传入</span></span><br><span class="line"><span class="comment">// T2.</span></span><br><span class="line"><span class="comment">// 本来这里没有问题, 但是可能 has_uniterated == true, 需要缝合两个队列.</span></span><br><span class="line"><span class="keyword">if</span> (!m-&gt;_more_tasks(cur_tail, &amp;cur_tail, !head-&gt;iterated)) &#123;</span><br><span class="line">    <span class="built_in">CHECK_EQ</span>(cur_tail, head);</span><br><span class="line">    <span class="built_in">CHECK</span>(head-&gt;iterated);</span><br><span class="line">    m-&gt;<span class="built_in">return_task_node</span>(head);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里根据任务有没有执行完，设置了不同的 <code>cur_tail</code> 来处理。然后我们看 <code>_more_tasks</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> ExecutionQueueBase::_more_tasks(</span><br><span class="line">        TaskNode* old_head, TaskNode** new_tail, </span><br><span class="line">        <span class="type">bool</span> has_uniterated) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CHECK</span>(old_head-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// Try to set _head to NULL to mark that the execution is done.</span></span><br><span class="line">    TaskNode* new_head = old_head;</span><br><span class="line">    TaskNode* desired = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> return_when_no_more = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (has_uniterated) &#123; <span class="comment">// desired 设置到 old_head, 方便组 batch.</span></span><br><span class="line">        desired = old_head;</span><br><span class="line">        return_when_no_more = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// _head 和 old_head 如果相等, 就把 desired 设置给 _head. 只有没有新任务来的时候, 会相等.</span></span><br><span class="line">    <span class="comment">// desired 在迭代完全的时候, 会是 NULL, 这个时候队列也设置为空; 否则设置为这次迭代的尾部, 允许别人再 append.</span></span><br><span class="line">    <span class="comment">// 失败的时候, 新的 _head 会被加载到 `new_head` 中.</span></span><br><span class="line">    <span class="keyword">if</span> (_head.<span class="built_in">compare_exchange_strong</span>(</span><br><span class="line">                new_head, desired, butil::memory_order_acquire)) &#123;</span><br><span class="line">        <span class="comment">// No one added new tasks.</span></span><br><span class="line">        <span class="comment">// 没有新任务, 这里返回本队列是否迭代完成.</span></span><br><span class="line">        <span class="keyword">return</span> return_when_no_more;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CHECK_NE</span>(new_head, old_head);</span><br><span class="line">    <span class="comment">// Above acquire fence pairs release fence of exchange in Write() to make</span></span><br><span class="line">    <span class="comment">// sure that we see all fields of requests set.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Someone added new requests.</span></span><br><span class="line">    <span class="comment">// Reverse the list until old_head.</span></span><br><span class="line">    TaskNode* tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (new_tail) &#123;</span><br><span class="line">        *new_tail = new_head;</span><br><span class="line">    &#125;</span><br><span class="line">    TaskNode* p = new_head;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(mwish): 这个地方和 enqueue 有并发, 没有问题吗.</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next == TaskNode::UNCONNECTED) &#123;</span><br><span class="line">            <span class="comment">// TODO(gejun): elaborate this</span></span><br><span class="line">            <span class="built_in">sched_yield</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        TaskNode* <span class="type">const</span> saved_next = p-&gt;next;</span><br><span class="line">        p-&gt;next = tail;</span><br><span class="line">        tail = p;</span><br><span class="line">        p = saved_next;</span><br><span class="line">        <span class="built_in">CHECK</span>(p != <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != old_head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Link old list with new list.</span></span><br><span class="line">    old_head-&gt;next = tail;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会把两个 queue 拼成一个，大概逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">正在执行的 Queue: T1(done)-&gt;T2(done)-&gt;T3(undone, head)</span><br><span class="line">head_ 有关的结构: (head)T6-&gt;T5-&gt;T4-&gt;T3-&gt;T2-&gt;T1</span><br><span class="line"></span><br><span class="line">回收空间，正在执行的 Queue: T3(undone, head)</span><br><span class="line">head_ 有关的结构: (head)T6-&gt;T5-&gt;T4-&gt;T3-&gt;T2-&gt;T1</span><br><span class="line"></span><br><span class="line">拼接后, queue 有关的结构: T3-&gt;T4-&gt;T5-&gt;T6</span><br><span class="line">head_ 有关的结构: (head)T6-&gt;T5-&gt;T4-&gt;T3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的执行流程如下</p>
<ol>
<li>对已经执行的 Task 的资源回收，调用 <code>ExecutionQueueBase::return_task_node</code>，在 <code>_more_tasks</code> 之前回首掉</li>
<li>会组好 Batch，然后等待下一次执行。这里会如上图一样拼接</li>
<li>如果没有更多的任务，可能会回收 <code>head</code>s</li>
</ol>
<h3 id="Graceful-shutdown"><a href="#Graceful-shutdown" class="headerlink" title="Graceful shutdown"></a>Graceful shutdown</h3><p>对于一个关闭的 queue，首先，投递的任务会失败：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (在 class ExecutionQueue&lt;T&gt; 里面)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execute</span><span class="params">(<span class="keyword">typename</span> butil::add_const_reference&lt;T&gt;::type task,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> TaskOptions* options, TaskHandle* handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stopped</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，这里有一套引用计数机制，来保证持有的地方不会失效：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ExecutionQueueBase::<span class="type">scoped_ptr_t</span> <span class="title">ExecutionQueueBase::address</span><span class="params">(<span class="type">uint64_t</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当引用计数差不多得了的时候，这里会投递一些关闭的 flag，调用 <code>_on_recycle</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> ExecutionQueueBase::_on_recycle() &#123;</span><br><span class="line">    <span class="comment">// Push a closed tasks</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        TaskNode* node = butil::<span class="built_in">get_object</span>&lt;TaskNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">BAIDU_LIKELY</span>(node != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="built_in">get_execq_vars</span>()-&gt;running_task_count &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            node-&gt;stop_task = <span class="literal">true</span>;</span><br><span class="line">            node-&gt;high_priority = <span class="literal">false</span>;</span><br><span class="line">            node-&gt;in_place = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">start_execute</span>(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CHECK</span>(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Fail to create task_node_t, &quot;</span> &lt;&lt; <span class="built_in">berror</span>();</span><br><span class="line">        ::<span class="built_in">bthread_usleep</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Usage"><span class="toc-number">1.</span> <span class="toc-text">Usage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Execution-Queue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.</span> <span class="toc-text">Execution Queue 的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.2.</span> <span class="toc-text">提交任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%94%A8%E6%88%B7%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E5%88%B0-lock-free-%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%88%B0%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8"><span class="toc-number">2.1.</span> <span class="toc-text">从用户提交任务到 lock-free 的添加到任务列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%9A%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">2.2.</span> <span class="toc-text">特殊情况：第一次执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">高优先级任务的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%B8%8B%E4%B8%80%E4%B8%AA-batch-%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-number">2.4.</span> <span class="toc-text">组下一个 batch 的逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graceful-shutdown"><span class="toc-number">2.5.</span> <span class="toc-text">Graceful shutdown</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2022/07/26/brpc-execution-queue/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&text=brpc bthread execution-queue"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&title=brpc bthread execution-queue"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&is_video=false&description=brpc bthread execution-queue"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=brpc bthread execution-queue&body=Check out this article: http://blog.mwish.me/2022/07/26/brpc-execution-queue/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&title=brpc bthread execution-queue"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&title=brpc bthread execution-queue"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&title=brpc bthread execution-queue"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&title=brpc bthread execution-queue"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&name=brpc bthread execution-queue&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2022/07/26/brpc-execution-queue/&t=brpc bthread execution-queue"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2024
    mwish
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FL51GBW6JT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FL51GBW6JT');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
