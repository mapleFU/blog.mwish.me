<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Velox 最初是一个 Facebook 为 Presto 做的一个 C++ Runtime，而为了扩大这套东西的使用价值，FB 开源了这套东西，现在这套东西可以给 Spark(Gluten), Presto 这样使用。Meta 对其的定义是个单机的计算库。详见论文 (1) (2) 和之前的 blog:  Intro to Velox: https:&#x2F;&#x2F;blog.mwish.me&#x2F;2022&#x2F;11&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Expression Execution in Velox Part 1: Basics and UDF">
<meta property="og:url" content="http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/index.html">
<meta property="og:site_name" content="风空之岛">
<meta property="og:description" content="Velox 最初是一个 Facebook 为 Presto 做的一个 C++ Runtime，而为了扩大这套东西的使用价值，FB 开源了这套东西，现在这套东西可以给 Spark(Gluten), Presto 这样使用。Meta 对其的定义是个单机的计算库。详见论文 (1) (2) 和之前的 blog:  Intro to Velox: https:&#x2F;&#x2F;blog.mwish.me&#x2F;2022&#x2F;11&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.mwish.me/blog-image/8009906994513327979.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/7112639785417370175.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/876913957418889513.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/6424380886371214072.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/8120608020549370653.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/4028683123846054944.png">
<meta property="article:published_time" content="2024-01-23T17:47:49.000Z">
<meta property="article:modified_time" content="2024-01-23T17:52:01.877Z">
<meta property="article:author" content="mwish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.mwish.me/blog-image/8009906994513327979.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/logo.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico">
        
      
    
    <!-- title -->
    <title>Expression Execution in Velox Part 1: Basics and UDF</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/01/20/PolarDB-IMCI-Row-Column-in-RO-node/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&text=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&title=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&is_video=false&description=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Expression Execution in Velox Part 1: Basics and UDF&body=Check out this article: http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&title=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&title=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&title=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&title=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&name=Expression Execution in Velox Part 1: Basics and UDF&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&t=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">数据类型和基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Type"><span class="toc-number">1.1.</span> <span class="toc-text">Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#From-Buffer-to-FlatVector"><span class="toc-number">1.2.</span> <span class="toc-text">From Buffer to FlatVector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selection-and-Rows"><span class="toc-number">1.3.</span> <span class="toc-text">Selection and Rows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DecodedVector"><span class="toc-number">1.4.</span> <span class="toc-text">DecodedVector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EvalCtx"><span class="toc-number">1.6.</span> <span class="toc-text">EvalCtx</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VectorFunction-and-SimpleFunctionAdapter"><span class="toc-number">2.</span> <span class="toc-text">VectorFunction and SimpleFunctionAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E7%9A%84%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">可选的优化参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Apply-%E6%89%A7%E8%A1%8C%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">2.2.</span> <span class="toc-text">Apply 执行的路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-number">3.</span> <span class="toc-text">References</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Expression Execution in Velox Part 1: Basics and UDF
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">mwish</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-01-23T17:47:49.000Z" itemprop="datePublished">2024-01-24</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>Velox 最初是一个 Facebook 为 Presto 做的一个 C++ Runtime，而为了扩大这套东西的使用价值，FB 开源了这套东西，现在这套东西可以给 Spark(Gluten), Presto 这样使用。Meta 对其的定义是个单机的计算库。详见论文 (1) (2) 和之前的 blog:</p>
<ul>
<li>Intro to Velox: <a href="https://blog.mwish.me/2022/11/13/Introduction-to-velox/">https://blog.mwish.me/2022/11/13/Introduction-to-velox/</a> </li>
<li>Type and Array in Columnar System <a href="https://blog.mwish.me/2023/05/04/Type-and-Array-in-Columnar-System/#Velox">https://blog.mwish.me/2023/05/04/Type-and-Array-in-Columnar-System/#Velox</a></li>
</ul>
<p>这里希望介绍 Velox 的表达式计算 Expr Evaluation。可能一篇文章介绍不完，所以本文应该只尝试介绍 <code>Expr::eval</code> 的链路。篇幅所限，本文应该也不会直接介绍 <code>SpecialForm</code> 的 Expr 的代码（if, cast, try, switch），但是会涉及它们里面的一些概念，要不然这里其实很多地方没法讲下去了。</p>
<p>这篇博文大概内容如下：</p>
<ol>
<li>简短介绍 Velox 这几块涉及的类型。</li>
<li>介绍 UDF 定义和怎么扩展到 VectorFunction 的，以及 SimpleFunction UDF 执行链路的优化</li>
<li>介绍 Expr 的基本执行链路</li>
</ol>
<p>（3）会在 Part 2 中介绍。</p>
<h2 id="数据类型和基本概念"><a href="#数据类型和基本概念" class="headerlink" title="数据类型和基本概念"></a><strong>数据类型和基本概念</strong></h2><p>这一部分的概念出自</p>
<ol>
<li><a href="https://blog.mwish.me/2023/05/04/Type-and-Array-in-Columnar-System/#Velox">https://blog.mwish.me/2023/05/04/Type-and-Array-in-Columnar-System/#Velox</a> </li>
<li><a target="_blank" rel="noopener" href="https://facebookincubator.github.io/velox/develop/types.html">https://facebookincubator.github.io/velox/develop/types.html</a></li>
<li><a target="_blank" rel="noopener" href="https://facebookincubator.github.io/velox/develop/vectors.html">https://facebookincubator.github.io/velox/develop/vectors.html</a></li>
</ol>
<h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a><strong>Type</strong></h3><p>Velox 中每个数据都有对应的类型. 列表如下：</p>
<p><img src="https://image.mwish.me/blog-image/8009906994513327979.png" alt="img"></p>
<p>此外还有一个 Function 类型。为什么 Function 需要一个类型呢？因为在执行 Lambda 的时候可能需要把函数当成一个参数传进去。</p>
<p>上述的类型是物理类型，这里还有 LogicalType</p>
<p><img src="https://image.mwish.me/blog-image/7112639785417370175.png" alt="img"></p>
<p>这里有个比较有趣的类型是 <code>TypeParameter</code>，比如说 Decimal 肯定得有两个参数 <code>Decimal(precision, scale)</code>, 然后时间也有对应的单位或者是否 adjustToUtc。这些封装成了 TypeParameter，便于存储访问。e.g.:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This class represents the fixed-point numbers.</span></span><br><span class="line"><span class="comment">/// The parameter &quot;precision&quot; represents the number of digits the</span></span><br><span class="line"><span class="comment">/// Decimal Type can support and &quot;scale&quot; represents the number of digits to the</span></span><br><span class="line"><span class="comment">/// right of the decimal point.</span></span><br><span class="line"><span class="keyword">template</span> &lt;TypeKind KIND&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalType</span> : <span class="keyword">public</span> ScalarType&lt;KIND&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">uint8_t</span> <span class="title">precision</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parameters_[<span class="number">0</span>].longLiteral.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">uint8_t</span> <span class="title">scale</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parameters_[<span class="number">1</span>].longLiteral.<span class="built_in">value</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> std::vector&lt;TypeParameter&gt; parameters_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShortDecimalType</span> : <span class="keyword">public</span> DecimalType&lt;TypeKind::BIGINT&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ShortDecimalType</span>(<span class="type">int</span> precision, <span class="type">int</span> scale)</span><br><span class="line">      : <span class="built_in">DecimalType</span>&lt;TypeKind::BIGINT&gt;(precision, scale) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LongDecimalType</span> : <span class="keyword">public</span> DecimalType&lt;TypeKind::HUGEINT&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LongDecimalType</span>(<span class="type">int</span> precision, <span class="type">int</span> scale)</span><br><span class="line">      : <span class="built_in">DecimalType</span>&lt;TypeKind::HUGEINT&gt;(precision, scale) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TypePtr <span class="title">DECIMAL</span><span class="params">(<span class="type">uint8_t</span> precision, <span class="type">uint8_t</span> scale)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里还有对应的复杂类型，<code>ARRAY</code>, <code>MAP</code>, <code>ROW</code> （Row 可以当成是 STRUCT）。</p>
<p>不同于 Arrow，字典之类的并不作为一种「类型」，而是作为一种 encoding。</p>
<h3 id="From-Buffer-to-FlatVector"><a href="#From-Buffer-to-FlatVector" class="headerlink" title="From Buffer to FlatVector"></a><strong>From Buffer to FlatVector</strong></h3><p>Velox 的 Buffer 和 Arrow 的 Buffer 类似，区别是：</p>
<ol>
<li>Arrow 的 Buffer 有 MemoryManager 和 Device，用来管理不同数据源的 Buffer；Velox 的 Buffer 是没有的。</li>
<li>Arrow 的 Buffer 大量依赖 <code>std::shared_ptr</code>；Velox 的 Buffer 依赖 <code>boost::intrusive_ptr</code>，可能 Velox 的性能会好点</li>
<li>两者都能绑定 MemoryTracker 类似的东西</li>
<li>Velox 的 Buffer 有一些工具函数管理 non-POD type</li>
</ol>
<p>Velox 的 Vector 分成好几部分，大量依赖了这个 Buffer 类型：</p>
<p><img src="https://image.mwish.me/blog-image/876913957418889513.png" alt="img"></p>
<ol>
<li><code>nulls_</code> 是一个 bits 级别的是否是 null，实现成一个 <code>BufferPtr</code></li>
<li><code>encoding</code>: 关于 encoding 我还是直接贴代码为好，如下。我们暂时只会介绍复杂类型、Flat、Constant、Dictionary</li>
<li>元信息：Vector 上有很多标注这个 Vector 存储信息的元信息，包括并不限于：<ol>
<li><code>type_</code></li>
<li><code>nullCount_</code></li>
<li><code>distinctValueCount_</code></li>
<li>还有一些执行的时候的上下文，比如：<code>memoDisabled_</code>, <code>isCodegenOutput_</code></li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provides an enumeration of vector encoding types.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">  BIASED,</span><br><span class="line">  CONSTANT,</span><br><span class="line">  DICTIONARY,</span><br><span class="line">  FLAT,</span><br><span class="line">  SEQUENCE,</span><br><span class="line">  ROW,</span><br><span class="line">  MAP,</span><br><span class="line">  ARRAY,</span><br><span class="line">  LAZY,</span><br><span class="line">  FUNCTION</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么下面我们应该介绍 Vector 的实现了。它有一个大概如下的继承链：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BaseVector</span> ( 包含 nulls, type, encoding 和元信息 )</span><br><span class="line">- LazyVector</span><br><span class="line">- FunctionVector</span><br><span class="line">- RowVector</span><br><span class="line">- SimpleVector&lt;T&gt; 基本的 vector 类型, 包含元素 T 类型和一些保障, 但是没有 element buffer.也有一些 statistics.</span><br><span class="line">  - DictionaryVector&lt;T&gt;: 字典 Vector, 成员见下代码</span><br><span class="line">  - FlatVector&lt;T&gt;: 常见布局的平坦元素 Vector, 用一个 BufferPtr 来承担 Values. 这里对 String 的处理比较有意思, 见下代码</span><br><span class="line">  - ConstantVector&lt;T&gt;: 对于 ConstantVector 来说, 它的语义是 <span class="string">&quot;常量的 Null 或者是一个 constant value&quot;</span>, 因此它不会用到父级别的 nulls Buffer. 它指向 Null 或者 Vector 中的某个位置</span><br></pre></td></tr></table></figure>
<p>DictionaryVector:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DictionaryVector</span> : <span class="keyword">public</span> SimpleVector&lt;T&gt; &#123;</span><br><span class="line">  BufferPtr indices_;</span><br><span class="line">  <span class="type">const</span> <span class="type">vector_size_t</span>* rawIndices_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  VectorPtr dictionaryValues_;</span><br><span class="line">  <span class="comment">// Caches &#x27;dictionaryValues_.get()&#x27; if scalar type.</span></span><br><span class="line">  SimpleVector&lt;T&gt;* scalarDictionaryValues_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// Caches &#x27;scalarDictionaryValues_-&gt;getRawValues()&#x27; if &#x27;dictionaryValues_&#x27;</span></span><br><span class="line">  <span class="comment">// is a FlatVector&lt;T&gt;.</span></span><br><span class="line">  <span class="type">const</span> T* rawDictionaryValues_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Indicates whether internal state has been set. Can also be false if there</span></span><br><span class="line">  <span class="comment">// is an unloaded lazy vector under the encoding layers.</span></span><br><span class="line">  <span class="type">bool</span> initialized_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.mwish.me/blog-image/6424380886371214072.png" alt="img"></p>
<p>需要特殊注意的两个地方是：</p>
<ol>
<li>Velox 的 Dictionary 是可以嵌套的。即：<code>VectorPtr -&gt; Dictionary -&gt; VectorPtr -&gt; Dictionary -&gt; ...</code> 这样套娃下去</li>
<li>Velox 的 Dictionary 可能包含 NULL，这里图上没有 Sample，但是 Dictionary 的 <code>VectorPtr</code> 可以包含 NULL</li>
<li>Dictionary 通过 <code>wrappedVector</code> <code>wrappedIndex</code> 返回内部的 <code>BaseVector</code> 和 index</li>
</ol>
<p>FlatVector:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlatVector is marked final to allow for inlining on virtual methods called</span></span><br><span class="line"><span class="comment">// on a pointer that has the static type FlatVector&lt;T&gt;; this can be a</span></span><br><span class="line"><span class="comment">// significant performance win when these methods are called in loops.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlatVector</span> <span class="keyword">final</span> : <span class="keyword">public</span> SimpleVector&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// Contiguous values.</span></span><br><span class="line">  <span class="comment">// If strings, these are velox::StringViews into memory held by</span></span><br><span class="line">  <span class="comment">// &#x27;stringBuffers_&#x27;</span></span><br><span class="line">  BufferPtr values_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Caches &#x27;values-&gt;as&lt;T&gt;()&#x27;</span></span><br><span class="line">  T* rawValues_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If T is velox::StringView, the referenced is held by</span></span><br><span class="line">  <span class="comment">// one of these.</span></span><br><span class="line">  std::vector&lt;BufferPtr&gt; stringBuffers_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used by &#x27;acquireSharedStringBuffers()&#x27; to fast check if a buffer to share</span></span><br><span class="line">  <span class="comment">// has already been referenced by &#x27;stringBuffers_&#x27;.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> we need to ensure &#x27;stringBuffers_&#x27; and &#x27;stringBufferSet_&#x27; are always</span></span><br><span class="line">  <span class="comment">// consistent.</span></span><br><span class="line">  folly::F14FastSet&lt;<span class="type">const</span> Buffer*&gt; stringBufferSet_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>FlatVector</code> 通过 <code>BufferPtr</code> 来存 value，然后弄了个 <code>rawValues_</code> 作为缓存。对于 <code>slice</code>，它允许用一个 <code>sliceBuffer</code> 拿到 bias 的 Buffer （arrow 有个额外的机制是 offset，即 base + offset 等于真实的数据，没有走 sliceBuffer 这样额外的机制。）</p>
<p>还有一个比较好玩的就是 string 的处理。<code>stringBuffers_</code> 和 <code>stringBufferSet_</code> 是为了给 string 有关的东西弄所有权使用的。与 Arrow 不同，Velox 支持 out-of-order write。所以这里会需要一些额外机制处理 <code>BufferPtr</code> 的所有权。</p>
<p>ConstantVector:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConstantVector</span> <span class="keyword">final</span> : <span class="keyword">public</span> SimpleVector&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// &#x27;valueVector_&#x27; element &#x27;index_&#x27; represents a complex constant</span></span><br><span class="line">  <span class="comment">// value. &#x27;valueVector_&#x27; is nullptr if the constant is scalar.</span></span><br><span class="line">  VectorPtr valueVector_;</span><br><span class="line">  <span class="comment">// The index of the represented value in &#x27;valueVector_&#x27;.</span></span><br><span class="line">  <span class="type">vector_size_t</span> index_ = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Holds the memory for backing non-inlined values represented by StringView.</span></span><br><span class="line">  BufferPtr stringBuffer_;</span><br><span class="line">  T value_;</span><br><span class="line">  <span class="type">bool</span> isNull_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> initialized_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This must be at end to avoid memory corruption.</span></span><br><span class="line">  std::<span class="type">conditional_t</span>&lt;can_simd, xsimd::batch&lt;T&gt;, <span class="type">char</span>&gt; valueBuffer_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ConstantVector 指向：</p>
<ol>
<li><code>valueVector_</code> 中的一个位置. 这里内部 Vector 可以是个 Flat 或者 Lazy，我其实感觉是 LazyVector 还比较有意义，是 Flat 的话感觉直接取值就行</li>
<li>直接指向 T, T 中的 string 所有权在 <code>stringBuffer_</code> 上</li>
<li><code>isNull_</code> 指向 Null</li>
</ol>
<h3 id="Selection-and-Rows"><a href="#Selection-and-Rows" class="headerlink" title="Selection and Rows"></a><strong>Selection and Rows</strong></h3><p><img src="https://image.mwish.me/blog-image/8120608020549370653.png" alt="img"></p>
<p>上述一个 RowVector 的结构。我们没有介绍 MAP 和 ARRAY，因为我们这篇文章不会用到它们。执行的时候，我们会有一个 Row 的输入。</p>
<p>此外，这里还会有个 <code>SelectivityVector</code>. 它的语义类似 NULL 但不完全相同。可以把它理解成向量化论文中的 Selection，没有被 Select / Filter 掉的数据不一定是 NULL。它的逻辑结构也是个 bits，类似 Nulls，但是（重复性的）做了一些工具类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A selectivityVector is used to logically filter / select data in place.</span></span><br><span class="line"><span class="comment">// The goal here is to be able to pass this vector between filter stages on</span></span><br><span class="line"><span class="comment">// different vectors while only maintaining a single copy of state and more</span></span><br><span class="line"><span class="comment">// importantly not ever having to re-layout the physical data. Further the</span></span><br><span class="line"><span class="comment">// SelectivityVector can be used to optimize filtering by skipping elements</span></span><br><span class="line"><span class="comment">// that where previously filtered by another filter / column</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SelectivityVector</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The vector of bits for what is selected vs not (1 is selected).</span></span><br><span class="line">  <span class="comment">// 这里的需求还是 bits 按照 8Byte 来对齐</span></span><br><span class="line">  std::vector&lt;<span class="type">uint64_t</span>&gt; bits_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The number of leading bits used in &#x27;bits_&#x27;.</span></span><br><span class="line">  <span class="type">vector_size_t</span> size_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The minimum index of a selected value, if there are any selected.</span></span><br><span class="line">  <span class="type">vector_size_t</span> begin_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// One past the last selected value, if there are any selected.</span></span><br><span class="line">  <span class="type">vector_size_t</span> end_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutable</span> std::optional&lt;<span class="type">bool</span>&gt; allSelected_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SelectivityIterator</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一般行执行的时候，输入结构可以当成下列结构：</p>
<ol>
<li>RowVector</li>
<li>SelectivityVector</li>
</ol>
<p>用 <code>SelectivityVector</code> 来表示 RowVector 的一些状态。</p>
<h3 id="DecodedVector"><a href="#DecodedVector" class="headerlink" title="DecodedVector"></a>DecodedVector</h3><p>关于 DecodedVector，官方描述见：<a target="_blank" rel="noopener" href="https://facebookincubator.github.io/velox/develop/dictionary-encoding.html">https://facebookincubator.github.io/velox/develop/dictionary-encoding.html</a></p>
<p><code>DecodedVector</code> 可以当作和 Dictionary / Constant 逻辑强相关：简单的说，DecodedVector 接受一个 Vector，展开成一个”最多嵌套一层” 的 Vector, Eg:</p>
<ol>
<li>Flat -&gt; Flat</li>
<li>DICT(DICT( … Flat(T))) -&gt; <code>&lt;indices, nulls, dictionaryValues&gt;</code></li>
<li>Dict(Dict(… Constant( T )) -&gt; <code>&lt;constantT, nulls, ...&gt;</code></li>
</ol>
<p>然后可以用 <code>nulls</code> 或者 <code>valueAt</code> 类似的方法访问。官方的 <code>DecodedVector</code> 例子比较充足，看看应该就会了。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>错误处理参考：<a target="_blank" rel="noopener" href="https://facebookincubator.github.io/velox/develop/expression-evaluation.html#error-handling-in-and-or-try">https://facebookincubator.github.io/velox/develop/expression-evaluation.html#error-handling-in-and-or-try</a></p>
<p>这部分我们举几个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a != <span class="number">0</span> <span class="keyword">and</span> b / a &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这个如果去做 Filter Reorder，那么 <code>b / a &gt; 0</code> 的时候，实际上是会需要处理错误的。此外，系统中还有 <code>TRY(...)</code> 这样的表达式，如果抛出错误会需要特殊处理。</p>
<p>Velox 里面一定程度上用异常来处理错误，但是会有一些直接产生 exception_ptr 或者包装错误的地方，来尽量减少开销。在执行的时候可能会有一个 <code>Vector</code> 来存放错误的状态，记录执行期的错误上下文，方便处理。</p>
<h3 id="EvalCtx"><a href="#EvalCtx" class="headerlink" title="EvalCtx"></a>EvalCtx</h3><p>我们终于来到了这里，本来想把 EvalCtx 放在介绍后头表达式执行的地方，不过思来想去挪到前头也不错，因为 Function 执行、表达式执行都有个 EvalCtx 的上下文。放后面介绍其实不太好。</p>
<p>初步下一个定义：<code>EvalCtx</code> 是对 <code>&lt;RowVector, ExprSet&gt;</code> 这个输入和对应执行上下文的包装, 因为和 rows 有关, 所以也写了很多数据本身的属性, 比如 flatNoNulls 什么的. 我们可以先看成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EvalCtx</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">memory::MemoryPool* FOLLY_NONNULL <span class="title">pool</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> execCtx_-&gt;<span class="built_in">pool</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the index-th column of the base row. If we have peeled off</span></span><br><span class="line">  <span class="comment">// wrappers like dictionaries, then this provides access only to the</span></span><br><span class="line">  <span class="comment">// peeled off fields.</span></span><br><span class="line">  <span class="function"><span class="type">const</span> VectorPtr&amp; <span class="title">getField</span><span class="params">(<span class="type">int32_t</span> index)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">VectorPtr <span class="title">ensureFieldLoaded</span><span class="params">(<span class="type">int32_t</span> index, <span class="type">const</span> SelectivityVector&amp; rows)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setPeeled</span><span class="params">(<span class="type">int32_t</span> index, <span class="type">const</span> VectorPtr&amp; vector)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (peeledFields_.<span class="built_in">size</span>() &lt;= index) &#123;</span><br><span class="line">      peeledFields_.<span class="built_in">resize</span>(index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    peeledFields_[index] = vector;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> std::vector&lt;VectorPtr&gt;&amp; <span class="title">peeledFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> peeledFields_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Used by peelEncodings.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">saveAndReset</span><span class="params">(ContextSaver&amp; saver, <span class="type">const</span> SelectivityVector&amp; rows)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(ContextSaver&amp; saver)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If exceptionPtr is known to be a VeloxException use setVeloxExceptionError</span></span><br><span class="line">  <span class="comment">// instead.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 设置执行的 Error.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setError</span><span class="params">(<span class="type">vector_size_t</span> index, <span class="type">const</span> std::exception_ptr&amp; exceptionPtr)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Similar to setError but more performant, should be used when the user knows</span></span><br><span class="line">  <span class="comment">// for sure that exception_ptr is a velox exception.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setVeloxExceptionError</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">vector_size_t</span> index,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::exception_ptr&amp; exceptionPtr)</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  core::ExecCtx* <span class="type">const</span> FOLLY_NONNULL execCtx_;</span><br><span class="line">  ExprSet* FOLLY_NULLABLE <span class="type">const</span> exprSet_;</span><br><span class="line">  <span class="type">const</span> RowVector* FOLLY_NULLABLE row_;</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> cacheEnabled_;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> maxSharedSubexprResultsCached_;</span><br><span class="line">  <span class="type">bool</span> inputFlatNoNulls_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Corresponds 1:1 to children of &#x27;row_&#x27;. Set to an inner vector</span></span><br><span class="line">  <span class="comment">// after removing dictionary/sequence wrappers.</span></span><br><span class="line">  std::vector&lt;VectorPtr&gt; peeledFields_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set if peeling was successful, that is, common encodings from inputs were</span></span><br><span class="line">  <span class="comment">// peeled off.</span></span><br><span class="line">  std::shared_ptr&lt;PeeledEncoding&gt; peeledEncoding_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// True if nulls in the input vectors were pruned (removed from the current</span></span><br><span class="line">  <span class="comment">// selectivity vector). Only possible is all expressions have default null</span></span><br><span class="line">  <span class="comment">// behavior.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// nullsPruned_ 和</span></span><br><span class="line">  <span class="type">bool</span> nullsPruned_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  <span class="comment">// Error Handling 的上下文, 对 Try(T) 这样的肯定要处理一层, 此外 Velox 还会 Filter Reorder,</span></span><br><span class="line">  <span class="comment">// 这里应该都会影响 Error 的处理.</span></span><br><span class="line">  <span class="type">bool</span> throwOnError_&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// True if the current set of rows will not grow, e.g. not under and IF or OR.</span></span><br><span class="line">  <span class="type">bool</span> isFinalSelection_&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If isFinalSelection_ is false, the set of rows for the upper-most IF or</span></span><br><span class="line">  <span class="comment">// OR. Used to determine the set of rows for loading lazy vectors.</span></span><br><span class="line">  <span class="type">const</span> SelectivityVector* FOLLY_NULLABLE finalSelection_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stores exception found during expression evaluation. Exceptions are stored</span></span><br><span class="line">  <span class="comment">// in a opaque flat vector, which will translate to a</span></span><br><span class="line">  <span class="comment">// std::shared_ptr&lt;std::exception_ptr&gt;.</span></span><br><span class="line">  ErrorVectorPtr errors_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这里有贴代码之嫌疑了，但是这个要嘴巴介绍确实比较抽象，通俗说这块还是 「输入的行 + Selection 的包装 + 输出的错误的包装」，Peeling 这个我们之后会讲，也和这块有关。</p>
<h2 id="VectorFunction-and-SimpleFunctionAdapter"><a href="#VectorFunction-and-SimpleFunctionAdapter" class="headerlink" title="VectorFunction and SimpleFunctionAdapter"></a>VectorFunction and SimpleFunctionAdapter</h2><p>这一节有个很好的总结：</p>
<ol>
<li>开发文档中 SimpleFunction 的部分 <a target="_blank" rel="noopener" href="https://facebookincubator.github.io/velox/develop/scalar-functions.html">https://facebookincubator.github.io/velox/develop/scalar-functions.html</a></li>
<li>官方博客关于 SimpleFunction 的介绍 <a target="_blank" rel="noopener" href="https://velox-lib.io/blog/simple-functions-2">https://velox-lib.io/blog/simple-functions-2</a></li>
</ol>
<p>Velox 有一个接口是 <code>VectorFunction</code>。这个 <code>VectorFunction</code> 不等价于 Arrow 的 VectorFunction ( Arrow 定义了 ScalarFunction 和 VectorFunction 等，Scalar 是参数之间互相无关，例如 Add 之类的；Vector 是可能有关，例如 Sort, Agg 等）。Velox 这些 Function 都是 “VectorFunction”，其接口如下（原本这里有一些字符串逻辑的定义，比如关于 ASCII 编码的属性，本文暂时移除这些便于阅读）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Superclass for functions which are written to run on whole vectors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// VectorFunction 的实现, 它不同于 arrow 的 Scalar 和 Vector. 任何 arrow 中的</span></span><br><span class="line"><span class="comment">// Scalar 对他来说都是 Vector function.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VectorFunction</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">VectorFunction</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">apply</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> SelectivityVector&amp; rows,</span></span></span><br><span class="line"><span class="params"><span class="function">      std::vector&lt;VectorPtr&gt;&amp; args, <span class="comment">// Not using const ref so we can reuse args</span></span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> TypePtr&amp; outputType,</span></span></span><br><span class="line"><span class="params"><span class="function">      EvalCtx&amp; context,</span></span></span><br><span class="line"><span class="params"><span class="function">      VectorPtr&amp; result)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isDeterministic</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// NULL 输入 -&gt; 输出 NULL 就是 defaultNull behavior.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isDefaultNullBehavior</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给 ML 之类的负载用，输入都是 flat + NoNull 可以定义一个 fastPath</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">supportsFlatNoNullsFastPath</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>SimpleFunctionAdapter</code> 则是 Velox 内部的一个工具，用户写了一个 C++ class 后，可以生成一个上述的 VectorFunction，便于快速执行。</p>
<h3 id="可选的优化参数"><a href="#可选的优化参数" class="headerlink" title="可选的优化参数"></a>可选的优化参数</h3><p>这部分可以参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://facebookincubator.github.io/velox/develop/scalar-functions.html">https://facebookincubator.github.io/velox/develop/scalar-functions.html</a></li>
<li><a target="_blank" rel="noopener" href="https://facebookincubator.github.io/velox/develop/view-and-writer-types.html">https://facebookincubator.github.io/velox/develop/view-and-writer-types.html</a></li>
</ol>
<p>用户可以写简单的函数，然后便于执行，最简单例子如下 ( <code>velox/functions/prestosql/Arithmetic.h</code> )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CeilFunction</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TOutput, <span class="keyword">typename</span> TInput = TOutput&gt;</span><br><span class="line">  FOLLY_ALWAYS_INLINE <span class="type">void</span> <span class="built_in">call</span>(TOutput&amp; result, <span class="type">const</span> TInput&amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_integral_v&lt;TInput&gt;) &#123;</span><br><span class="line">      result = a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = <span class="built_in">ceil</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FloorFunction</span> &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TOutput, <span class="keyword">typename</span> TInput = TOutput&gt;</span><br><span class="line">  FOLLY_ALWAYS_INLINE <span class="type">void</span> <span class="built_in">call</span>(TOutput&amp; result, <span class="type">const</span> TInput&amp; a) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_integral_v&lt;TInput&gt;) &#123;</span><br><span class="line">      result = a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = <span class="built_in">floor</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>String 相关的大概知道文档里 ascii 有关的、生命周期优化就行，比如说：</p>
<ol>
<li><code>callAscii</code> 在输入发现自己全是 ascii 的时候可以用，作为 ascii fast path，比如求 utf8 char count 或者 truncate，如果都是 ASCII 那快速处理就完事了，不然还要扫一下 codepoint。</li>
<li>Reuse input: Velox 的字符串列会有 <code>BufferPtr</code>，作为侵入式 shared_ptr 拿到列的字符串的所有权。正常的话一个 str 有关的算子会走 copy，然后开一块新的空间存放所有权。但比如 substr 或者 truncate 就可以在输入列 copy 一份 <code>BufferPtr</code> (而不是数据），来拿到对应的数据，避免一轮开销（zero-copy）</li>
</ol>
<p>我们这里主要关注 NULL 相关的几个逻辑：</p>
<ol>
<li>函数 <code>callNullable</code>: 当定义这个函数的时候，行为不是 defaultNull，即不是输入 Null -&gt; 输出 Null 的形式了。</li>
<li>函数 <code>callNullFree</code> : 当定义这个函数的时候，在输入没有 NULL 的时候，定义了一个 FastPath。这个一般是给嵌套类型（Array / Map ) 使用的。</li>
</ol>
<blockquote>
<p>思考：Arrow 的一些执行，比如 Add 执行的时候，会分开 Null 和 Add。即 Int32Array + Int32Array 的时候，做一轮 bitAnd，再直接 ignoreNull 做一轮整数加法。这种估计最好有一些渐进式实现，比如对 Selector 返回 RLE/Bitpack 的模式，如果是连续的 Null / Non-Null （RLE Mode），就执行 / 不执行。</p>
</blockquote>
<p>那么下面介绍具体的执行。</p>
<h3 id="Apply-执行的路径"><a href="#Apply-执行的路径" class="headerlink" title="Apply 执行的路径"></a>Apply 执行的路径</h3><p>这里执行的路径其实比较简单，但是因为有一些依赖，加上他们写的模版代码还不咋好看，其实看起来还是蛮恶心的。</p>
<ol>
<li>尝试找到 output vector，或者进行 input reuse。Input reuse 是个特定场景还比较有用的优化，比如 <code>(a + 1) * 2 + b</code>。这个东西编译成表达式（不考虑 codegen 连接整个表达式的话），可能 a 作为输入列，<code>+1</code> 执行一下 Function， <code>*2</code> 又是一次，<code>+b</code> 又是一次，就很离谱。虽然算下来可能最后 profile 的时候，大部分计算瓶颈真不是这里，而且内存可以池化，但是这块可能会把 CPU 开销弄出一些内存访问开销。这里比较好的方式就是 codegen 。而 input reuse 就是用输入看看能不能一起用在输出上（即读写同一个 Vector）</li>
<li>根据函数定义和输入，判断 NULL 的分发。这里如果是 defaultNull 的（即没有定义 <code>callNullable</code>），下发给 <strong>VectorFunction 的输入甚至不会含 NULL(这里的不包含指的是 Selection 选中的不包含，没选中的就不管了）。</strong></li>
<li>分发 Decode，比如输入都是 <code>VectorPtr</code>，但是 Vector 会有不同的 encoding。这里最好的方式是根据 encoding 的类型去分发执行，比如两个都是 Constant 就怎么执行（实际上由于 Peeling 这种情况不多）；一个 Constant 一个 Vector 怎么执行；两个都是 Dictionary 怎么执行。这里见下图。当然这个情况下执行可能参数多的时候展开就很废。Velox 限定了展开条件，输入小于 2 才去做展开</li>
</ol>
<p><img src="https://image.mwish.me/blog-image/4028683123846054944.png" alt="img"></p>
<p>上面贴图执行相关的参数是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// https://velox-lib.io/blog/simple-functions-1</span></span><br><span class="line"><span class="comment">/// 参考: `To avoid code size blowing` 这一段.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> specializeForAllEncodings = FUNC::num_args &lt;= <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>原理介绍完了，看代码吧（我删掉了一些字符串和初始化有关的代码）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SelectivityVector&amp; rows,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;VectorPtr&gt;&amp; args,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TypePtr&amp; outputType,</span></span></span><br><span class="line"><span class="params"><span class="function">    EvalCtx&amp; context,</span></span></span><br><span class="line"><span class="params"><span class="function">    VectorPtr&amp; result<span class="comment">/*result 可以是 nullptr*/</span>)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span>* reusableResult = &amp;result;</span><br><span class="line">  <span class="comment">// If result is null, check if one of the arguments can be re-used for</span></span><br><span class="line">  <span class="comment">// storing the result. This is possible if all the following conditions are</span></span><br><span class="line">  <span class="comment">// met:</span></span><br><span class="line">  <span class="comment">// - result type is a fixed-width type,</span></span><br><span class="line">  <span class="comment">// - function doesn&#x27;t produce nulls,</span></span><br><span class="line">  <span class="comment">// - an argument has the same type as result,</span></span><br><span class="line">  <span class="comment">// - the argument has flat encoding,</span></span><br><span class="line">  <span class="comment">// - the argument is singly-referenced and has singly-referenced values</span></span><br><span class="line">  <span class="comment">// and nulls buffers.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 这个要输出不是 Null 才行，为什么呢? 这块在计算的时候, 对于 producing Null</span></span><br><span class="line">  <span class="comment">// 的结果, 会 clearAllNulls:</span></span><br><span class="line">  <span class="comment">// 见 https://github.com/facebookincubator/velox/pull/1521</span></span><br><span class="line">  <span class="type">bool</span> isResultReused = <span class="literal">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      !FUNC::can_produce_null_output &amp;&amp; !FUNC::udf_has_callNullFree &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">      return_type_traits::isPrimitiveType &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">      return_type_traits::isFixedWidth)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入是 NULL 的时候才能使用.</span></span><br><span class="line">    <span class="keyword">if</span> (!reusableResult-&gt;<span class="built_in">get</span>())</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span>* arg = <span class="built_in">findReusableArg</span>&lt;<span class="number">0</span>&gt;(args)) &#123;</span><br><span class="line">        reusableResult = arg;</span><br><span class="line">        isResultReused = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ApplyContext applyContext&#123;</span><br><span class="line">      &amp;rows, outputType, context, *reusableResult, isResultReused&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this UDF can take the fast path iteration, we set all active rows as</span></span><br><span class="line">  <span class="comment">// non-nulls in the result vector. The assumption is that the majority of</span></span><br><span class="line">  <span class="comment">// rows will return non-null values (and hence won&#x27;t have to touch the</span></span><br><span class="line">  <span class="comment">// null buffer during iteration).</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(fastPathIteration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If result is resuing one of the inputs we do not clear nulls, instead</span></span><br><span class="line">    <span class="comment">// we do that after the the input is read. It is safe because reuse only</span></span><br><span class="line">    <span class="comment">// happens when the function does not generate null.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 如果 result 是重用的，那么就不用 clearNulls 了.</span></span><br><span class="line">    <span class="keyword">if</span> (!isResultReused) &#123;</span><br><span class="line">      (*reusableResult)-&gt;<span class="built_in">clearNulls</span>(rows);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 系统的 DecodedVector</span></span><br><span class="line">  std::vector&lt;std::optional&lt;LocalDecodedVector&gt;&gt; decoded;</span><br><span class="line">  <span class="comment">// 允许执行并且参数数量小于一定限制的话, 就根据类型去 unpack.</span></span><br><span class="line">  <span class="comment">// 见: https://velox-lib.io/blog/simple-functions-1</span></span><br><span class="line">  <span class="comment">// 参考: `To avoid code size blowing` 这一段.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">allPrimitiveArgsFlatConstant</span>(args)) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        allArgsFlatConstantFastPathEligible() &amp;&amp; specializeForAllEncodings)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 根据类型做展开然后分发</span></span><br><span class="line">      <span class="built_in">unpackSpecializeForAllEncodings</span>&lt;<span class="number">0</span>&gt;(applyContext, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      decoded.<span class="built_in">resize</span>(args.<span class="built_in">size</span>());</span><br><span class="line">      <span class="built_in">unpack</span>&lt;<span class="number">0</span>, <span class="literal">true</span>&gt;(applyContext, decoded, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    decoded.<span class="built_in">resize</span>(args.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">unpack</span>&lt;<span class="number">0</span>, <span class="literal">false</span>&gt;(applyContext, decoded, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(fastPathIteration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If result is resued and function is is_default_null_behavior then we do</span></span><br><span class="line">    <span class="comment">// not need to clear nulls.</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!FUNC::is_default_null_behavior)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (isResultReused) &#123;</span><br><span class="line">        (*reusableResult)-&gt;<span class="built_in">clearNulls</span>(rows);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isResultReused) &#123;</span><br><span class="line">    result = std::<span class="built_in">move</span>(*reusableResult);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 <code>Decode</code> 一层我们关注 <code>unpack*</code> 函数，以 flat-no-null 执行为例（即输入 Vector 都是 flat / constant，且函数参数小于3个）. 这里会把所有输入展开成 <code>VectorReader</code>，然后最内层的时候执行 <code>iterate</code>。这里我们会看到，<code>Vector</code> 被转换成了 <code>ConstantVectorReader</code> 和 <code>FlatVectorReader</code>，我们可以与后面的代码进行对比。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is called only when we know that all args are flat or constant and are</span></span><br><span class="line"><span class="comment">// eligible for the optimization and the optimization is enabled.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int32_t</span> POSITION, <span class="keyword">typename</span>... TReader&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unpackSpecializeForAllEncodings</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ApplyContext&amp; applyContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;VectorPtr&gt;&amp; rawArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">    TReader&amp;... readers)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(POSITION == FUNC::num_args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">iterate</span>(applyContext, readers...);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; arg = rawArgs[POSITION];</span><br><span class="line">    <span class="keyword">using</span> type =</span><br><span class="line">        <span class="keyword">typename</span> VectorExec::<span class="keyword">template</span> resolver&lt;arg_at&lt;POSITION&gt;&gt;::in_type;</span><br><span class="line">    <span class="keyword">if</span> (arg-&gt;<span class="built_in">isConstantEncoding</span>()) &#123;</span><br><span class="line">      <span class="comment">// 展开成 constant reader, 然后继续 delegate 下去</span></span><br><span class="line">      <span class="keyword">auto</span> reader = ConstantVectorReader&lt;arg_at&lt;POSITION&gt;&gt;(</span><br><span class="line">          *(arg-&gt;asUnchecked&lt;ConstantVector&lt;type&gt;&gt;()));</span><br><span class="line">      <span class="built_in">unpackSpecializeForAllEncodings</span>&lt;POSITION + <span class="number">1</span>&gt;(</span><br><span class="line">          applyContext, rawArgs, readers..., reader);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DCHECK</span>(arg-&gt;<span class="built_in">isFlatEncoding</span>());</span><br><span class="line">      <span class="comment">// Should be flat if not constant.</span></span><br><span class="line">      <span class="keyword">auto</span> reader = FlatVectorReader&lt;arg_at&lt;POSITION&gt;&gt;(</span><br><span class="line">          *arg-&gt;asUnchecked&lt;FlatVector&lt;type&gt;&gt;());</span><br><span class="line">      <span class="built_in">unpackSpecializeForAllEncodings</span>&lt;POSITION + <span class="number">1</span>&gt;(</span><br><span class="line">          applyContext, rawArgs, readers..., reader);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>iterate</code> 的代码很长，我们贴一下：</p>
<p>这里分为好几步：</p>
<ol>
<li>判断输入是否有 <code>callNullFree</code>，有的话，传给 VectorFunction 的参数可能含 Null。需要做一轮 fast check</li>
<li>按需求循环展开 Readers 的 Null 信息（和 ASCII 之类的信息），然后调用函数</li>
</ol>
<p>这个函数我看几遍都觉得丑，刚开始看的时候觉得是我水平的问题，现在咋看还是丑，妈的就是它写的丑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体执行的函数，手握所有的 ColumnReader. 然后去生成(行式)执行的代码.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... TReader&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iterate</span><span class="params">(ApplyContext&amp; applyContext, TReader&amp;... readers)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Null 的行为这里涉及好几个定义:</span></span><br><span class="line">  <span class="comment">// 1. `callNullable`: 没有定义这个函数为 default, 即输入为 NULL -&gt; 输出为 NULL.</span></span><br><span class="line">  <span class="comment">//    callNullable 处理</span></span><br><span class="line">  <span class="comment">// 2. `callNullFree`: 定义了这个函数, 即没有任何 NULL 的时候进行快速 path.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If udf_has_callNullFree is true compute mayHaveNullsRecursive.</span></span><br><span class="line">  <span class="comment">// 开洞, 不过这玩意好像没啥意思, 感觉有的 NULL 在 Expr 执行的时候甚至不会分发下来</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(FUNC::udf_has_callNullFree)</span> </span>&#123;</span><br><span class="line">    (</span><br><span class="line">        [&amp;]() &#123;</span><br><span class="line">          readers.<span class="built_in">setChildrenMayHaveNulls</span>();</span><br><span class="line">          applyContext.mayHaveNullsRecursive |=</span><br><span class="line">              readers.<span class="built_in">mayHaveNullsRecursive</span>();</span><br><span class="line">        &#125;(),</span><br><span class="line">        ...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If is_default_contains_nulls_behavior we return null if the inputs</span></span><br><span class="line">  <span class="comment">// contain any nulls.</span></span><br><span class="line">  <span class="comment">// If !is_default_contains_nulls_behavior we don&#x27;t invoke callNullFree</span></span><br><span class="line">  <span class="comment">// if the inputs contain any nulls, but rather invoke call or</span></span><br><span class="line">  <span class="comment">// callNullable as usual.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 1. defaultNull: Expr 系统不会传 Null 下来</span></span><br><span class="line">  <span class="comment">// 2. has_callNullFree: 有 nullFree 的函数的定义</span></span><br><span class="line">  <span class="comment">// 3. mayHaveNullsRecursive: 有 Null 啊，得执行了</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 这里是: &quot;Expr 系统不会传 Null 下来&quot; || (&quot;有 nullFree 的函数的定义&quot; &amp;&amp; &quot;输入不包含任何 null&quot;)</span></span><br><span class="line">  <span class="type">bool</span> callNullFree = FUNC::is_default_contains_nulls_behavior ||</span><br><span class="line">      (FUNC::udf_has_callNullFree &amp;&amp; !applyContext.mayHaveNullsRecursive);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute allNotNull.</span></span><br><span class="line">  <span class="comment">// 计算是否所有输入都是 NotNull, 和上面 callNullFree 有一定重合部分.</span></span><br><span class="line">  <span class="type">bool</span> allNotNull;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(FUNC::is_default_null_behavior)</span> </span>&#123;</span><br><span class="line">    allNotNull = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    allNotNull = (!readers.<span class="built_in">mayHaveNulls</span>() &amp;&amp; ...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterate the rows.</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(fastPathIteration)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span>* nullBuffer = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 干脆叫 getRawResultData 吧，你们起名字没人 review 吗？</span></span><br><span class="line">    <span class="keyword">auto</span> getRawData = [&amp;]() &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">constexpr</span> (return_type_traits::typeKind == TypeKind::BOOLEAN) &#123;</span><br><span class="line">        <span class="keyword">return</span> applyContext.result-&gt;<span class="built_in">mutableRawValues</span>();</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> applyContext.resultWriter.data_;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* data = <span class="built_in">getRawData</span>();</span><br><span class="line">    <span class="comment">// 写入单个 Result.</span></span><br><span class="line">    <span class="comment">// row: rowId</span></span><br><span class="line">    <span class="comment">// notNull: out isNull</span></span><br><span class="line">    <span class="comment">// out: 输出的类型.</span></span><br><span class="line">    <span class="keyword">auto</span> writeResult = [&amp;applyContext, &amp;nullBuffer, &amp;data](</span><br><span class="line">                           <span class="keyword">auto</span> row, <span class="type">bool</span> notNull, <span class="keyword">auto</span> out) INLINE_LAMBDA &#123;</span><br><span class="line">      <span class="comment">// For fast path iteration, all active rows were already set as</span></span><br><span class="line">      <span class="comment">// non-null beforehand, so we only need to update the null buffer if</span></span><br><span class="line">      <span class="comment">// the function returned null (which is not the common case).</span></span><br><span class="line">      <span class="keyword">if</span> (notNull) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">constexpr</span> (return_type_traits::typeKind == TypeKind::BOOLEAN) &#123;</span><br><span class="line">          bits::<span class="built_in">setBit</span>(data, row, out);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          data[row] = out;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nullBuffer) &#123;</span><br><span class="line">          nullBuffer = applyContext.result-&gt;<span class="built_in">mutableRawNulls</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        bits::<span class="built_in">setNull</span>(nullBuffer, row);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (callNullFree) &#123;</span><br><span class="line">      <span class="keyword">if</span> (applyContext.mayHaveNullsRecursive) &#123;</span><br><span class="line">        applyContext.<span class="built_in">applyToSelectedNoThrow</span>([&amp;](<span class="keyword">auto</span> row) INLINE_LAMBDA &#123;</span><br><span class="line">          <span class="keyword">typename</span> return_type_traits::NativeType out&#123;&#125;;</span><br><span class="line">          <span class="keyword">auto</span> containsNull = (readers.<span class="built_in">containsNull</span>(row) || ...);</span><br><span class="line">          <span class="type">bool</span> notNull;</span><br><span class="line">          <span class="keyword">if</span> (containsNull) &#123;</span><br><span class="line">            <span class="comment">// Result is NULL because the input contains NULL.</span></span><br><span class="line">            notNull = <span class="literal">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            notNull = <span class="built_in">doApplyNullFree</span>&lt;<span class="number">0</span>&gt;(row, out, readers...);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">writeResult</span>(row, notNull, out);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有 Null, 按照 Selector 执行.</span></span><br><span class="line">        applyContext.<span class="built_in">applyToSelectedNoThrow</span>([&amp;](<span class="keyword">auto</span> row) INLINE_LAMBDA &#123;</span><br><span class="line">          <span class="keyword">typename</span> return_type_traits::NativeType out&#123;&#125;;</span><br><span class="line">          <span class="type">bool</span> notNull = <span class="built_in">doApplyNullFree</span>&lt;<span class="number">0</span>&gt;(row, out, readers...);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">writeResult</span>(row, notNull, out);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allNotNull) &#123;</span><br><span class="line">        <span class="comment">// ... 下面都是面条代码，别看了，逻辑差不多的。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单介绍一下 <code>doApply</code> 的逻辑，就是展开可变参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="type">size_t</span> POSITION,</span><br><span class="line">    <span class="keyword">typename</span>... Values,</span><br><span class="line">    std::<span class="type">enable_if_t</span>&lt;</span><br><span class="line">        POSITION == FUNC::num_args &amp;&amp; FUNC::is_default_null_behavior,</span><br><span class="line">        <span class="type">int32_t</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">FOLLY_ALWAYS_INLINE <span class="type">bool</span></span><br><span class="line"><span class="built_in">doApply</span>(<span class="type">size_t</span> <span class="comment">/*idx*/</span>, T&amp; target, <span class="type">const</span> Values&amp;... values) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">return</span> (*fn_).<span class="built_in">call</span>(target, values...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For NOT default null behavior, terminate with UDFHolder::callNullable.</span></span><br><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="type">size_t</span> POSITION,</span><br><span class="line">    <span class="keyword">typename</span>... Values,</span><br><span class="line">    std::<span class="type">enable_if_t</span>&lt;</span><br><span class="line">        POSITION == FUNC::num_args &amp;&amp; !FUNC::is_default_null_behavior,</span><br><span class="line">        <span class="type">int32_t</span>&gt; = <span class="number">0</span>&gt;</span><br><span class="line">FOLLY_ALWAYS_INLINE <span class="type">bool</span></span><br><span class="line"><span class="built_in">doApply</span>(<span class="type">size_t</span> <span class="comment">/*idx*/</span>, T&amp; target, <span class="type">const</span> Values*... values) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">return</span> (*fn_).<span class="built_in">callNullable</span>(target, values...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们过的是参数小于3的时候的 unpack，下面过一下参数多的时候，这里会走 DecodedVector 相关的 Reader 来读，这里关注下面的 <code>LocalDecodedVector</code> 代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不用类型分发, 只是用 DecodedVector 来处理这块的逻辑，可能有一定的性能损失.</span></span><br><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="type">int32_t</span> POSITION,</span><br><span class="line">    <span class="type">bool</span> allPrimitiveArgsFlatConstant,</span><br><span class="line">    <span class="keyword">typename</span>... TReader&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unpack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ApplyContext&amp; applyContext,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;std::optional&lt;LocalDecodedVector&gt;&gt;&amp; decodedArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;VectorPtr&gt;&amp; rawArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">    TReader&amp;... readers)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(POSITION == FUNC::num_args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">iterate</span>(applyContext, readers...);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (isVariadicType&lt;arg_at&lt;POSITION&gt;&gt;::value) &#123;</span><br><span class="line">    <span class="comment">// This should already be statically checked by the UDFHolder used to</span></span><br><span class="line">    <span class="comment">// wrap the simple function, but checking again here just in case.</span></span><br><span class="line">    <span class="built_in">static_assert</span>(</span><br><span class="line">        POSITION == FUNC::num_args - <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;Variadic args can only be used as the last argument to a function.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = POSITION; i &lt; rawArgs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      decodedArgs[i] = <span class="built_in">LocalDecodedVector</span>(</span><br><span class="line">          applyContext.context, *rawArgs[i], *applyContext.rows);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> variadicReader =</span><br><span class="line">        VectorReader&lt;arg_at&lt;POSITION&gt;&gt;(decodedArgs, POSITION);</span><br><span class="line">    <span class="built_in">iterate</span>(applyContext, readers..., variadicReader);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Use ConstantFlatVectorReader as optimization when applicable.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">constexpr</span> (</span><br><span class="line">        allPrimitiveArgsFlatConstant &amp;&amp;</span><br><span class="line">        isArgFlatConstantFastPathEligible&lt;POSITION&gt;) &#123;</span><br><span class="line">      <span class="keyword">using</span> <span class="type">value_t</span> =</span><br><span class="line">          <span class="keyword">typename</span> ConstantFlatVectorReader&lt;arg_at&lt;POSITION&gt;&gt;::<span class="type">exec_in_t</span>;</span><br><span class="line">      <span class="keyword">auto</span>&amp; arg = rawArgs[POSITION];</span><br><span class="line">      <span class="keyword">auto</span> reader = arg-&gt;<span class="built_in">encoding</span>() == VectorEncoding::Simple::FLAT</span><br><span class="line">          ? ConstantFlatVectorReader&lt;arg_at&lt;POSITION&gt;&gt;(</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;FlatVector&lt;<span class="type">value_t</span>&gt;*&gt;(arg.<span class="built_in">get</span>()))</span><br><span class="line">          : ConstantFlatVectorReader&lt;arg_at&lt;POSITION&gt;&gt;(</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;ConstantVector&lt;<span class="type">value_t</span>&gt;*&gt;(arg.<span class="built_in">get</span>()));</span><br><span class="line"></span><br><span class="line">      <span class="built_in">unpack</span>&lt;POSITION + <span class="number">1</span>, allPrimitiveArgsFlatConstant&gt;(</span><br><span class="line">          applyContext, decodedArgs, rawArgs, readers..., reader);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      decodedArgs[POSITION] = <span class="built_in">LocalDecodedVector</span>(</span><br><span class="line">          applyContext.context, *rawArgs[POSITION], *applyContext.rows);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span>* oneUnpacked = decodedArgs.<span class="built_in">at</span>(POSITION).<span class="built_in">value</span>().<span class="built_in">get</span>();</span><br><span class="line">      <span class="keyword">auto</span> reader = VectorReader&lt;arg_at&lt;POSITION&gt;&gt;(oneUnpacked);</span><br><span class="line">      <span class="built_in">unpack</span>&lt;POSITION + <span class="number">1</span>, allPrimitiveArgsFlatConstant&gt;(</span><br><span class="line">          applyContext, decodedArgs, rawArgs, readers..., reader);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a><strong>References</strong></h2><ol>
<li>P. Pedreira, et al., <a target="_blank" rel="noopener" href="https://15721.courses.cs.cmu.edu/spring2023/papers/23-velox/p3372-pedreira.pdf">Velox: Meta’s Unified Execution Engine</a>, in <em>VLDB</em>, 2022</li>
<li><a target="_blank" rel="noopener" href="https://15721.courses.cs.cmu.edu/spring2024/papers/01-modern/p2679-pedreira.pdf">The Composable Data Management System Manifesto</a> (P. Pedreira, et al., VLDB 2023)</li>
<li>Intro to Velox: <a href="https://blog.mwish.me/2022/11/13/Introduction-to-velox/">https://blog.mwish.me/2022/11/13/Introduction-to-velox/</a> </li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">数据类型和基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Type"><span class="toc-number">1.1.</span> <span class="toc-text">Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#From-Buffer-to-FlatVector"><span class="toc-number">1.2.</span> <span class="toc-text">From Buffer to FlatVector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Selection-and-Rows"><span class="toc-number">1.3.</span> <span class="toc-text">Selection and Rows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DecodedVector"><span class="toc-number">1.4.</span> <span class="toc-text">DecodedVector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EvalCtx"><span class="toc-number">1.6.</span> <span class="toc-text">EvalCtx</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VectorFunction-and-SimpleFunctionAdapter"><span class="toc-number">2.</span> <span class="toc-text">VectorFunction and SimpleFunctionAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E7%9A%84%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">可选的优化参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Apply-%E6%89%A7%E8%A1%8C%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">2.2.</span> <span class="toc-text">Apply 执行的路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#References"><span class="toc-number">3.</span> <span class="toc-text">References</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&text=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&title=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&is_video=false&description=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Expression Execution in Velox Part 1: Basics and UDF&body=Check out this article: http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&title=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&title=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&title=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&title=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&name=Expression Execution in Velox Part 1: Basics and UDF&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/&t=Expression Execution in Velox Part 1: Basics and UDF"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2024
    mwish
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FL51GBW6JT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FL51GBW6JT');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
