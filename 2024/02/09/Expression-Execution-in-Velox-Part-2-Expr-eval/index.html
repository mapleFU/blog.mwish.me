<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="上一节我们介绍了 SimpleFunction 执行的链路，表达式除了 Simple Function 之外：  还会能让用户直接继承 VectorFunction 写一些自己定义的 Agg 或者别的方式，这里我理解和 Arrow Compute 里面的定义是相似的 Register 一些 Agg 之类的函数，然后进行各种操作  Velox 官方很多地方还是靠 UDF 的，很诚恳( 指没有在内部搞">
<meta property="og:type" content="article">
<meta property="og:title" content="Expression Execution in Velox Part 2: Expr::eval">
<meta property="og:url" content="http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/index.html">
<meta property="og:site_name" content="风空之岛">
<meta property="og:description" content="上一节我们介绍了 SimpleFunction 执行的链路，表达式除了 Simple Function 之外：  还会能让用户直接继承 VectorFunction 写一些自己定义的 Agg 或者别的方式，这里我理解和 Arrow Compute 里面的定义是相似的 Register 一些 Agg 之类的函数，然后进行各种操作  Velox 官方很多地方还是靠 UDF 的，很诚恳( 指没有在内部搞">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.mwish.me/blog-image/4389218142237259241.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/2940558373116012940.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/1095838213981124704.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/expr-eval-code.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/cse-velox.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/expr-eval-code.png">
<meta property="article:published_time" content="2024-02-08T18:08:52.000Z">
<meta property="article:modified_time" content="2024-02-17T12:42:39.803Z">
<meta property="article:author" content="mwish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.mwish.me/blog-image/4389218142237259241.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/logo.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico">
        
      
    
    <!-- title -->
    <title>Expression Execution in Velox Part 2: Expr::eval</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2024/02/17/Expression-Execution-in-Velox-Part-3-SpecialForm/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&text=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&title=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&is_video=false&description=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Expression Execution in Velox Part 2: Expr::eval&body=Check out this article: http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&title=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&title=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&title=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&title=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&name=Expression Execution in Velox Part 2: Expr::eval&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&t=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E7%9A%84%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">执行之前的部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E9%93%BE%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">表达式的执行链路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">2.1.</span> <span class="toc-text">相关的背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-ExecCtx"><span class="toc-number">2.1.1.</span> <span class="toc-text">输入: ExecCtx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-Constant-FieldReference"><span class="toc-number">2.1.2.</span> <span class="toc-text">输入: Constant &#x2F; FieldReference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9A%84%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%E5%92%8C-Compute-Metadata"><span class="toc-number">2.1.3.</span> <span class="toc-text">基础的优化手段和 Compute Metadata</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#distinctFields-multiplyReferencedFields-sameAsParentDistinctFields"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">distinctFields, multiplyReferencedFields, sameAsParentDistinctFields</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#propagatesNulls"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">propagatesNulls</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Determinstic"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">Determinstic</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hasConditions"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">hasConditions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Expr-for-VectorFunction"><span class="toc-number">2.2.</span> <span class="toc-text">Expr for VectorFunction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Flat-no-null-fast-path"><span class="toc-number">2.2.1.</span> <span class="toc-text">Flat no null fast path</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSE-%E8%AE%A1%E7%AE%97"><span class="toc-number">2.2.2.</span> <span class="toc-text">CSE 计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EvalAll-%E7%9B%B8%E5%AF%B9-flat-no-null-%E5%A4%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.3.</span> <span class="toc-text">EvalAll: 相对 flat no null 多了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Encoding-Peeling"><span class="toc-number">2.2.4.</span> <span class="toc-text">Encoding - Peeling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EvalWithNulls"><span class="toc-number">2.2.5.</span> <span class="toc-text">EvalWithNulls</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dictionary-Memo"><span class="toc-number">2.2.6.</span> <span class="toc-text">Dictionary Memo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wrapup"><span class="toc-number">2.3.</span> <span class="toc-text">Wrapup</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Expression Execution in Velox Part 2: Expr::eval
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">mwish</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-02-08T18:08:52.000Z" itemprop="datePublished">2024-02-09</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>上一节我们介绍了 SimpleFunction 执行的链路，表达式除了 Simple Function 之外：</p>
<ol>
<li>还会能让用户直接继承 VectorFunction 写一些自己定义的 Agg 或者别的方式，这里我理解和 Arrow Compute 里面的定义是相似的</li>
<li>Register 一些 Agg 之类的函数，然后进行各种操作</li>
</ol>
<p>Velox 官方很多地方还是靠 UDF 的，很诚恳( 指没有在内部搞各种骚操作 )。他们的展开在上一节（<a href="https://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/）">https://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/）</a> 中有所介绍.</p>
<p>本期介绍的是 Velox Expression 的执行，执行具体的 Expr </p>
<h2 id="执行之前的部分"><a href="#执行之前的部分" class="headerlink" title="执行之前的部分"></a>执行之前的部分</h2><p>这里要区分 Velox 的 Expr，下图是个很好的例子：</p>
<p><img src="https://image.mwish.me/blog-image/4389218142237259241.png" alt="img"></p>
<p>Velox 在执行前拿到的很大程度上是左侧的表达式，这里可以见：<a href="https://blog.mwish.me/2022/11/13/Introduction-to-velox/#Compilation">https://blog.mwish.me/2022/11/13/Introduction-to-velox/#Compilation</a> . 简单说这里在执行之前会做一些优化包括：</p>
<ol>
<li>CSE 的处理</li>
<li>常量折叠</li>
<li>Flatten ANDs and ORs …</li>
</ol>
<p>最终这里会生成一个表达式. Compile 签名如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::shared_ptr&lt;Expr&gt;&gt; <span class="built_in">compileExpressions</span>(</span><br><span class="line">    <span class="type">const</span> std::vector&lt;core::TypedExprPtr&gt;&amp; sources,</span><br><span class="line">    core::ExecCtx* execCtx,</span><br><span class="line">    ExprSet* exprSet,</span><br><span class="line">    <span class="type">bool</span> enableConstantFolding = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>我们这一节不会直接介绍这里的逻辑。这里的生成结果是 ExprSet，它是一组表达式的集合，共享了一些表达式的上下文。在 ExprSet 中有些表达式是会被共享的。</p>
<p>具体而言，这里最后产生的是一个 <code>facebook::velox::exec::Expr</code>。<code>Expr</code> 本身便于执行一些带 VectorFunction （很多又是我们上一节介绍的 Simple Function），而剩下的被处理为 SpecialForm，表示 Velox 自己包装的 if 之类的逻辑。很多错误处理的逻辑也包装在里面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Constant, Cast, Coalesce, Conjunct(And, Or), FieldReference, Switch, Lambda, Try.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialForm</span> : <span class="keyword">public</span> Expr;</span><br></pre></td></tr></table></figure>
<h2 id="表达式的执行链路"><a href="#表达式的执行链路" class="headerlink" title="表达式的执行链路"></a><strong>表达式的执行链路</strong></h2><h3 id="相关的背景"><a href="#相关的背景" class="headerlink" title="相关的背景"></a>相关的背景</h3><h4 id="输入-ExecCtx"><a href="#输入-ExecCtx" class="headerlink" title="输入: ExecCtx"></a>输入: ExecCtx</h4><p>在上一节介绍过：<a href="https://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/#EvalCtx">https://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/#EvalCtx</a> 。这里的输入是整个表达式的行。</p>
<p>考虑一个情况，比如输入来自 TableScan 之类的，那么这里就很可能是 Lazy 的或者是编码的输入。</p>
<h4 id="输入-Constant-FieldReference"><a href="#输入-Constant-FieldReference" class="headerlink" title="输入: Constant / FieldReference"></a>输入: Constant / FieldReference</h4><p>我们不打算太前面介绍一些特殊表达式，但是连 Constant 和 FieldRef 都不知道的话输入就没法介绍下去了。</p>
<p>关于 Constant 和 FieldReference 感觉是大家都有的表达式类型，但是 Constant 比较好玩的一点是，可能是因为复用代码或者内存不好管理，感觉 Velox 中 Scalar 是用 <code>ConstantVector</code> 存储的…</p>
<p>这两个结构如下 ( Vector 一些粗略介绍见 <a href="https://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/">https://blog.mwish.me/2024/01/24/Expression-Execution-in-Velox-Part-1-Basics-and-UDF/</a> ）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstantExpr</span> : <span class="keyword">public</span> SpecialForm &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 内部生成的 Constant column</span></span><br><span class="line">  <span class="comment">// 因为这个 constant value 构造来自于 VectorPtr value, 所以会在这上面包一层 Constant.</span></span><br><span class="line">  VectorPtr sharedConstantValue_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以名称的形式来 Bind 在:</span></span><br><span class="line"><span class="comment">// 1. EvalCtx 输入行的一个字段上(inputs_.empty() 的时候, 会在执行的时候从 inputRow 拿到输入).</span></span><br><span class="line"><span class="comment">// 2. Inputs 仅包含一个表达式时, 在该表达式的输出上( `inputs_[0].eval` ).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 值得一提的是, 如果输出来自表达式之类的, 这里的输出会尝试拍平, 即会尝试弄成</span></span><br><span class="line"><span class="comment">// Flatten 的结构, 解掉一些 Peeling</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FieldReference</span> : <span class="keyword">public</span> SpecialForm &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> std::string field_;</span><br><span class="line">  <span class="type">int32_t</span> index_ = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这两者都会尝试计算，然后每次把值输出。这里会尽量尝试直接 reuse Input，然后 reuse 失败才会 <code>EvalCtx::moveOrCopyResult</code> 去输出结果。这里还有一些细节但感觉现在介绍还是过早了，现在把他们当成表达式输入就行，最后在 SpecialForm 介绍。</p>
<h4 id="基础的优化手段和-Compute-Metadata"><a href="#基础的优化手段和-Compute-Metadata" class="headerlink" title="基础的优化手段和 Compute Metadata"></a>基础的优化手段和 Compute Metadata</h4><p>这里可以参考下面几个链接，讲过的东西再讲一遍就不太好了。</p>
<ol>
<li>官方博客：<a target="_blank" rel="noopener" href="https://facebookincubator.github.io/velox/develop/expression-evaluation.html">https://facebookincubator.github.io/velox/develop/expression-evaluation.html</a></li>
<li>Velox 发表的论文：<a target="_blank" rel="noopener" href="https://engineering.fb.com/2023/03/09/open-source/velox-open-source-execution-engine/">https://engineering.fb.com/2023/03/09/open-source/velox-open-source-execution-engine/</a></li>
<li>和我之前对论文的 comment: <a href="https://blog.mwish.me/2022/11/13/Introduction-to-velox/">https://blog.mwish.me/2022/11/13/Introduction-to-velox/</a></li>
</ol>
<p>这里需要知道的是：</p>
<ol>
<li>CSE 识别之类的东西是在 Compiler 的地方发现的，但是会在执行的时候 aware 一些 CSE。具体来说，它会计算某个 child 是否被多次 ref，如果被多次 Ref 的话，可能会尝试缓存计算的结果，并且每次做增量计算（具体而言，对于一个 EvalCtx 和一组输入，一个共享表达式，多次计算的 Selection 可能有重合，也有不重合的地方。每缓存算过的地方，新算没算过的地方即可，这里也是当作计算本身的 cost 比较高？）</li>
<li>Constant Folding 之类的也是 ExprSet 之类的地方发现处理的，会在 Expr::eval 之前，具体代码也在下面：</li>
</ol>
<p>编译的时候 （ <code>compileRewrittenExpression</code> ) 这里会调用 <code>Expr::computeMetadata</code>. 之前的论文介绍，关于 Metadata 的部分我们跳过了很多，但是这节竟然要深入细节，就要用罗列 API 的气势讲讲这些。这个函数的开头会计算所有 children 的表达式，如果已经计算完成的话，不会重复计算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expr::computeMetadata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (metaDataComputed_) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute metadata for all the inputs.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; input : inputs_) &#123;</span><br><span class="line">    input-&gt;<span class="built_in">computeMetadata</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，Constant Folding 的逻辑也在 <code>compileRewrittenExpression</code> 中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">result-&gt;<span class="built_in">computeMetadata</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the expression is constant folding it is redundant.</span></span><br><span class="line"><span class="keyword">auto</span> folded = enableConstantFolding &amp;&amp; !isConstantExpr</span><br><span class="line">    ? <span class="built_in">tryFoldIfConstant</span>(result, scope)</span><br><span class="line">    : result;</span><br><span class="line">scope-&gt;visited[expr.<span class="built_in">get</span>()] = folded;</span><br><span class="line"><span class="keyword">return</span> folded;</span><br></pre></td></tr></table></figure>
<h5 id="distinctFields-multiplyReferencedFields-sameAsParentDistinctFields"><a href="#distinctFields-multiplyReferencedFields-sameAsParentDistinctFields" class="headerlink" title="distinctFields, multiplyReferencedFields, sameAsParentDistinctFields"></a>distinctFields, multiplyReferencedFields, sameAsParentDistinctFields</h5><p><img src="https://image.mwish.me/blog-image/2940558373116012940.png" alt="img"></p>
<p>上图是一张非常好的图，介绍了 distinctField 的计算逻辑（但是没有写 MultiReference）。简单的说，这里输入可以调整为各个 FieldReference，然后 Expr 会维护两个变量：<code>distinctFields</code>, <code>multiReferencedFields</code>，具体而言，这里认为所有的对 ExecCtx 中 Row Input 输入的 Ref 都是 <code>FieldReference</code>, 这个时候它会有如下规则：</p>
<p>对于一个表达式，它会 Merge 所有子表达式的 Input 的 FieldReference。<code>FieldReference</code> 表达式本身只会有自己的 <code>distinctField</code>，那么下游的 <code>multiReferencedFields</code> 会直接走到 <code>mutliReferencedFields</code> 中。</p>
<ol>
<li>第一次遇到，并且没有在 <code>mutliReferencedFields</code>，会放到 <code>distinctField</code> 中</li>
<li>多次遇到会放到 <code>multiReferncedFields</code> 中</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expr::mergeFields</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;FieldReference*&gt;&amp; distinctFields,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::unordered_set&lt;FieldReference*&gt;&amp; multiplyReferencedFields,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;FieldReference*&gt;&amp; moreFields)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>* newField : moreFields) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isMember</span>(distinctFields, *newField)) &#123;</span><br><span class="line">      multiplyReferencedFields.<span class="built_in">insert</span>(newField);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      distinctFields.<span class="built_in">emplace_back</span>(newField);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expr::computeDistinctFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在调用这个之前这块( distinctFields_, multiplyReferencedFields_ )应该是 empty 的.</span></span><br><span class="line">  <span class="comment">// 合并所有子表达式的 distinctFields_, 把出现多次的放到 multiplyReferencedFields_ 里面.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; input : inputs_) &#123;</span><br><span class="line">    <span class="built_in">mergeFields</span>(</span><br><span class="line">        distinctFields_, multiplyReferencedFields_, input-&gt;distinctFields_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="propagatesNulls"><a href="#propagatesNulls" class="headerlink" title="propagatesNulls"></a>propagatesNulls</h5><p>这里我们在 VectorFunction 那讲过类似的，即是否 null-in-null-out。</p>
<p>这里 Velox 的表达式系统拆分了两套接口（见： <a target="_blank" rel="noopener" href="https://github.com/facebookincubator/velox/pull/5287">https://github.com/facebookincubator/velox/pull/5287</a> ）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">propagateNulls</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">computePropagatesNulls</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>对于 VectorFunction 的表达式, 从 VectorFuction 上直接拿到 propagateNull 就可以了. Expr 上也有 <code>bool propagateNulls() const</code> 的接口.</li>
<li>对于 SpecialForm, 额外从 <code>!vectorFunction</code> 来计算 propagateNulls.</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (3) Compute propagatesNulls_.</span></span><br><span class="line"><span class="comment">// propagatesNulls_ is true iff a null in any of the columns this</span></span><br><span class="line"><span class="comment">// depends on makes the Expr null.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Constant, FieldReference, CastExpr, SpecialForm 这些当成 Vector 来处理.</span></span><br><span class="line"><span class="comment">// Q: 为什么 SpecialCase 要这么处理呢?</span></span><br><span class="line"><span class="comment">// A: Vector 直接用里头的就可以了. Constant, FieldReference, CastExpr 这些</span></span><br><span class="line"><span class="comment">//    是零条/多条输入流 - 抛出 null 的, 和正常函数一起处理, if/switch/try 这种就</span></span><br><span class="line"><span class="comment">//    自己 compute 了</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isSpecialForm</span>() &amp;&amp; !<span class="built_in">is</span>&lt;ConstantExpr&gt;() &amp;&amp; !<span class="built_in">is</span>&lt;FieldReference&gt;() &amp;&amp;</span><br><span class="line">    !<span class="built_in">is</span>&lt;CastExpr&gt;()) &#123;</span><br><span class="line">  <span class="built_in">as</span>&lt;SpecialForm&gt;()-&gt;<span class="built_in">computePropagatesNulls</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (vectorFunction_ &amp;&amp; !vectorFunction_-&gt;<span class="built_in">isDefaultNullBehavior</span>()) &#123;</span><br><span class="line">    propagatesNulls_ = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// vectorFunction 已经是 defaultNull. 或者是 Const, fieldRef, Cast 这样的.</span></span><br><span class="line">    <span class="comment">// 现在要检查 inputs_ 的 NullPropagating.</span></span><br><span class="line">    <span class="comment">// 规则:</span></span><br><span class="line">    <span class="comment">// * 整个表达式的输入来源于所有子表达式的输入, 根输入是 `distinctFields_`.</span></span><br><span class="line">    <span class="comment">// * input 要么是 PropagateNull, 要么不是</span></span><br><span class="line">    <span class="comment">// * 那么, 如果自身是 PropagateNull, 然后如果 `!PropagateNull` 的子表达式中,</span></span><br><span class="line">    <span class="comment">//   全部是 `distinctFields_` 的子集, 这里输入中如果有任何一个 Null, 那么</span></span><br><span class="line">    <span class="comment">//   返回就是 Null.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Logic for handling default-null vector functions.</span></span><br><span class="line">    <span class="comment">// cast, constant and fieldReference expressions act as vector functions</span></span><br><span class="line">    <span class="comment">// with default null behavior.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the function has default null behavior, the Expr propagates nulls if</span></span><br><span class="line">    <span class="comment">// the set of fields null-propagating arguments depend on is a superset of</span></span><br><span class="line">    <span class="comment">// the fields non null-propagating arguments depend on.</span></span><br><span class="line">    std::unordered_set&lt;FieldReference*&gt; nullPropagating, nonNullPropagating;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; input : inputs_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (input-&gt;propagatesNulls_) &#123;</span><br><span class="line">        nullPropagating.<span class="built_in">insert</span>(</span><br><span class="line">            input-&gt;distinctFields_.<span class="built_in">begin</span>(), input-&gt;distinctFields_.<span class="built_in">end</span>());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nonNullPropagating.<span class="built_in">insert</span>(</span><br><span class="line">            input-&gt;distinctFields_.<span class="built_in">begin</span>(), input-&gt;distinctFields_.<span class="built_in">end</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// propagatesNulls_ is true if nonNullPropagating is subset of</span></span><br><span class="line">    <span class="comment">// nullPropagating.</span></span><br><span class="line">    propagatesNulls_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* field : nonNullPropagating) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!nullPropagating.<span class="built_in">count</span>(field)) &#123;</span><br><span class="line">        propagatesNulls_ = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到一个逻辑，即  vectorFunction 已经不是 nullPropagete 的情况下肯定不是 <code>nullPropagete</code>。<code>vectorFunction</code> 是 nullPropagete 的情况下，需要检查所有的输入。这里有个性质比较好玩：</p>
<ul>
<li>抽取所有 nullProgate 的 Input Fields 和所有 !nullPropagate 的 Input Fields</li>
<li>如果 !nullPropagate 是 nullPropagate 的子集，那么任何一个 child 的 <code>!nullPropagate</code> 列，都会产生一个 null input，然后目标是 null，所以是 nullPropagate 的</li>
<li>反之，不是 nullPropagate 的</li>
</ul>
<h5 id="Determinstic"><a href="#Determinstic" class="headerlink" title="Determinstic"></a>Determinstic</h5><p>是否是确定性的表达式。这里逻辑很简单，我就不讲了…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) Compute deterministic_.</span></span><br><span class="line"><span class="comment">// An expression is deterministic if it is a deterministic function call or a</span></span><br><span class="line"><span class="comment">// special form, and all its inputs are also deterministic.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 注意到这个 desterminstic 好像不是递归的，只是单纯的看自己的 deterministic_.</span></span><br><span class="line"><span class="comment">// 所以 SpecialForm 里面的 inputs_ 本身可以是 deterministic 的, 然后后面再去</span></span><br><span class="line"><span class="comment">// 跟子表达式去处理 &amp; desterminstic.</span></span><br><span class="line"><span class="keyword">if</span> (vectorFunction_) &#123;</span><br><span class="line">  <span class="comment">// 利用 vectorFunction_ 的 isDeterministic() 方法</span></span><br><span class="line">  deterministic_ = vectorFunction_-&gt;<span class="built_in">isDeterministic</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">VELOX_CHECK</span>(<span class="built_in">isSpecialForm</span>());</span><br><span class="line">  deterministic_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; input : inputs_) &#123;</span><br><span class="line">  deterministic_ &amp;= input-&gt;deterministic_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="hasConditions"><a href="#hasConditions" class="headerlink" title="hasConditions"></a>hasConditions</h5><p>这个任何一个子表达式包含 condition 就会判断，逻辑很弱智：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true if input expression or any sub-expression is an IF, AND or OR.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasConditionals</span><span class="params">(Expr* expr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (expr-&gt;<span class="built_in">isConditional</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; child : expr-&gt;<span class="built_in">inputs</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">hasConditionals</span>(child.<span class="built_in">get</span>())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Expr-for-VectorFunction"><a href="#Expr-for-VectorFunction" class="headerlink" title="Expr for VectorFunction"></a>Expr for VectorFunction</h3><p>我们以下列简单的表达式来表示这里的逻辑：</p>
<ol>
<li><code>1</code></li>
<li><code>1 + a</code></li>
<li><code>(1 + a) * 2 + b</code></li>
</ol>
<p>我们也补上官方的一张图，作为一个比较好的参考</p>
<p><img src="https://image.mwish.me/blog-image/1095838213981124704.png" alt="img"></p>
<p>(这张图少了 <code>evalWithMemo</code>: <a target="_blank" rel="noopener" href="https://facebookincubator.github.io/velox/develop/expression-evaluation.html#memoizing-the-dictionaries">https://facebookincubator.github.io/velox/develop/expression-evaluation.html#memoizing-the-dictionaries</a> )</p>
<p>我们可以在下图画出一个实际的路线图：</p>
<p><img src="https://image.mwish.me/blog-image/expr-eval-code.png" alt="expr-eval-code"></p>
<h4 id="Flat-no-null-fast-path"><a href="#Flat-no-null-fast-path" class="headerlink" title="Flat no null fast path"></a>Flat no null fast path</h4><p>这一段可以见下面的环节，官方文档说的很好。主要是在 ML 之类的场景，处理 encoding 和 Null 本身有一定开销。官方博客这段放在比较后头，但是比较早介绍这个能比较快的 introduce 一个不处理 Null、不处理 encoding 的简单模型，我们可以在这个模型上再扩展出后续的能力，所以我觉得这样讲也不坏。</p>
<p><a target="_blank" rel="noopener" href="https://facebookincubator.github.io/velox/develop/expression-evaluation.html#flat-no-nulls-fast-path">https://facebookincubator.github.io/velox/develop/expression-evaluation.html#flat-no-nulls-fast-path</a></p>
<p>这段逻辑的入口在下面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expr::eval</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SelectivityVector&amp; rows,</span></span></span><br><span class="line"><span class="params"><span class="function">    EvalCtx&amp; context,</span></span></span><br><span class="line"><span class="params"><span class="function">    VectorPtr&amp; result,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ExprSet* parentExprSet)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsFlatNoNullsFastPath_ &amp;&amp; context.<span class="built_in">throwOnError</span>() &amp;&amp;</span><br><span class="line">      context.<span class="built_in">inputFlatNoNulls</span>() &amp;&amp; rows.<span class="built_in">countSelected</span>() &lt; <span class="number">1&#x27;000</span>) &#123;</span><br><span class="line">    <span class="comment">// 满足了 ML 那种 FastPath 的条件, 执行 FlatNoNull 函数</span></span><br><span class="line">    <span class="comment">// 主要是在 ML 之类的场景，处理 encoding 和 Null 本身有一定开销, 框架就不处理了.</span></span><br><span class="line">    <span class="comment">// 具体见这个 patch: https://github.com/facebookincubator/velox/pull/1943</span></span><br><span class="line">    <span class="comment">// 把细节说的比较清楚.</span></span><br><span class="line">    <span class="built_in">evalFlatNoNulls</span>(rows, context, result, parentExprSet);</span><br><span class="line">    <span class="built_in">checkResultInternalState</span>(result);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expr::evalFlatNoNulls</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SelectivityVector&amp; rows,</span></span></span><br><span class="line"><span class="params"><span class="function">    EvalCtx&amp; context,</span></span></span><br><span class="line"><span class="params"><span class="function">    VectorPtr&amp; result,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ExprSet* parentExprSet)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">shouldEvaluateSharedSubexp</span>()) &#123;</span><br><span class="line">    <span class="built_in">evaluateSharedSubexpr</span>(</span><br><span class="line">        rows,</span><br><span class="line">        context,</span><br><span class="line">        result,</span><br><span class="line">        [&amp;](<span class="type">const</span> SelectivityVector&amp; rows,</span><br><span class="line">            EvalCtx&amp; context,</span><br><span class="line">            VectorPtr&amp; result) &#123;</span><br><span class="line">          <span class="built_in">evalFlatNoNullsImpl</span>(rows, context, result, parentExprSet);</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">evalFlatNoNullsImpl</span>(rows, context, result, parentExprSet);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们观测到有一段 <code>shouldEvaluateSharedSubexp</code> 和 <code>evaluateSharedSubexpr</code> ，这些是 MultiRef 的 CSE 表达式求值的逻辑。我们下一节介绍。</p>
<p>我们直接来贴 <code>evalFlatNoNullsImpl</code> 的逻辑，关注几个点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExprExceptionContext exprExceptionContext&#123;<span class="keyword">this</span>, context.<span class="built_in">row</span>(), parentExprSet&#125;;</span><br><span class="line"><span class="comment">// 内部用 ExceptionContextSetter 来包装 `ExprExceptionContext`, </span></span><br><span class="line"><span class="comment">// 添加异常的时候打印这个表达式的逻辑.</span></span><br><span class="line"><span class="function">ExceptionContextSetter <span class="title">exceptionContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;parentExprSet ? onTopLevelException : onException,</span></span></span><br><span class="line"><span class="params"><span class="function">     parentExprSet ? (<span class="type">void</span>*)&amp;exprExceptionContext : <span class="keyword">this</span>&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里是异常处理的上下文。Velox 使用了一个 <code>ThreadLocal</code> 的 <code>ExceptionContext</code>, 在抛出异常的时候，这里会加入 <code>ExceptionContext</code> 里面的字符串。这里内容是加上了这个表达式的 ToString，来在抛异常的时候，能够定位到表达式的上下文。</p>
<p>我们再看下面具体的逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expr::evalFlatNoNullsImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SelectivityVector&amp; rows,</span></span></span><br><span class="line"><span class="params"><span class="function">    EvalCtx&amp; context,</span></span></span><br><span class="line"><span class="params"><span class="function">    VectorPtr&amp; result,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ExprSet* parentExprSet)</span> </span>&#123;</span><br><span class="line">  ExprExceptionContext exprExceptionContext&#123;<span class="keyword">this</span>, context.<span class="built_in">row</span>(), parentExprSet&#125;;</span><br><span class="line">  <span class="comment">// 内部用 ExceptionContextSetter 来包装 `ExprExceptionContext`, </span></span><br><span class="line">  <span class="comment">// 添加异常的时候打印这个表达式的逻辑.</span></span><br><span class="line">  <span class="function">ExceptionContextSetter <span class="title">exceptionContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      &#123;parentExprSet ? onTopLevelException : onException,</span></span></span><br><span class="line"><span class="params"><span class="function">       parentExprSet ? (<span class="type">void</span>*)&amp;exprExceptionContext : <span class="keyword">this</span>&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!rows.<span class="built_in">hasSelections</span>()) &#123;</span><br><span class="line">    <span class="built_in">checkOrSetEmptyResult</span>(<span class="built_in">type</span>(), context.<span class="built_in">pool</span>(), result);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isSpecialForm</span>()) &#123;</span><br><span class="line">    <span class="comment">// If, And, Or 之类的洞都是 special case.</span></span><br><span class="line">    <span class="built_in">evalSpecialFormWithStats</span>(rows, context, result);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prepare Input</span></span><br><span class="line">  <span class="comment">// 这个地方 constantInput 还不是 inputValues_ 😅</span></span><br><span class="line">  <span class="comment">// 想了一下, 应该本质是因为 eval 的时候需要 resize, 所以特判一下.</span></span><br><span class="line">  inputValues_.<span class="built_in">resize</span>(inputs_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; inputs_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (constantInputs_[i]) &#123;</span><br><span class="line">      <span class="comment">// No need to re-evaluate constant expression. Simply move constant values</span></span><br><span class="line">      <span class="comment">// from constantInputs_.</span></span><br><span class="line">      inputValues_[i] = std::<span class="built_in">move</span>(constantInputs_[i]);</span><br><span class="line">      <span class="comment">// 这里是 constant 的时候, 需要 resize 到 `rows.end()`.</span></span><br><span class="line">      inputValues_[i]-&gt;<span class="built_in">resize</span>(rows.<span class="built_in">end</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这个地方是说 inputValues_ 里面的值不是 constant 的.</span></span><br><span class="line">      <span class="comment">// 这个时候需要通过 eval 来拿到值</span></span><br><span class="line">      inputs_[i]-&gt;<span class="built_in">evalFlatNoNulls</span>(rows, context, inputValues_[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Apply VectorFunction</span></span><br><span class="line">  <span class="comment">// 执行 Vector Function.</span></span><br><span class="line">  <span class="built_in">applyFunction</span>(rows, context, result);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Move constant values back to constantInputs_.</span></span><br><span class="line">  <span class="comment">// 恢复 constantInputs_ 的值, 等待下一次继续 resize.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; inputs_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputIsConstant_[i]) &#123;</span><br><span class="line">      constantInputs_[i] = std::<span class="built_in">move</span>(inputValues_[i]);</span><br><span class="line">      <span class="built_in">VELOX_CHECK_NULL</span>(inputValues_[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理掉非 Const 的 Input Value, 这些来自表达式的生成.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Q: reuse input 会怎么处理这些?</span></span><br><span class="line">  <span class="comment">// A: reuse input 要求输入和输出列类型相同, 然后是 unique 的.</span></span><br><span class="line">  <span class="comment">//    结果它会 reuse 相同的内存. </span></span><br><span class="line">  <span class="comment">//    重点是 `releaseInputValues` 下层 `VectorPool::release`</span></span><br><span class="line">  <span class="comment">//    的时候, 如果 !unique, 就不会把这个内存释放掉.</span></span><br><span class="line">  <span class="built_in">releaseInputValues</span>(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>applyFunction</code> 的逻辑很简单直接，就是调用我们上一节的 Expr。这里注意一下参数的 <code>ConstantInput</code> 处理，因为这里需要把 Constant 的 Size 调整到和 Row 的范围内。</p>
<p>最后有个 <code>releaseInputValues</code>, 这里需要注意的是，这里按照引用计数来释放。</p>
<p>这里介绍有点抽象，我们举例子：<code>(1 + a) * 2</code>, 这里的表达式是：</p>
<ol>
<li><code>Expr(input = ConstantExpr(1), input = FieldReference(&quot;a&quot;), vectorFunction=&quot;add&quot;)</code></li>
<li><code>Expr(input = ConstantExpr(2), input = Expr(1), vectorFunction=&quot;mul&quot;)</code></li>
</ol>
<p>在 Expr2 求值的时候，逻辑如下：</p>
<ol>
<li>假如输入有 500 行，对 Constant，resize 到 500</li>
<li>对 Expr1 递归的执行 <code>evalFlatNoNulls</code>, 拿到一个 <code>Vector</code>(是 <code>FlatVector</code>) 作为输出</li>
<li>执行的时候，发现 input reuse, 输出和输入是一个类型，选中 <code>Expr(1)</code> 结果存放表达式 <code>_ * 2</code> 的结果</li>
<li>还回去 constant</li>
<li><code>releaseInputValues</code>，这里因为有 reuse input，所以 <code>Expr(1)</code> 结果只是减少了 ref-count，没有背释放掉，这个结果被返回。</li>
</ol>
<h4 id="CSE-计算"><a href="#CSE-计算" class="headerlink" title="CSE 计算"></a>CSE 计算</h4><p><code>shouldEvaluateSharedSubexp</code> 和 <code>evaluateSharedSubexpr</code> 这些和 CSE 的计算有关。后面字典求值一些逻辑也和这块很相似。我个人认为 CSE 是出于一种设计：表达式计算相对比较重，输入容易重复。</p>
<p><img src="https://image.mwish.me/blog-image/cse-velox.png" alt="cse-velox"></p>
<p>上面是一个 CSE 的典型场景。<strong>对于同一个 Row Input</strong>, 两个表达式计算的 Selector 可能相同也可能有不重合的地方.</p>
<p>这里逻辑大概如下：</p>
<ol>
<li>（显然的）必须要 deterministic 才能执行 CSE 缓存</li>
<li>必须是 MultiReferenced 的（也很显然…)</li>
<li><code>inputs_.empty()</code>，这里逻辑是 <code>inputs_</code> 只包含子表达式，没有子表达式又是 deterministic，基本上就是 FieldRef Const 这类了，CSE 也没啥意义。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Returns true if this is a deterministic shared sub-expressions with at</span></span><br><span class="line"><span class="comment">/// least one input (i.e. not a constant or field access expression).</span></span><br><span class="line"><span class="comment">/// Evaluation of such expression is optimized by memoizing and reusing</span></span><br><span class="line"><span class="comment">/// the results of prior evaluations. That logic is implemented in</span></span><br><span class="line"><span class="comment">/// &#x27;evaluateSharedSubexpr&#x27;.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Shared Sub Expr 在 comment 里面定义又叫 CSE.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">shouldEvaluateSharedSubexp</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要是:</span></span><br><span class="line">  <span class="comment">// 1. deterministic (不 determinstic 感觉不能增量算, 要每次自己算了)</span></span><br><span class="line">  <span class="comment">// 2. 被多个表达式依赖</span></span><br><span class="line">  <span class="comment">// 3. 有 input --&gt; i.e. not a constant or field access (并非指向表达式结果的 FieldRef) </span></span><br><span class="line">  <span class="comment">//   expression. 这些表达式都很轻, 感觉也没必要 CSE 这种搞法了.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 这个还是看算子树的情况</span></span><br><span class="line">  <span class="keyword">return</span> deterministic_ &amp;&amp; isMultiplyReferenced_ &amp;&amp; !inputs_.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Expr</code> 中，有 CSE 对应的成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SharedResults</span> &#123;</span><br><span class="line">  <span class="comment">// The rows for which &#x27;sharedSubexprValues_&#x27; has a value.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// CSE 之已经计算过的 rows.</span></span><br><span class="line">  std::unique_ptr&lt;SelectivityVector&gt; sharedSubexprRows_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// If multiply referenced or literal, these are the values.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// CSE 的结果 Vector.</span></span><br><span class="line">  VectorPtr sharedSubexprValues_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Maps the inputs referenced by distinctFields_ captuered when</span></span><br><span class="line"><span class="comment">// evaluateSharedSubexpr() is called to the cached shared results.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// CSE 计算的结果, 受到 `maxSharedSubexprResultsCached()` 的限制.</span></span><br><span class="line">std::map&lt;std::vector&lt;<span class="type">const</span> BaseVector*&gt;, SharedResults&gt; sharedSubexprResults_;</span><br></pre></td></tr></table></figure>
<p>在计算的时候，逻辑如下：</p>
<ol>
<li>如果是 CSE，找到上一次的 CSE 缓存（即上面的 <code>sharedSubexprResults_</code>)</li>
<li>如果没有找到，就地对 <code>selection</code> 进行计算，并且尝试加入 CSE 缓存</li>
<li>否则，比较这次的 <code>selection</code> 和计算缓存的 <code>sharedSubexprRows_</code>，然后加入结果集。</li>
</ol>
<h4 id="EvalAll-相对-flat-no-null-多了什么"><a href="#EvalAll-相对-flat-no-null-多了什么" class="headerlink" title="EvalAll: 相对 flat no null 多了什么"></a>EvalAll: 相对 flat no null 多了什么</h4><p><code>Expr::evalAll</code> 定位有点类似 <code>evalFlatNoNulls</code>, 它是这里最泛用的一套东西了。</p>
<p>我们简单看 <code>Expr::eval</code>，它也有设置 Exception 上下文的逻辑，我们不再赘述。我们忽略掉一些 Lazy Eval 的逻辑，直接看下面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expr::eval</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">  <span class="keyword">if</span> (inputs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 没有 input 直接快速 evalAll, 这个地方应该是常量表达式或者 FieldRef 之类的</span></span><br><span class="line">    <span class="comment">// (或者甚至 non-determinstic 的生成表达式), 反正也不用管你 encoding 什么</span></span><br><span class="line">    <span class="comment">// 的, 直接 evalAll 执行最内层逻辑就是.</span></span><br><span class="line">    <span class="built_in">evalAll</span>(rows, context, result);</span><br><span class="line">    <span class="built_in">checkResultInternalState</span>(result);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">evalEncodings</span>(rows, context, result);</span><br><span class="line">  <span class="built_in">checkResultInternalState</span>(result);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里逻辑应该非常好理解，没 input 的话，那就 <code>rows</code> 本身有关的叼毛 Null 没有、Encoding 也没有了（当然，子表达式还是会产生这些逻辑的，我们延迟到 <code>Expr::evalAll</code> 处理。它为什么不先求值呢？我猜也是和 <code>Expr::eval</code> 的中间各种对 NULL 之类的优化有关）。</p>
<p>我们直接贴逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expr::evalAllImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SelectivityVector&amp; rows,</span></span></span><br><span class="line"><span class="params"><span class="function">    EvalCtx&amp; context,</span></span></span><br><span class="line"><span class="params"><span class="function">    VectorPtr&amp; result)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">VELOX_DCHECK</span>(rows.<span class="built_in">hasSelections</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isSpecialForm</span>()) &#123;</span><br><span class="line">    <span class="comment">// 开洞执行, 我也不知道咋搞的.</span></span><br><span class="line">    <span class="built_in">evalSpecialFormWithStats</span>(rows, context, result);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// tryPeelArgs 指的是内部执行的时候, 在计算了来自 input 表达式的输入之后, 是否可以尝试 Peel</span></span><br><span class="line">  <span class="comment">// (这里输入的 rows 可能在 `evalEncoding` 的时候已经 Peel 过一轮了).</span></span><br><span class="line">  <span class="comment">// 这里需要 deterministic_ 为 true, 且所有的 input 都是 Peelable 的, 然后才可以抽取公共</span></span><br><span class="line">  <span class="comment">// 字典.</span></span><br><span class="line">  <span class="type">bool</span> tryPeelArgs = deterministic_ ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">  <span class="type">bool</span> defaultNulls = vectorFunction_-&gt;<span class="built_in">isDefaultNullBehavior</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tracks what subset of rows shall un-evaluated inputs and current expression</span></span><br><span class="line">  <span class="comment">// evaluates. Initially points to rows.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 套一层本次执行的 Selector, 可以分清本次和增量的 Selector.</span></span><br><span class="line">  <span class="function">MutableRemainingRows <span class="title">remainingRows</span><span class="params">(rows, context)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (defaultNulls) &#123;</span><br><span class="line">    <span class="comment">// 以 default null 方式展开子表达式(args), 这里需要按照 Selector 增量展开 input 设置到</span></span><br><span class="line">    <span class="comment">// this-&gt;inputValues_ 里头.</span></span><br><span class="line">    <span class="comment">// defaultNull 下, 一个为 null, 结果为 null.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">evalArgsDefaultNulls</span>(</span><br><span class="line">            remainingRows,</span><br><span class="line">            [&amp;](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">              <span class="comment">// 按照上一轮剩下的 Selector 去展开 input.</span></span><br><span class="line">              inputs_[i]-&gt;<span class="built_in">eval</span>(remainingRows.<span class="built_in">rows</span>(), context, inputValues_[i]);</span><br><span class="line">              <span class="comment">// 设置是否要 peeling</span></span><br><span class="line">              tryPeelArgs =</span><br><span class="line">                  tryPeelArgs &amp;&amp; <span class="built_in">isPeelable</span>(inputValues_[i]-&gt;<span class="built_in">encoding</span>());</span><br><span class="line">            &#125;,</span><br><span class="line">            context,</span><br><span class="line">            result)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// !defaultNulls 下, 一个为 null, 结果不一定为 Null</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">evalArgsWithNulls</span>(</span><br><span class="line">            remainingRows,</span><br><span class="line">            [&amp;](<span class="keyword">auto</span> i) &#123;</span><br><span class="line">              inputs_[i]-&gt;<span class="built_in">eval</span>(remainingRows.<span class="built_in">rows</span>(), context, inputValues_[i]);</span><br><span class="line">              tryPeelArgs =</span><br><span class="line">                  tryPeelArgs &amp;&amp; <span class="built_in">isPeelable</span>(inputValues_[i]-&gt;<span class="built_in">encoding</span>());</span><br><span class="line">            &#125;,</span><br><span class="line">            context,</span><br><span class="line">            result)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 如果有 tryPeel 的话, 尝试 applyFunctionWithPeeling. </span></span><br><span class="line">  <span class="comment">// 2. 否则执行 applyFunction, 直接 apply. 里面在参数少的时候可能也会展开(即字典处理，但是不会减少输入参数)</span></span><br><span class="line">  <span class="keyword">if</span> (!tryPeelArgs ||</span><br><span class="line">      !<span class="built_in">applyFunctionWithPeeling</span>(remainingRows.<span class="built_in">rows</span>(), context, result)) &#123;</span><br><span class="line">    <span class="built_in">applyFunction</span>(remainingRows.<span class="built_in">rows</span>(), context, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write non-selected rows in remainingRows as nulls in the result if some</span></span><br><span class="line">  <span class="comment">// rows have been skipped.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 产生了新的 Null, 需要 Deselect.</span></span><br><span class="line">  <span class="keyword">if</span> (remainingRows.<span class="built_in">hasChanged</span>()) &#123;</span><br><span class="line">    <span class="built_in">addNulls</span>(rows, remainingRows.<span class="built_in">rows</span>().<span class="built_in">asRange</span>().<span class="built_in">bits</span>(), context, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">releaseInputValues</span>(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们观察到多的地方是：</p>
<ol>
<li>Null 的处理 ( <code>evalArgsDefaultNulls</code>, <code>evalArgsWithNulls</code>)</li>
<li>Peeling 的处理 （这个我们可以放在下一 Part 介绍）</li>
</ol>
<p>我们观察一下这里 Null 的处理，非 Default Null 的处理是最简单的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里不会按照 Null 来增量展开, 但是会按照 Error 来做增量展开.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EvalArg&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Expr::evalArgsWithNulls</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MutableRemainingRows&amp; rows,</span></span></span><br><span class="line"><span class="params"><span class="function">    EvalArg evalArg,</span></span></span><br><span class="line"><span class="params"><span class="function">    EvalCtx&amp; context,</span></span></span><br><span class="line"><span class="params"><span class="function">    VectorPtr&amp; result)</span> </span>&#123;</span><br><span class="line">  inputValues_.<span class="built_in">resize</span>(inputs_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; inputs_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="built_in">evalArg</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (!rows.<span class="built_in">deselectErrors</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!rows.<span class="built_in">rows</span>().<span class="built_in">hasSelections</span>()) &#123;</span><br><span class="line">    <span class="built_in">releaseInputValues</span>(context);</span><br><span class="line">    <span class="built_in">setAllNulls</span>(rows.<span class="built_in">originalRows</span>(), context, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只要处理错误，然后返回即可（ <code>deselectErrors</code> ）。</p>
<p>有 Null 的地方逻辑也比较简单，维护一个 <code>MutableRemainingRows</code> 对象，然后每次反选 Null 的地方：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 default null 方式展开子表达式(args), 这里需要按照 Selector 增量展开 input 的表达式.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return false 表示没有任何输入需要执行了.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EvalArg&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Expr::evalArgsDefaultNulls</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MutableRemainingRows&amp; rows,</span></span></span><br><span class="line"><span class="params"><span class="function">    EvalArg evalArg,</span></span></span><br><span class="line"><span class="params"><span class="function">    EvalCtx&amp; context,</span></span></span><br><span class="line"><span class="params"><span class="function">    VectorPtr&amp; result)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function">LocalDecodedVector <span class="title">decoded</span><span class="params">(context)</span></span>;</span><br><span class="line">  <span class="comment">// Store pre-existing errors locally and clear them from</span></span><br><span class="line">  <span class="comment">// &#x27;context&#x27;. We distinguish between argument errors and</span></span><br><span class="line">  <span class="comment">// pre-existing ones.</span></span><br><span class="line">  <span class="keyword">if</span> (context.<span class="built_in">errors</span>()) &#123;</span><br><span class="line">    context.<span class="built_in">swapErrors</span>(originalErrors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inputValues_.<span class="built_in">resize</span>(inputs_.<span class="built_in">size</span>());</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">ScopedVarSetter <span class="title">throwErrors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        context.mutableThrowOnError(), throwArgumentErrors(context))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; inputs_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="comment">// 展开 this-&gt;inputs_ 的 Arg</span></span><br><span class="line">      <span class="built_in">evalArg</span>(i);</span><br><span class="line">      <span class="comment">// 拿到一轮 flatNull.</span></span><br><span class="line">      <span class="type">const</span> <span class="type">uint64_t</span>* flatNulls = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">auto</span>&amp; arg = inputValues_[i];</span><br><span class="line">      <span class="keyword">if</span> (arg-&gt;<span class="built_in">mayHaveNulls</span>()) &#123;</span><br><span class="line">        <span class="comment">// default eval. mayHaveNull 的时候, 会把 null 的位置标记出来.</span></span><br><span class="line">        <span class="comment">// 这里的 rows.rows() 是一句 filter 过一轮的, 即前面的参数标注为 null 的</span></span><br><span class="line">        <span class="comment">// 后面也不用解析了. 这个感觉可以减轻一些比较重的地方的计算, 这块见:</span></span><br><span class="line">        <span class="comment">// https://github.com/facebookincubator/velox/pull/3189</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 这个地方通过 DecodedVector 只是为了拿到 Null, 和 Peel 其实关系不大.</span></span><br><span class="line">        decoded.<span class="built_in">get</span>()-&gt;<span class="built_in">decode</span>(*arg, rows.<span class="built_in">rows</span>());</span><br><span class="line">        flatNulls = decoded.<span class="built_in">get</span>()-&gt;<span class="built_in">nulls</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// A null with no error deselects the row.</span></span><br><span class="line">      <span class="comment">// An error adds itself to argument errors.</span></span><br><span class="line">      <span class="keyword">if</span> (context.<span class="built_in">errors</span>()) &#123;</span><br><span class="line">        <span class="comment">/// ...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flatNulls) &#123;</span><br><span class="line">        rows.<span class="built_in">deselectNulls</span>(flatNulls);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!rows.<span class="built_in">rows</span>().<span class="built_in">hasSelections</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mergeOrThrowArgumentErrors</span>(</span><br><span class="line">      rows.<span class="built_in">rows</span>(), originalErrors, argumentErrors, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果所有行都被 deselect 了, 那就可以不用执行后面的逻辑了.</span></span><br><span class="line">  <span class="keyword">if</span> (!rows.<span class="built_in">deselectErrors</span>()) &#123;</span><br><span class="line">    <span class="built_in">releaseInputValues</span>(context);</span><br><span class="line">    <span class="built_in">setAllNulls</span>(rows.<span class="built_in">originalRows</span>(), context, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会看到这里有个相对 Hack 的地方是借助了 <code>LocalDecodedVector</code>。我们之前没介绍过 <code>DecodedVector</code> 的逻辑，这玩意在官方链接 <a target="_blank" rel="noopener" href="https://facebookincubator.github.io/velox/develop/dictionary-encoding.html#decodedvector">https://facebookincubator.github.io/velox/develop/dictionary-encoding.html#decodedvector</a> 提到。Velox 的 Vector 对象可以是多层的，比如：<code>Dict(DICT(DICT(T)</code>, 而每层都可能包含一些 Null。<code>DecodedVector</code> 逻辑是拍平成一层，即 <code>DICT(DICT(DICT(Flat)))</code> -&gt; <code>DICT(Flat)</code>，然后也获取真正的内层 Nulls。这里通过 DecodedVector 来拿到真正的 nulls，然后反选这些 Nulls。从而避免这些行的表达式执行。</p>
<h4 id="Encoding-Peeling"><a href="#Encoding-Peeling" class="headerlink" title="Encoding - Peeling"></a>Encoding - Peeling</h4><p>Peeling 的逻辑在 <code>evalEncoding</code> 内部，应该是这里比较难读懂的一块逻辑，而且实际上在代码里，Peeling 分为了两部分：</p>
<ol>
<li><code>evalEncoding</code> 里面处理 rows 的 Peeling</li>
<li><code>evalAll</code> 里面 <code>applyFunctionWithPeeling</code>，处理子表达式输入的 Peeling。</li>
</ol>
<p>我们先简单介绍一下 Peeling, Peeling 实际上是一种 <strong>单个或者多个表达式的 DICT 剥离</strong>。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Few important examples of how vectors are peeled:</span></span><br><span class="line"><span class="comment">/// 1. Common dictionary layers are peeled</span></span><br><span class="line"><span class="comment">///    Input Vectors: Dict1(Dict2(Flat1)), Dict1(Dict2(Const1)),</span></span><br><span class="line"><span class="comment">///                   Dict1(Dict2(Dict3(Flat2)))</span></span><br><span class="line"><span class="comment">///    Peeled Vectors: Flat, Const1, Dict3(Flat2)</span></span><br><span class="line"><span class="comment">///    peel: Dict1(Dict2) =&gt; collapsed into one dictionary</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 2. Common dictionary layers are peeled</span></span><br><span class="line"><span class="comment">///    Input Vectors: Dict1(Dict2(Flat1)), Dict1(Const1)),</span></span><br><span class="line"><span class="comment">///                   Dict1(Dict2(Dict3(Flat2)))</span></span><br><span class="line"><span class="comment">///    Peeled Vectors: Dict2(Flat), Const1, Dict2(Dict3(Flat2))</span></span><br><span class="line"><span class="comment">///    peel: Dict1</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// 3. Common dictionary layers are peeled while constant is ignored</span></span><br><span class="line"><span class="comment">///    (since all valid rows translated via the common dictionary layers would</span></span><br><span class="line"><span class="comment">///    point to the same constant index)</span></span><br><span class="line"><span class="comment">///    Input Vectors: Dict1(Dict2(Flat1)), Const1,</span></span><br><span class="line"><span class="comment">///                   Dict1(Dict2(Dict3(Flat2)))</span></span><br><span class="line"><span class="comment">///    Peeled Vectors: Flat, Const1, Dict3(Flat2)</span></span><br><span class="line"><span class="comment">///    peel: Dict1(Dict2) =&gt; collapsed into one dictionary</span></span><br></pre></td></tr></table></figure>
<p>简单的说，Peel 就是把外部的东西抠出来，然后改变 ndv，用内部的 cols 来执行。希望有更小的开销。然后执行完后，结果也可能会 Cache 起来，再包装给外侧的输出。我们举几个例子：</p>
<ol>
<li>某列 ndv 很小，返回的是一个字典，那么只要在字典上执行表达式，不用再值上执行</li>
<li>Ndv 不小，可以缓存一下，每次做增量 eval</li>
</ol>
<p>(不过我理解对于超大字典，而且 ndv 很大重复值很少，实际上这块可能是个负优化。)</p>
<p>我们简单看一下 <code>evalEncodings</code> 里的条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// NOTE(mwish): 这里 Peeling 的逻辑其实比较 Hack, 实际上分为两层:</span></span><br><span class="line"><span class="comment">/// 1. `evalEncodings`: 这里根据输入的 rows 尝试去做 Peeling.</span></span><br><span class="line"><span class="comment">/// 2. `evalAll`: 这里是真正的执行逻辑, 但是这里的输入 rows 已经是 Peeling 之后的结果了.</span></span><br><span class="line"><span class="comment">///    但还有一部分输入来自于子表达式的计算. 这里会根据 Peeling 的 rows 计算完子表达式结果</span></span><br><span class="line"><span class="comment">///    后, 根据返回值的 rows 来决定是否再做一次 Peeling.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Expr::evalEncodings</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SelectivityVector&amp; rows,</span></span></span><br><span class="line"><span class="params"><span class="function">    EvalCtx&amp; context,</span></span></span><br><span class="line"><span class="params"><span class="function">    VectorPtr&amp; result)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不是 determinstic 的, 那么就不会尝试去做 Encoding 的处理. 因为 Peeling</span></span><br><span class="line">  <span class="comment">// 本身会改变 input(可能会减少输入 size), 所以不是 determinstic 的话, 这个优化</span></span><br><span class="line">  <span class="comment">// 本身也不合法.</span></span><br><span class="line">  <span class="keyword">if</span> (deterministic_ &amp;&amp; !<span class="built_in">skipFieldDependentOptimizations</span>()) &#123;</span><br><span class="line">    <span class="type">bool</span> hasFlat = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* field : distinctFields_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isFlat</span>(*context.<span class="built_in">getField</span>(field-&gt;<span class="built_in">index</span>(context)))) &#123;</span><br><span class="line">        hasFlat = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一旦有 Flat, 这里本身都无法 Peel, 避免一轮框架开销了.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasFlat) &#123;</span><br><span class="line">      <span class="comment">/// 真正的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 公共 Encoding 匹配失败, fallback 到直接 evalWithNulls.</span></span><br><span class="line">  <span class="built_in">evalWithNulls</span>(rows, context, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No need to peel encoding or remove sure nulls for default null propagating</span></span><br><span class="line">  <span class="comment">// expressions when the expression has single parent(the expression that</span></span><br><span class="line">  <span class="comment">// reference it) and have the same distinct fields as its parent.</span></span><br><span class="line">  <span class="comment">// The reason is because such optimizations would be redundant in that case,</span></span><br><span class="line">  <span class="comment">// since they would have been performed identically on the parent.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 如果没有distinctField(什么字段都不 Ref), 或者 Parent 和自身的 distinctField</span></span><br><span class="line">  <span class="comment">// 一样(sameAsParent 需要 !isMultiplyReferenced_ 才有意义), 就不 Peeling. </span></span><br><span class="line">  <span class="comment">// 这里含义其实比较简单, Parent 传来的 Vector 已经是 Peeled 了,</span></span><br><span class="line">  <span class="comment">// Null 也已经处理了</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 这里本质就是父亲算过 Null / Distinct 的优化, 自己就不用做了.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">skipFieldDependentOptimizations</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMultiplyReferenced_ &amp;&amp; sameAsParentDistinctFields_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (distinctFields_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里需要：</p>
<ol>
<li>Deterministic</li>
<li>满足 <code>skipFieldDependentOptimizations</code>，这个地方逻辑比较有意思，比如和父亲输入一样，那么显然父表达式就会做了这个逻辑（呵呵万一你爹不 deterministic 呢 2333）</li>
<li>输入都不是 Flat。</li>
</ol>
<p>Peeling 会把行和 Selector 换成内部 Const / 字典，所以显然，它会修改 <code>EvalCtx</code>, 实际逻辑如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Typical usage pattern for peeling includes:</span></span><br><span class="line"><span class="comment">/// (See Expr::applyFunctionWithPeeling() for example usage)</span></span><br><span class="line"><span class="comment">/// 1. peeling a set of input vectors</span></span><br><span class="line"><span class="comment">/// 2. converting relevant rows (top level rows and final selection rows)</span></span><br><span class="line"><span class="comment">/// 3. Saving the current context and setting the peel</span></span><br><span class="line"><span class="comment">/// 4. Applying the function or moving forward with expression eval</span></span><br><span class="line"><span class="comment">/// 5. wrapping the result vector with the peel</span></span><br></pre></td></tr></table></figure>
<p>换成代码即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">VectorPtr wrappedResult;</span><br><span class="line"><span class="comment">// Attempt peeling and bound the scope of the context used for it.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ContextSaver: 用来保存当前的 Context, 主要是执行 Peeling 的时候(`peelEncodings`),</span></span><br><span class="line"><span class="comment">// 会修改 EvalCtx 和 Row 的数量, 所以需要在执行完之后恢复.</span></span><br><span class="line"><span class="built_in">withContextSaver</span>([&amp;](ContextSaver&amp; saveContext) &#123;</span><br><span class="line">  LocalSelectivityVector <span class="built_in">newRowsHolder</span>(context);</span><br><span class="line">  LocalSelectivityVector <span class="built_in">finalRowsHolder</span>(context);</span><br><span class="line">  LocalDecodedVector <span class="built_in">decodedHolder</span>(context);</span><br><span class="line">  <span class="keyword">auto</span> peelEncodingsResult = <span class="built_in">peelEncodings</span>(</span><br><span class="line">      context,</span><br><span class="line">      saveContext,</span><br><span class="line">      rows,</span><br><span class="line">      decodedHolder,</span><br><span class="line">      newRowsHolder,</span><br><span class="line">      finalRowsHolder);</span><br><span class="line">  <span class="comment">// 尝试给输入做 Peel, 抽取公共的 Rows, 抽取成功的话就去执行.</span></span><br><span class="line">  <span class="keyword">auto</span>* newRows = peelEncodingsResult.newRows;</span><br><span class="line">  <span class="keyword">if</span> (newRows) &#123;</span><br><span class="line">    VectorPtr peeledResult;</span><br><span class="line">    <span class="comment">// peelEncodings() can potentially produce an empty selectivity</span></span><br><span class="line">    <span class="comment">// vector if all selected values we are waiting for are nulls. So,</span></span><br><span class="line">    <span class="comment">// here we check for such a case.</span></span><br><span class="line">    <span class="keyword">if</span> (newRows-&gt;<span class="built_in">hasSelections</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (peelEncodingsResult.mayCache) &#123;</span><br><span class="line">        <span class="comment">// 对于 Constant / Dictionary Peeling, 尝试增量执行, 缓存 Eval 的结果.</span></span><br><span class="line">        <span class="built_in">evalWithMemo</span>(*newRows, context, peeledResult);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">evalWithNulls</span>(*newRows, context, peeledResult);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据 Peeling 的结果恢复外层的结果.</span></span><br><span class="line">    <span class="comment">// 这里就相当于内层执行完了, 然后反向给外层处理.</span></span><br><span class="line">    wrappedResult = context.<span class="built_in">getPeeledEncoding</span>()-&gt;<span class="built_in">wrap</span>(</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">type</span>(), context.<span class="built_in">pool</span>(), peeledResult, rows);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果能生成 newRows, 那么就可以直接返回了.</span></span><br><span class="line"><span class="comment">// 否则上面 ContextSaver 会恢复 ctx.</span></span><br><span class="line"><span class="keyword">if</span> (wrappedResult != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  context.<span class="built_in">moveOrCopyResult</span>(wrappedResult, rows, result);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里 <code>ContextSaver</code> 是在 Peel 失败的时候恢复原来的 Row 信息的。</p>
<h4 id="EvalWithNulls"><a href="#EvalWithNulls" class="headerlink" title="EvalWithNulls"></a>EvalWithNulls</h4><p><code>evalWithNulls</code> 逻辑非常简单，当表达式是 propagateNull 的时候，deselect Null input 即可。</p>
<h4 id="Dictionary-Memo"><a href="#Dictionary-Memo" class="headerlink" title="Dictionary Memo"></a>Dictionary Memo</h4><p>我们假设场景是一个 TableScan，Parquet 可能会有 Row-Group 级别的 Dict。这个时候，每次 Scan 产生的 Dict 大概都是同一个。我们之前介绍的 CSE 是缓存一个 row 的输出，但是 Memo 则是跨 Row Vector 缓存输出。这里对输入的要求是，表达式输入必须只能有一个，而且必须是 Dictionary。</p>
<p>这里逻辑见：<a target="_blank" rel="noopener" href="https://facebookincubator.github.io/velox/develop/expression-evaluation.html#memoizing-the-dictionaries">https://facebookincubator.github.io/velox/develop/expression-evaluation.html#memoizing-the-dictionaries</a></p>
<h3 id="Wrapup"><a href="#Wrapup" class="headerlink" title="Wrapup"></a>Wrapup</h3><p><img src="https://image.mwish.me/blog-image/expr-eval-code.png" alt="expr-eval-code"></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E7%9A%84%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">执行之前的部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E9%93%BE%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">表达式的执行链路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">2.1.</span> <span class="toc-text">相关的背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-ExecCtx"><span class="toc-number">2.1.1.</span> <span class="toc-text">输入: ExecCtx</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-Constant-FieldReference"><span class="toc-number">2.1.2.</span> <span class="toc-text">输入: Constant &#x2F; FieldReference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9A%84%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%E5%92%8C-Compute-Metadata"><span class="toc-number">2.1.3.</span> <span class="toc-text">基础的优化手段和 Compute Metadata</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#distinctFields-multiplyReferencedFields-sameAsParentDistinctFields"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">distinctFields, multiplyReferencedFields, sameAsParentDistinctFields</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#propagatesNulls"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">propagatesNulls</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Determinstic"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">Determinstic</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hasConditions"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">hasConditions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Expr-for-VectorFunction"><span class="toc-number">2.2.</span> <span class="toc-text">Expr for VectorFunction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Flat-no-null-fast-path"><span class="toc-number">2.2.1.</span> <span class="toc-text">Flat no null fast path</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSE-%E8%AE%A1%E7%AE%97"><span class="toc-number">2.2.2.</span> <span class="toc-text">CSE 计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EvalAll-%E7%9B%B8%E5%AF%B9-flat-no-null-%E5%A4%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.3.</span> <span class="toc-text">EvalAll: 相对 flat no null 多了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Encoding-Peeling"><span class="toc-number">2.2.4.</span> <span class="toc-text">Encoding - Peeling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EvalWithNulls"><span class="toc-number">2.2.5.</span> <span class="toc-text">EvalWithNulls</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dictionary-Memo"><span class="toc-number">2.2.6.</span> <span class="toc-text">Dictionary Memo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wrapup"><span class="toc-number">2.3.</span> <span class="toc-text">Wrapup</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&text=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&title=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&is_video=false&description=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Expression Execution in Velox Part 2: Expr::eval&body=Check out this article: http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&title=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&title=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&title=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&title=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&name=Expression Execution in Velox Part 2: Expr::eval&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2024/02/09/Expression-Execution-in-Velox-Part-2-Expr-eval/&t=Expression Execution in Velox Part 2: Expr::eval"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2024
    mwish
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FL51GBW6JT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FL51GBW6JT');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
