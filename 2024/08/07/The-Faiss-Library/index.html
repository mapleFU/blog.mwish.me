<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="（本文是因为笔者最近在多个社区都看到 vector searching 相关的内容，虽然工作主业和这块关系不大，但是看的多了又不懂的东西就说明该看了。这里只摘录了论文 1-5 节，后面 database 的部分会和 Vector DB 入门的 paper 一起介绍。中间 compression 的一节我看的比较吃力，略过了很多，敬请谅解。） Faiss 是 Meta 开源的向量搜索库，比较 Mat">
<meta property="og:type" content="article">
<meta property="og:title" content="The Faiss Library">
<meta property="og:url" content="http://blog.mwish.me/2024/08/07/The-Faiss-Library/index.html">
<meta property="og:site_name" content="风空之岛">
<meta property="og:description" content="（本文是因为笔者最近在多个社区都看到 vector searching 相关的内容，虽然工作主业和这块关系不大，但是看的多了又不懂的东西就说明该看了。这里只摘录了论文 1-5 节，后面 database 的部分会和 Vector DB 入门的 paper 一起介绍。中间 compression 的一节我看的比较吃力，略过了很多，敬请谅解。） Faiss 是 Meta 开源的向量搜索库，比较 Mat">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.mwish.me/blog-image/6710969848124834217.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/3349012570787576529.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/6154208128703839642.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/5456173371475461418.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/8756900833429477152.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/7634136652666670192.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/5858628296618725981.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/7616712720163447230.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/2996947872024585192.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/6246422684835866667.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/3679172661756048152.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/8331940136786927197.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/8607717129608517343.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/5048565481672880584.png">
<meta property="og:image" content="https://image.mwish.me/blog-image/1895811674982683657.png">
<meta property="article:published_time" content="2024-08-07T12:58:14.000Z">
<meta property="article:modified_time" content="2024-08-07T13:04:10.195Z">
<meta property="article:author" content="mwish">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.mwish.me/blog-image/6710969848124834217.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/logo.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico">
        
      
    
    <!-- title -->
    <title>The Faiss Library</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2024/09/01/x86-basics-and-code-analysis-with-ai/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/06/22/Task-execution-basics-in-Velox/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2024/08/07/The-Faiss-Library/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&text=The Faiss Library"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&title=The Faiss Library"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&is_video=false&description=The Faiss Library"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=The Faiss Library&body=Check out this article: http://blog.mwish.me/2024/08/07/The-Faiss-Library/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&title=The Faiss Library"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&title=The Faiss Library"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&title=The Faiss Library"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&title=The Faiss Library"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&name=The Faiss Library&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&t=The Faiss Library"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Performance-axes-of-a-vector-search-library"><span class="toc-number">2.</span> <span class="toc-text">Performance axes of a vector search library</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Distance-measures"><span class="toc-number">2.1.</span> <span class="toc-text">Distance measures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Brute-force-search"><span class="toc-number">2.2.</span> <span class="toc-text">Brute force search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Metrics-for-Approximate-Neighbor-Search"><span class="toc-number">2.3.</span> <span class="toc-text">Metrics for Approximate Neighbor Search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exploring-search-time-settings"><span class="toc-number">2.4.</span> <span class="toc-text">Exploring search-time settings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Refining-IndexRefine"><span class="toc-number">2.5.</span> <span class="toc-text">Refining ( IndexRefine )</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Compression-levels"><span class="toc-number">3.</span> <span class="toc-text">Compression levels</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-vector-codes"><span class="toc-number">3.1.</span> <span class="toc-text">The vector codes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scalar-quantizers"><span class="toc-number">3.2.</span> <span class="toc-text">Scalar quantizers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multi-codeblock-quantizers"><span class="toc-number">3.3.</span> <span class="toc-text">Multi-codeblock quantizers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-preprocessing"><span class="toc-number">3.4.</span> <span class="toc-text">Vector preprocessing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Faiss-additive-quantization-options"><span class="toc-number">3.5.</span> <span class="toc-text">Faiss additive quantization options</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-compression-benchmark"><span class="toc-number">3.6.</span> <span class="toc-text">Vector compression benchmark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-indexes"><span class="toc-number">3.7.</span> <span class="toc-text">Binary indexes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Non-exhaustive-search"><span class="toc-number">4.</span> <span class="toc-text">Non-exhaustive search</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Inverted-files"><span class="toc-number">4.1.</span> <span class="toc-text">Inverted files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graph-based"><span class="toc-number">4.2.</span> <span class="toc-text">Graph based</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IndexHNSW"><span class="toc-number">4.2.1.</span> <span class="toc-text">IndexHNSW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSG"><span class="toc-number">4.2.2.</span> <span class="toc-text">NSG</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Discussion"><span class="toc-number">4.2.3.</span> <span class="toc-text">Discussion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IVF-vs-Graph-based"><span class="toc-number">4.2.4.</span> <span class="toc-text">IVF vs. Graph-based</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">5.</span> <span class="toc-text">Reference</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        The Faiss Library
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">mwish</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-08-07T12:58:14.000Z" itemprop="datePublished">2024-08-07</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>（本文是因为笔者最近在多个社区都看到 vector searching 相关的内容，虽然工作主业和这块关系不大，但是看的多了又不懂的东西就说明该看了。这里只摘录了论文 1-5 节，后面 database 的部分会和 Vector DB 入门的 paper 一起介绍。中间 compression 的一节我看的比较吃力，略过了很多，敬请谅解。）</p>
<p>Faiss 是 Meta 开源的向量搜索库，比较 Match 数据库相关的需求。早在 2017 左右 FB 就有相关的信息和开源了，最近翻到 Arxiv 上有个 24 年的 Faiss 的 Paper （ <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2401.08281">https://arxiv.org/abs/2401.08281</a> ），比较详细的介绍了 Database 和 Vector Index 相关的内容，结合 SIGMOD’24 VectorDB 相关的 Talk ( <a target="_blank" rel="noopener" href="https://dbgroup.cs.tsinghua.edu.cn/ligl/papers/vdbms-tutorial-clean.pdf">https://dbgroup.cs.tsinghua.edu.cn/ligl/papers/vdbms-tutorial-clean.pdf</a> ) 来讨论一下</p>
<p>Faiss 是一个向量搜索、索引库。这块的 Index Building 或者构建实际上是会比较重的，而搜索也会相对比较重，所以大家会按照自己需求训练，然后去拿到 ANN 的数据。实际上这几块要 Scale 都是有比较多工程要做的。Faiss 提供了一版本基础的实现，可以作为一般的搜索实现或者一些自己写的实现的 Baseline，在召回、搜索、RAG 等领域派上用场。</p>
<p>Faiss 的论文在网上有个 2024 年的作者精简视频，是在 Rockset 的 Talk，正文大概 25min : <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=jIn2ElPSyUc&amp;ab_channel=Rockset">https://www.youtube.com/watch?v=jIn2ElPSyUc&amp;ab_channel=Rockset</a></p>
<p>本人在大学选过数据挖掘的课，但很遗憾很多相关的概念都已经还给老师了。相关内容要一边上网搜一遍回忆。如有错误敬请指正。原论文的写作还是比较易读和规范的，又不理解的地方或者好奇某个地方的来源可以翻原文，大部分地方都解释的很详细。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Embedding 是个很重要的内容，他经常被作为各种处理的 intermediate representation，自监督学习中也经常用到 embedding。ML 里面有个 end-to-end learning 的概念，即输入（语音？）直接对应到目标，当有的时候端到端很重的时候，embedding + k-means 分类相对来说就有用武之地了。上层可能会在推荐系统等地方把文本、图片转为向量/Tensor，然后在读的时候去「召回」一定的 Embedding，拿到符合要求的数据。这里一个最简的内容集合如下图。</p>
<p><img src="https://image.mwish.me/blog-image/6710969848124834217.png" alt="img"></p>
<p>Embedding 可能来自于某个 embedding extractor，通常是一个神经网络，Encoder/Decoder 能把上游 Target 和目标连接起来，在读取的时候，可能希望有 vector index，能执行 ann 等查询，在满足一定预期的情况下拿到结果。</p>
<p>Faiss 是一个 Vector Searching Toolkit，包含 index, search, cluster, compress, transform vector 的内容。这里是希望根据 embedding 来直接做相关的搜索，并提供比较完善的处理链路。本项目最早由 facebookresearch 开始，但是最近还有 Vector 处理热潮，让这波东西能被更多人用上。Faiss 不会 extract features，也不是一个服务或者一个数据库，只是一个单机的 vector 处理库。</p>
<p>在 Faiss 上最基础的 workload 是 KNN 或者 ANN，用户提供一个 vector，然后拿到「最近」的向量，这个「最近」可以由向量的欧几里得距离来表示。</p>
<h2 id="Performance-axes-of-a-vector-search-library"><a href="#Performance-axes-of-a-vector-search-library" class="headerlink" title="Performance axes of a vector search library"></a>Performance axes of a vector search library</h2><p>Vector Search 可能有下面的定义，比如说对于 Vector 查询最近的向量</p>
<p>对于给定的 database vectors :<script type="math/tex">\{x_{i}, i = 1..N\} \subset \mathbb{R}^d</script> 和一个 Query vector <script type="math/tex">q \subset \mathbb{R}^d</script>, 搜索需要计算最近的一个向量。一个更常用的操作是 KNN，获取最近的 K 个向量。而还有一类搜索，对于给定的距离 <script type="math/tex">\epsilon</script>，找到小于这个距离的所有向量。这里面有几个讨论点：</p>
<h3 id="Distance-measures"><a href="#Distance-measures" class="headerlink" title="Distance measures"></a>Distance measures</h3><p><img src="https://image.mwish.me/blog-image/3349012570787576529.png" alt="img"></p>
<p>以上几种是最常见的距离，它们本身能够互相转换，但是如果是 Index 的话，很难根据一种距离定义的 Index 找到另外 Index 的搜索。</p>
<h3 id="Brute-force-search"><a href="#Brute-force-search" class="headerlink" title="Brute force search"></a>Brute force search</h3><p>实际上，大部分精准 KNN 都需要暴力搜索，论文提到这个并不是 trivial 的</p>
<blockquote>
<p>Implementing brute force search efficiently is not trivial [Chern et al., 2022, Johnson et al., 2019]. It requires</p>
<p>(1) an efficient way of computing the distances and</p>
<p>(2) for k-nearest neighbor search, an efficient way of keeping track of the k smallest distances.</p>
</blockquote>
<p>(翻了一下代码，这块好像对应 <code>IndexFlat::search</code> )</p>
<p>某种意义上，这里会需要跟用户用提供的向量来计算距离，对于上述的距离，距离的计算实现方式可能会是：</p>
<ul>
<li>自身 Batch 小的话直接 Scalar 或者并行的正常算</li>
<li>自身 Batch 大的话，可以用矩阵乘法类似的方式来计算，看代码里面有一些 <code>exhaustive_inner_product_blas</code> 这样的代码，分发到矩阵上来做计算</li>
</ul>
<p>在处理 Knn 的时候，这里有多种 Pattern:</p>
<ol>
<li>如果只有一个，用 Top1 的方式来计算</li>
<li>如果 k 的数量比较小，走 Binary Heap 来过滤</li>
<li>如果 k 的数量比较大，去定义一个 reservoir 方式，这个有点类似 DB 的 Sort，先分组无序处理，超过一定阈值之后，会有一个 Resharp 流程，拿到一个临时的阈值，然后根据这个筛选</li>
</ol>
<p>翻了下这块的代码，这里还是写的挺清楚的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Consumer</span>, <span class="keyword">class</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> Consumer::T <span class="title">dispatch_knn_ResultHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> nx,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">float</span>* vals,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int64_t</span>* ids,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> k,</span></span></span><br><span class="line"><span class="params"><span class="function">        MetricType metric,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> IDSelector* sel,</span></span></span><br><span class="line"><span class="params"><span class="function">        Consumer&amp; consumer,</span></span></span><br><span class="line"><span class="params"><span class="function">        Types... args)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_C_SEL(C, use_sel)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (k == 1) &#123;                                                           \</span></span><br><span class="line"><span class="meta">        Top1BlockResultHandler<span class="string">&lt;C, use_sel&gt;</span> res(nx, vals, ids, sel);         \</span></span><br><span class="line"><span class="meta">        return consumer.template f<span class="string">&lt;&gt;</span>(res, args...);                         \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; distance_compute_min_k_reservoir) &#123;                      \</span></span><br><span class="line"><span class="meta">        HeapBlockResultHandler<span class="string">&lt;C, use_sel&gt;</span> res(nx, vals, ids, k, sel);      \</span></span><br><span class="line"><span class="meta">        return consumer.template f<span class="string">&lt;&gt;</span>(res, args...);                         \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> &#123;                                                                \</span></span><br><span class="line"><span class="meta">        ReservoirBlockResultHandler<span class="string">&lt;C, use_sel&gt;</span> res(nx, vals, ids, k, sel); \</span></span><br><span class="line"><span class="meta">        return consumer.template f<span class="string">&lt;&gt;</span>(res, args...);                         \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_similarity_metric</span>(metric)) &#123;</span><br><span class="line">        <span class="keyword">using</span> C = CMin&lt;<span class="type">float</span>, <span class="type">int64_t</span>&gt;;</span><br><span class="line">        <span class="keyword">if</span> (sel) &#123;</span><br><span class="line">            <span class="built_in">DISPATCH_C_SEL</span>(C, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">DISPATCH_C_SEL</span>(C, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">using</span> C = CMax&lt;<span class="type">float</span>, <span class="type">int64_t</span>&gt;;</span><br><span class="line">        <span class="keyword">if</span> (sel) &#123;</span><br><span class="line">            <span class="built_in">DISPATCH_C_SEL</span>(C, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">DISPATCH_C_SEL</span>(C, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> DISPATCH_C_SEL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>库的 Python Wrapper 里面也提供了 <code>knn</code> 和 <code>knn_gpu</code> 这样的 wrapper。</p>
<p>Knn 有个很显而易见的毛病，就是这个算法完全不 Scalable，为此，实际上大家很多时候可能更倾向于 ann 做一些模糊的查询</p>
<h3 id="Metrics-for-Approximate-Neighbor-Search"><a href="#Metrics-for-Approximate-Neighbor-Search" class="headerlink" title="Metrics for Approximate Neighbor Search"></a>Metrics for Approximate Neighbor Search</h3><p>在 ann 中，用户接受不完美的结果，这给更符合需求的设计提供了空间。这里搜索来源于几个点：</p>
<blockquote>
<p>(1) how well the distance metric correlates with the item matching objective and </p>
<p>(2) the quality of ANNS</p>
</blockquote>
<p>对于第二个问题：</p>
<p>Ann 的 Accuracy 被称为 “n-recall@m”，表示在实际的 “n” 个最近中返回了 “m” 个</p>
<p>而对于 range-search，这里有 <script type="math/tex">\epsilon</script>和搜索时的允许的 <script type="math/tex">\epsilon^{'}</script>，允许的  <script type="math/tex">\epsilon^{'}</script>越大，搜索的结果会越多。</p>
<p>对于 distance metrics, 这里对于一个 Encoder C 和一个 Decoder D，有下面的衡量方式( MSE )：</p>
<p><img src="https://image.mwish.me/blog-image/6154208128703839642.png" alt="img"></p>
<p>这里也有一些资源的需求：</p>
<p>对于 Searching，有：</p>
<ol>
<li>Search time</li>
<li>Memory usage<ol>
<li>constant memory overhead -&gt; 结构的开销 </li>
<li>vector memory overhead -&gt; 存储中对应的 vector 带来的边际开销</li>
</ol>
</li>
<li>(for io) number of I/O operations (IOPS).</li>
</ol>
<p>对于 Index Build(Training), 有:</p>
<ol>
<li>index building time<ol>
<li>Training time</li>
<li>addition time per vector</li>
</ol>
</li>
<li>(for io) number of I/O operations (IOPS).</li>
</ol>
<p>关于这些东西的 tunning 也是一个 Trade off。准确的说，这里大概有几个：speed, memory usage, accuracy，这三个。</p>
<h3 id="Exploring-search-time-settings"><a href="#Exploring-search-time-settings" class="headerlink" title="Exploring search-time settings"></a>Exploring search-time settings</h3><p>这节介绍调优的内容还是非常有趣的，对于 Vector Index 通常会有一个或者多个 hyperparameter，作者表示，对于 speed / accuracy / memory usage，应该只保留 Pareto-Optimal 的参数，即定义上 Pareto Frontier 上的参数。</p>
<p>这里可能会需要一个多个参数组的笛卡尔积，但是 Faiss 因为对参数有先验知识，定义了一些剪枝的方式，来快速求出参数空间的保留参数集合。</p>
<p>在实验中，这里还拆分出了不同的配置：</p>
<ul>
<li>不同的 index 用不同的处理方式</li>
<li>Compression ( 即 Vector 的有损编码等）</li>
</ul>
<p><img src="https://image.mwish.me/blog-image/5456173371475461418.png" alt="img"></p>
<h3 id="Refining-IndexRefine"><a href="#Refining-IndexRefine" class="headerlink" title="Refining ( IndexRefine )"></a>Refining ( IndexRefine )</h3><p>Refine 这里会需要组合一个更快的 inaccurrate index 和一个准确率更高的 index。这里会先在更快的 index 拿到一组结果，再去慢的 index 精确计算这里面符合需求的数据。</p>
<blockquote>
<p>This requires the accurate index to store the vectors in a way that allows efficient random access to possibly-compressed database vectors. Some implementations use a slower storage (e.g. flash) for the second index</p>
</blockquote>
<p>Refine 这个代码也写的贼清楚：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Index that queries in a base_index (a fast one) and refines the</span></span><br><span class="line"><span class="comment"> *  results with an exact search, hopefully improving the results.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexRefine</span> : Index &#123;</span><br><span class="line">    <span class="comment">/// faster index to pre-select the vectors that should be filtered</span></span><br><span class="line">    Index* base_index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// refinement index</span></span><br><span class="line">    Index* refine_index;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> own_fields;       <span class="comment">///&lt; should the base index be deallocated?</span></span><br><span class="line">    <span class="type">bool</span> own_refine_index; <span class="comment">///&lt; same with the refinement index</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// factor between k requested in search and the k requested from</span></span><br><span class="line">    <span class="comment">/// the base_index (should be &gt;= 1)</span></span><br><span class="line">    <span class="type">float</span> k_factor = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>当然，这样两个 Index 也不是唯一的 Refine 方式，实际上，在同一个 Index 中也有类似的方式，先有一个准确度低的 Vector，再去 decompress 然后去做精细的. 学术界也提供了多种解决的方案。</p>
<h2 id="Compression-levels"><a href="#Compression-levels" class="headerlink" title="Compression levels"></a>Compression levels</h2><p>（笔者注：这一张因为笔者这方面完全没有基础，看的非常痛苦，越后面的章节越痛苦，有的地方可能就简单带过了，假以时日希望本人懂这块之后能把这里相关的内容补全）。</p>
<p>这里的 Compression 并不是我们通用的 zstd 之类的无损压缩，而是 quanitizer 这样的压缩，把原本的 embedding 映射到一个更小的空间中。定义 quantizer 为：C: <script type="math/tex">\mathbb{R}^d \rightarrow \{i = 1..K\}</script> ，和对应的 Decoder: <script type="math/tex">\{i = 1..K\} \rightarrow \mathbb{R}^d</script>，在这里，搜索的逻辑会变成:</p>
<p><img src="https://image.mwish.me/blog-image/8756900833429477152.png" alt="img"></p>
<p>这里等价于，对索引的 index 做 quantizer，然后查询的时候等价于去 Decode 这部分数据，然后拿到这部分的最小值。这里还有个 asymmetric distance computation(ADC) 和 symmetric distance computation(SDC) 的区别（下图为 SDC)：</p>
<p><img src="https://image.mwish.me/blog-image/7634136652666670192.png" alt="img"></p>
<p>这里区别主要是 ADC 更精确，SDC 开销更小。Faiss 基本上采用的是 ADC:</p>
<blockquote>
<p>Most Faiss indexes perform ADC as it is more accurate: there is no accuracy loss on the query vectors. SDC is useful when there is also a storage constraint on the queries or for indexing methods for which SDC is faster to compute than ADC.</p>
</blockquote>
<p><img src="https://image.mwish.me/blog-image/5858628296618725981.png" alt="img"></p>
<h3 id="The-vector-codes"><a href="#The-vector-codes" class="headerlink" title="The vector codes"></a>The vector codes</h3><p>理想的 Quanitizer 能最小化处理后 Vector 的 MSE, Kmeans 能比较好的做到这一点，K-means quantizer 将输入 vector 划分到 K 个 centroid，数据的表示在处理后需要<script type="math/tex">\lceil \log_{2}N \rceil</script>bits。这导致 k-means 在 accuracy 上很好，但是在 memory usage 和 encoding complexity 上，随着需要的 bits 增大而增大，Faiss 认为 k-means 实践上最好不要超过 3Bytes ( 即 16M）</p>
<h3 id="Scalar-quantizers"><a href="#Scalar-quantizers" class="headerlink" title="Scalar quantizers"></a>Scalar quantizers</h3><p>将向量的每个维度编码为一个 vector。这个比较典型的代码是对应的 <code>IndexLSH</code>，根据用户的向量输入，生成一组 threshold，然后按照大于或者小于 threshold</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * dimension 0 corresponds to the least significant bit of b[0], or</span></span><br><span class="line"><span class="comment"> * equivalently to the lsb of the first byte that is stored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fvec2bitvec</span><span class="params">(<span class="type">const</span> <span class="type">float</span>* __restrict x, <span class="type">uint8_t</span>* __restrict b, <span class="type">size_t</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d; i += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="type">uint8_t</span> w = <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint8_t</span> mask = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> nj = i + <span class="number">8</span> &lt;= d ? <span class="number">8</span> : d - i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nj; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[i + j] &gt;= <span class="number">0</span>)</span><br><span class="line">                w |= mask;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *b = w;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ScalarQuantizer 有很多对应的模式，下面代码写的比较清晰，这里大概是把一个维度映射到 <code>SQ&#123;&#125;</code> 对应的位数上，来实现一个压缩。在压缩后，向量存储会按照下列模式进行：</p>
<blockquote>
<p>The IndexRowwiseMinMax stores vectors with per-vector normalizing coefficients. The ranges are trained beforehand on a set of representative vectors.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The uniform quantizer has a range [vmin, vmax]. The range can be</span></span><br><span class="line"><span class="comment"> * the same for all dimensions (uniform) or specific per dimension</span></span><br><span class="line"><span class="comment"> * (default).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ScalarQuantizer</span> : Quantizer &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">QuantizerType</span> &#123;</span><br><span class="line">        QT_8bit,         <span class="comment">///&lt; 8 bits per component</span></span><br><span class="line">        QT_4bit,         <span class="comment">///&lt; 4 bits per component</span></span><br><span class="line">        QT_8bit_uniform, <span class="comment">///&lt; same, shared range for all dimensions</span></span><br><span class="line">        QT_4bit_uniform,</span><br><span class="line">        QT_fp16,</span><br><span class="line">        QT_8bit_direct, <span class="comment">///&lt; fast indexing of uint8s</span></span><br><span class="line">        QT_6bit,        <span class="comment">///&lt; 6 bits per component</span></span><br><span class="line">        QT_bf16,</span><br><span class="line">        QT_8bit_direct_signed, <span class="comment">///&lt; fast indexing of signed int8s ranging from</span></span><br><span class="line">                               <span class="comment">///&lt; [-128 to 127]</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">train</span><span class="params">(<span class="type">size_t</span> n, <span class="type">const</span> <span class="type">float</span>* x)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Encode a set of vectors</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param x      vectors to encode, size n * d</span></span><br><span class="line"><span class="comment">     * @param codes  output codes, size n * code_size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">compute_codes</span><span class="params">(<span class="type">const</span> <span class="type">float</span>* x, <span class="type">uint8_t</span>* codes, <span class="type">size_t</span> n)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Decode a set of vectors</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param codes  codes to decode, size n * code_size</span></span><br><span class="line"><span class="comment">     * @param x      output vectors, size n * d</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decode</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span>* code, <span class="type">float</span>* x, <span class="type">size_t</span> n)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Multi-codeblock-quantizers"><a href="#Multi-codeblock-quantizers" class="headerlink" title="Multi-codeblock quantizers"></a>Multi-codeblock quantizers</h3><p>Faiss 支持 Multi-codeblock quantizers, 形式上这里可以当成有 M 个 Vector-quantizer，每个可以产生 K 个不同的 value。这里能够产生<script type="math/tex">K^M</script> 个对应的 vector，然后 codesize 是<script type="math/tex">M\lceil \log_{2}K \rceil</script></p>
<p>Product Quantizer (PQ) 把输入向量切分为多组，然后用 kmeans quantizer 独立处理每一组。对于 PQ6x10 的 product quantizer，它切分输入为 6 个子 vector，每个 10 bits (M = 6, K = 2^10 ).</p>
<p><img src="https://image.mwish.me/blog-image/7616712720163447230.png" alt="img"></p>
<p>（这里参考了：ANN 之 Product Quantization - 名扬的文章 - 知乎 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/140548922">https://zhuanlan.zhihu.com/p/140548922</a> ，图片也来自这篇博文。）</p>
<p>Additive quantizers （加法量化器）是另一种 multi-codebook quantizer，这里可以当成 additive quantizer 由多个 sub-quantizer 组成，这里有两种：</p>
<ul>
<li>ResidualQuantizer：<a target="_blank" rel="noopener" href="https://www.assemblyai.com/blog/what-is-residual-vector-quantization/">https://www.assemblyai.com/blog/what-is-residual-vector-quantization/</a> </li>
</ul>
<p><img src="https://image.mwish.me/blog-image/2996947872024585192.png" alt="img"></p>
<ul>
<li>Local search Quantizer: 从非 optimal 的地方做 Local Search，争取找到更优的结果（这个没找到我能看懂的资料，orz）</li>
</ul>
<p>Faiss 还提供了混合 Quantizer，比如 PQ + Residual.</p>
<p>文章还提供了 Quantizer 的 Hierarchy, 这里的关键是下文：</p>
<blockquote>
<p>The implications of this hierarchy are (1) the degrees of freedom for the reproduction values of quantizer i + 1 are larger than for i, so it is more accurate (2) quantizer i+1 has a higher capacity so it consumes more resources in terms of training time and storage overhead than i.</p>
</blockquote>
<p><img src="https://image.mwish.me/blog-image/6246422684835866667.png" alt="img"></p>
<h3 id="Vector-preprocessing"><a href="#Vector-preprocessing" class="headerlink" title="Vector preprocessing"></a>Vector preprocessing</h3><blockquote>
<p>To take advantage of some quantizers, it is beneficial to apply transformations to the input vectors prior to encoding them. Many of these transformations are ddimensional rotations, that do not change comparison metrics like cosine, L2 and inner product.</p>
</blockquote>
<p>这里会做 PCA 之类的操作，尽量不改变目标 Metrics 的情况下，对输入向量处理。</p>
<h3 id="Faiss-additive-quantization-options"><a href="#Faiss-additive-quantization-options" class="headerlink" title="Faiss additive quantization options"></a>Faiss additive quantization options</h3><p>因为我看不懂 additive quantization，所以先跳过了。尴尬。。。</p>
<h3 id="Vector-compression-benchmark"><a href="#Vector-compression-benchmark" class="headerlink" title="Vector compression benchmark"></a>Vector compression benchmark</h3><p>基本上等价于 code-size 大战 MSE 了</p>
<p><img src="https://image.mwish.me/blog-image/3679172661756048152.png" alt="img"></p>
<h3 id="Binary-indexes"><a href="#Binary-indexes" class="headerlink" title="Binary indexes"></a>Binary indexes</h3><p>用 binary quantizer + hamming distance 描述。</p>
<p><img src="https://image.mwish.me/blog-image/8331940136786927197.png" alt="img"></p>
<p>这里有一些相关的 Index:</p>
<ul>
<li>IndexBinary: Binary Quantizer Index 的基类</li>
<li>IndexBinaryFlat: 暴力搜索 knn</li>
<li>IndexBinaryIVF: 借助下一节的 IVF 来做搜索</li>
<li>IndexBinaryHNSW: 用 HNSW 来做搜索</li>
<li>IndexBinaryHash: 用前缀哈希来找到相关联的 bucket 并搜索</li>
</ul>
<h2 id="Non-exhaustive-search"><a href="#Non-exhaustive-search" class="headerlink" title="Non-exhaustive search"></a>Non-exhaustive search</h2><blockquote>
<p>Non-exhaustive search is the cornerstone of fast search implementations for medium-sized datasets. In that case, the aim of the indexing method is to quickly focus on a subset of database vectors that are most likely to contain the search results.</p>
</blockquote>
<p>比较早期的方法是 LSH，我们之前还贴过代码，这里的核心是把向量映射到 bucket 上，这里的问题是：</p>
<ul>
<li>可能需要多个方向的映射，要不然很难找到关联的 bucket, 这里会增加 search time 开销</li>
<li>最早的方式并不 adaptive</li>
</ul>
<p>Tree-based Index 也被提出，这里下层寻找有点类似 KD-Tree, 但是可能用的是 kmeans 的方式来找到下一层。</p>
<p>下面指出，这两种仍然是传统 db 的思路（索引结构）来做向量索引，这几种方式都不 scalable。向量的主要方式是 IVF 和 graph-based searching</p>
<blockquote>
<p>Both in the case of LSH and tree-based methods, the hope is to extend classical database search structures to vector search, because they have a favorable complexity (constant or logarithmic in N). However, it turns out that these methods do not scale well for dimensions above 10.</p>
<p>Faiss implements two non-exhaustive search approaches that operate at different memory vs. speed tradeoffs: inverted file and graph-based.</p>
</blockquote>
<h3 id="Inverted-files"><a href="#Inverted-files" class="headerlink" title="Inverted files"></a>Inverted files</h3><p>IVF indexing is a technique that clusters the database vectors at indexing time. This clustering uses a vector quantizer (the coarse quantizer) that outputs <script type="math/tex">K_{IVF}</script> distinct indices (Faiss’s nlist parameter). The coarse quantizer’s <script type="math/tex">K_{IVF}</script> reproduction values are called centroids. The vectors of each cluster (possibly compressed) are stored contiguously into inverted lists, forming an inverted file (IVF). At search time, only a subset of <script type="math/tex">P_{IVF}</script> clusters are visited (a.k.a. nprobe). The subset is formed by searching the <script type="math/tex">P_{IVF}</script> nearest centroids, as in Equation (2).</p>
<p>以上这段直接摘抄原文了。即这里 build 的时候，根据 vector quantizer，来构成 <code>nlist</code> 个倒排，搜索的时候，这里会访问其中 P 个 ( <code>nprobe</code> )。</p>
<p>如果 nprobe 固定且 List 完全均匀，那么这里一次访问的计算距离如下（ 看意思是 IVF 需要全部访问）</p>
<p><img src="https://image.mwish.me/blog-image/8607717129608517343.png" alt="img"></p>
<p>这里实际上是不准确的，因为：</p>
<ul>
<li>随着插入，K 会增加，那么为了保证精准，P 也要增加</li>
<li>实际上 K 不一定会被全扫，如果 coarse quantization 是一个 hnsw 索引，那么可能只会粗筛选一些</li>
</ul>
<p><img src="https://image.mwish.me/blog-image/5048565481672880584.png" alt="img"></p>
<p>这里还有很多特殊的优化，比如搜索大 batch 的时候做特殊优化，做特殊的 kmeans 等等。</p>
<h3 id="Graph-based"><a href="#Graph-based" class="headerlink" title="Graph based"></a>Graph based</h3><p>Graph based 本质上是一种通用的框架，它的建模大概是，Node 是指向 Vectors 的 Index （类似另一种形式的 IVF），在 search 的时候会需要在边上游走，找到最近的 Query Vector。这里可能就类似在图上游走的逻辑了，实际搜索可能会有类似 dfs bfs 的逻辑，search time 这样就会和搜索次数挂钩：搜索次数越多，搜索越准确和越慢</p>
<p>这里的代码会通常是个通用框架，作者认为某种程度上 tree-based search 和 IVF 是 Graph 的特殊形式，因为 Graph 本身可以看作对 Database Vector 临近关系的预处理。在这种图上直接尝试完整的 knn 并不合适，因为实际上一些搜索可能会陷入 local minima，所以这里建边可能也会有指向稍微远一点节点的边。大部分 graph 会使用一些固定的出边来方便平衡 search speed 和 memory usage，这样的话我们可以很好根据搜索的点、边来确定访问的内存开销（因为对于指定参数，你的访问点、边量大概也是可预测的）。</p>
<p>Faiss 中提供了 <code>IndexHNSW</code> 和 <code>IndexNSG</code>：</p>
<h4 id="IndexHNSW"><a href="#IndexHNSW" class="headerlink" title="IndexHNSW"></a>IndexHNSW</h4><p>其中一些顶点（节点）被随机选择并提升为首先被探索的 Pivot。</p>
<p>本质上，这个有点像 SkipList，在构建的时候选取合适的地方连接起来，同时不让图陷入 local min。这里还要考虑精准度和内存占用，内存占用要加上出边的占用。</p>
<p>这个结构有个优点就是可以增量构建，就是可以动态插入 Vector</p>
<h4 id="NSG"><a href="#NSG" class="headerlink" title="NSG"></a>NSG</h4><p>NSG 从输入的 kmeans 开始构建，并且将其中一些 short-range edges 替换成 longer-range edges。NSG 不使用多层，而是用 long-range edges 来搜索，并从固定的 center point 开始搜索。</p>
<p>因为 NSG 需要 KNN 图，虽有有一些特定的优化或者特殊构建方式（比如 <code>NNDescent</code>），但是这个相对来说 build 侧还是很耗时的。此外 NSG 是不允许动态更新的</p>
<h4 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h4><p><img src="https://image.mwish.me/blog-image/1895811674982683657.png" alt="img"></p>
<p>上述是 search time 的 trade-off ，关于 build 内容如下所述</p>
<blockquote>
<p>Increasing the number of edges improves the results only to some extent: beyond 64 edges it degrades. NSG obtains better tradeoffs in general, at the cost of a longer build time. Building the input k-NN graph with NN-descent for 1M vectors takes 37 s, and about the same time with brute force search on a GPU (but in that case the k-NN graph is exact).</p>
</blockquote>
<h4 id="IVF-vs-Graph-based"><a href="#IVF-vs-Graph-based" class="headerlink" title="IVF vs. Graph-based"></a>IVF vs. Graph-based</h4><p>IVF Index 可以被看作 graph-based index 的特化版本，尤其是是当一个小的 graph-based index 被作为 coarse quantizer 的时候。在 Faiss 中，有下面的经验结论：</p>
<ul>
<li>Graph-based Indices 在内存没有过大约束，比如 1M index 以下的场景可以被使用。在 10M vector 以上，通常 construction time 会成为制约因素。</li>
<li>对于更大的 index，IVF 可能会成为仅有的选项，但是 IVF 前台可以挂一个 graph-based index 作为 coarse quantization 的优化项。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>Faiss paper: <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2401.08281">https://arxiv.org/abs/2401.08281</a></li>
<li>SIGMOD’24 Vector Database Management Techniques and Systems: <a target="_blank" rel="noopener" href="https://dbgroup.cs.tsinghua.edu.cn/ligl/papers/vdbms-tutorial-clean.pdf">https://dbgroup.cs.tsinghua.edu.cn/ligl/papers/vdbms-tutorial-clean.pdf</a></li>
<li>ANN 之 Product Quantization - 名扬的文章 - 知乎 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/140548922">https://zhuanlan.zhihu.com/p/140548922</a></li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">1.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Performance-axes-of-a-vector-search-library"><span class="toc-number">2.</span> <span class="toc-text">Performance axes of a vector search library</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Distance-measures"><span class="toc-number">2.1.</span> <span class="toc-text">Distance measures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Brute-force-search"><span class="toc-number">2.2.</span> <span class="toc-text">Brute force search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Metrics-for-Approximate-Neighbor-Search"><span class="toc-number">2.3.</span> <span class="toc-text">Metrics for Approximate Neighbor Search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exploring-search-time-settings"><span class="toc-number">2.4.</span> <span class="toc-text">Exploring search-time settings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Refining-IndexRefine"><span class="toc-number">2.5.</span> <span class="toc-text">Refining ( IndexRefine )</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Compression-levels"><span class="toc-number">3.</span> <span class="toc-text">Compression levels</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-vector-codes"><span class="toc-number">3.1.</span> <span class="toc-text">The vector codes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scalar-quantizers"><span class="toc-number">3.2.</span> <span class="toc-text">Scalar quantizers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multi-codeblock-quantizers"><span class="toc-number">3.3.</span> <span class="toc-text">Multi-codeblock quantizers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-preprocessing"><span class="toc-number">3.4.</span> <span class="toc-text">Vector preprocessing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Faiss-additive-quantization-options"><span class="toc-number">3.5.</span> <span class="toc-text">Faiss additive quantization options</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-compression-benchmark"><span class="toc-number">3.6.</span> <span class="toc-text">Vector compression benchmark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-indexes"><span class="toc-number">3.7.</span> <span class="toc-text">Binary indexes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Non-exhaustive-search"><span class="toc-number">4.</span> <span class="toc-text">Non-exhaustive search</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Inverted-files"><span class="toc-number">4.1.</span> <span class="toc-text">Inverted files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graph-based"><span class="toc-number">4.2.</span> <span class="toc-text">Graph based</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IndexHNSW"><span class="toc-number">4.2.1.</span> <span class="toc-text">IndexHNSW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSG"><span class="toc-number">4.2.2.</span> <span class="toc-text">NSG</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Discussion"><span class="toc-number">4.2.3.</span> <span class="toc-text">Discussion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IVF-vs-Graph-based"><span class="toc-number">4.2.4.</span> <span class="toc-text">IVF vs. Graph-based</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">5.</span> <span class="toc-text">Reference</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2024/08/07/The-Faiss-Library/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&text=The Faiss Library"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&title=The Faiss Library"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&is_video=false&description=The Faiss Library"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=The Faiss Library&body=Check out this article: http://blog.mwish.me/2024/08/07/The-Faiss-Library/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&title=The Faiss Library"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&title=The Faiss Library"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&title=The Faiss Library"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&title=The Faiss Library"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&name=The Faiss Library&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2024/08/07/The-Faiss-Library/&t=The Faiss Library"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2024
    mwish
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FL51GBW6JT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FL51GBW6JT');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
