<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="之前的文章 https:&#x2F;&#x2F;blog.mwish.me&#x2F;2023&#x2F;08&#x2F;03&#x2F;Arrow-Acero-Framework&#x2F; 提到了 AsyncTaskScheduler。Acero 中，这里有两种 TaskScheduler，因为历史原因存在：  AsyncTaskScheduler: 异步任务调度器，触发出不同的任务，每个任务提交需要返回一个 Result&gt;，Task 里面可以递归的添加">
<meta property="og:type" content="article">
<meta property="og:title" content="Acero Task Scheduler">
<meta property="og:url" content="http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/index.html">
<meta property="og:site_name" content="风空之岛">
<meta property="og:description" content="之前的文章 https:&#x2F;&#x2F;blog.mwish.me&#x2F;2023&#x2F;08&#x2F;03&#x2F;Arrow-Acero-Framework&#x2F; 提到了 AsyncTaskScheduler。Acero 中，这里有两种 TaskScheduler，因为历史原因存在：  AsyncTaskScheduler: 异步任务调度器，触发出不同的任务，每个任务提交需要返回一个 Result&gt;，Task 里面可以递归的添加">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-02-19T14:17:26.000Z">
<meta property="article:modified_time" content="2025-02-19T14:19:48.894Z">
<meta property="article:author" content="mwish">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/logo.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/logo.ico" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.ico">
        
      
    
    <!-- title -->
    <title>Acero Task Scheduler</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.2.0"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/02/17/Velox-Exchange-Shuffle-Skeleton/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&text=Acero Task Scheduler"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&title=Acero Task Scheduler"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&is_video=false&description=Acero Task Scheduler"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Acero Task Scheduler&body=Check out this article: http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&title=Acero Task Scheduler"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&title=Acero Task Scheduler"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&title=Acero Task Scheduler"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&title=Acero Task Scheduler"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&name=Acero Task Scheduler&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&t=Acero Task Scheduler"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AF%E7%9E%B0-acero-QueryContext"><span class="toc-number">1.</span> <span class="toc-text">俯瞰 acero::QueryContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncTaskScheduler"><span class="toc-number">2.</span> <span class="toc-text">AsyncTaskScheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AddAsyncGenerator"><span class="toc-number">2.1.</span> <span class="toc-text">AddAsyncGenerator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThrottledAsyncTaskScheduler"><span class="toc-number">2.2.</span> <span class="toc-text">ThrottledAsyncTaskScheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Future-%E7%9A%84-TryAddCallback-%E8%AF%AD%E4%B9%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">Future 的 TryAddCallback 语义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AsyncTaskGroup"><span class="toc-number">2.3.</span> <span class="toc-text">AsyncTaskGroup</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TaskScheduler"><span class="toc-number">3.</span> <span class="toc-text">TaskScheduler</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Acero Task Scheduler
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">mwish</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-02-19T14:17:26.000Z" itemprop="datePublished">2025-02-19</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>之前的文章 <a href="https://blog.mwish.me/2023/08/03/Arrow-Acero-Framework/">https://blog.mwish.me/2023/08/03/Arrow-Acero-Framework/</a> 提到了 AsyncTaskScheduler。Acero 中，这里有两种 TaskScheduler，因为历史原因存在：</p>
<ol>
<li><code>AsyncTaskScheduler</code>: 异步任务调度器，触发出不同的任务，每个任务提交需要返回一个 <code>Result&gt;</code>，Task 里面可以递归的添加 SubTask。<code>AsyncTaskScheduler</code> 可以提供对应的 <code>finish</code> 或者 <code>abort</code> 的 callback。这里也有 <code>Throttle</code> 这样的限流作业提交（主要用于 Scan 和 Sink 等）和 <code>TaskGroupScheduler</code> 这样一个按组提交、整个一起完成的逻辑（类似 Go WaitGroup 经典的用法）。</li>
<li><code>TaskScheduler</code>: 我猜你一眼就说这是非异步任务调度器了，但很遗憾这并不是，这个类型实际上是 <code>AsyncTaskScheduler</code> 的调用者（设计可以不是，但 acero 链路里面实际上是）。它实际做的事情是一个 Task Group 运行器。这里会有这样的逻辑<ol>
<li>允许注册一个 TaskGroup</li>
<li>允许开始调度，或者要求 ScheduleMore / ExecuteMore</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TaskScheduler` 这个概念有点抽象，我们换个角度，以 pipeline 的角度来想想这个问题，首先 Acero 如前一篇文章，是一个 Push-based Execution Model，在底端由 `AsyncTaskScheduler` 来去驱动，见 `ExecPlanImpl::StartProducing` 和每个 Node 的 `StartProducing()` 接口，驱动一个 `Throttle` 的 `AsyncTaskScheduler</span><br></pre></td></tr></table></figure>
<p>那 TaskScheduler 呢？它的设计是为了一个东西：ExecNode 内并发。对于一些 Pipeline Breaker，比如 Agg 或者 HashJoin，这里会使用 TaskGroup 来做「节点内并发调度」。同时 Node 初始的时候可能会初始化一些 Partition 数，或者 Hash Join 的分区数，TaskGroup 根据这些分区数来决定 Group-Size，并 Group-By Group 调度。一个 Group 调度完可以触发后面的调度，比如：前台 <code>AsynTaskScheduler</code> 不走 <code>TaskScheduler</code>，调用 Hash Build ，Build 完通过 TaskScheduler 和分区数启动 Probe Group。</p>
<h2 id="俯瞰-acero-QueryContext"><a href="#俯瞰-acero-QueryContext" class="headerlink" title="俯瞰 acero::QueryContext"></a>俯瞰 acero::QueryContext</h2><p>QueryContext 的成员包含下面两个，前者在 <code>QueryContext::Init</code> 中初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">arrow::util::AsyncTaskScheduler* async_scheduler_ = NULLPTR;</span><br><span class="line">std::unique_ptr&lt;TaskScheduler&gt; task_scheduler_ = TaskScheduler::<span class="built_in">Make</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">QueryContext::Init</span><span class="params">(util::AsyncTaskScheduler* scheduler)</span> </span>&#123;</span><br><span class="line">  async_scheduler_ = scheduler;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ARROW_ACERO_EXPORT</span> QueryContext &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TaskScheduler* <span class="title">scheduler</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> task_scheduler_.<span class="built_in">get</span>(); &#125;</span><br><span class="line">  arrow::<span class="function">util::AsyncTaskScheduler* <span class="title">async_scheduler</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> async_scheduler_; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面也有 <code>QueryContext</code> 层 Schedule Task 的例子，这几个比较简单明确</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueryContext::ScheduleTask</span><span class="params">(std::function&lt;Status()&gt; fn, std::string_view name)</span> </span>&#123;</span><br><span class="line">  ::arrow::internal::Executor* exec = <span class="built_in">executor</span>();</span><br><span class="line">  <span class="comment">// Adds a task which submits fn to the executor and tracks its progress.  If we&#x27;re</span></span><br><span class="line">  <span class="comment">// already stopping then the task is ignored and fn is not executed.</span></span><br><span class="line">  async_scheduler_-&gt;<span class="built_in">AddSimpleTask</span>(</span><br><span class="line">      [exec, fn = std::<span class="built_in">move</span>(fn)]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> exec-&gt;<span class="built_in">Submit</span>(std::<span class="built_in">move</span>(fn)); &#125;, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueryContext::ScheduleTask</span><span class="params">(std::function&lt;Status(<span class="type">size_t</span>)&gt; fn, std::string_view name)</span> </span>&#123;</span><br><span class="line">  std::function&lt;Status()&gt; indexed_fn = [<span class="keyword">this</span>, fn]() &#123;</span><br><span class="line">    <span class="type">size_t</span> thread_index = <span class="built_in">GetThreadIndex</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fn</span>(thread_index);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">ScheduleTask</span>(std::<span class="built_in">move</span>(indexed_fn), name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QueryContext::ScheduleIOTask</span><span class="params">(std::function&lt;Status()&gt; fn, std::string_view name)</span> </span>&#123;</span><br><span class="line">  async_scheduler_-&gt;<span class="built_in">AddSimpleTask</span>(</span><br><span class="line">      [<span class="keyword">this</span>, fn]() &#123; <span class="keyword">return</span> io_context_.<span class="built_in">executor</span>()-&gt;<span class="built_in">Submit</span>(std::<span class="built_in">move</span>(fn)); &#125;, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueryContext::RegisterTaskGroup</span><span class="params">(std::function&lt;Status(<span class="type">size_t</span>, <span class="type">int64_t</span>)&gt; task,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    std::function&lt;Status(<span class="type">size_t</span>)&gt; on_finished)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> task_scheduler_-&gt;<span class="built_in">RegisterTaskGroup</span>(std::<span class="built_in">move</span>(task), std::<span class="built_in">move</span>(on_finished));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">QueryContext::StartTaskGroup</span><span class="params">(<span class="type">int</span> task_group_id, <span class="type">int64_t</span> num_tasks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> task_scheduler_-&gt;<span class="built_in">StartTaskGroup</span>(<span class="built_in">GetThreadIndex</span>(), task_group_id, num_tasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里顺便提一下，<code>QueryContext</code> 里面有个比较有意思的类型是 <code>ThreadIndexer</code>，这个类型把 io 线程和 cpu 线程的 thread_id 映射到 0 开始的 index 上，用来维护 acero 内部执行的状态。</p>
<p>我来贴一段有水字数嫌疑的代码：<a target="_blank" rel="noopener" href="https://github.com/apache/arrow/blob/ec3d2839d102cc44d368c154cfa756eb946909ee/cpp/src/arrow/acero/exec_plan.cc#L128-L186">https://github.com/apache/arrow/blob/ec3d2839d102cc44d368c154cfa756eb946909ee/cpp/src/arrow/acero/exec_plan.cc#L128-L186</a></p>
<ol>
<li>利用 <code>arrow::util::AsyncTaskScheduler::Make</code>, 就地创建一个 <code>AsyncTaskScheduler</code>，然后去用它来初始化 <code>QueryContext</code> 的 <code>AsyncTaskScheduler*</code></li>
<li>去初始化每个 <code>ExecNode</code> ，初始化的时候，<code>Node</code> 拿到 <code>QueryContext</code>，在 <code>TaskScheduler</code> 注册 TaskGroup，e.g.: <a target="_blank" rel="noopener" href="https://github.com/apache/arrow/blob/ec3d2839d102cc44d368c154cfa756eb946909ee/cpp/src/arrow/acero/hash_join_node.cc#L931-L982">https://github.com/apache/arrow/blob/ec3d2839d102cc44d368c154cfa756eb946909ee/cpp/src/arrow/acero/hash_join_node.cc#L931-L982</a></li>
<li>这里调用了 <code>TaskScheduler::RegisterEnd()</code> 来标识所有 <code>ExecNode</code> 的注册完成。然后有个 <code>StartScheduling</code>。你会发现这个 <code>StartScheduling</code> 甚至没有开始驱动叶子结点 <code>StartProducing</code>。实际上这里就是注册具体执行的调度着是 <code>ctx-&gt;ScheduleTask</code>，即 <code>AsyncTaskScheduler::AddSimpleTask</code>，然后注册了一下最大的并发任务数（这里设的比核数还多一些，目测就是个随便设的经验值了）</li>
<li>驱动 <code>ExecNode::StartProducing</code>. 对于有的 <code>ExecNode</code>，这里的逻辑会分成不同的种类：<ol>
<li>消费来自别的节点的数据，啥都不干：<a target="_blank" rel="noopener" href="https://github.com/apache/arrow/blob/ec3d2839d102cc44d368c154cfa756eb946909ee/cpp/src/arrow/acero/aggregate_internal.h#L196">https://github.com/apache/arrow/blob/ec3d2839d102cc44d368c154cfa756eb946909ee/cpp/src/arrow/acero/aggregate_internal.h#L196</a></li>
<li>像 Join 一类，可能需要 Prepare 一些资源的：<a target="_blank" rel="noopener" href="https://github.com/apache/arrow/blob/ec3d2839d102cc44d368c154cfa756eb946909ee/cpp/src/arrow/acero/asof_join_node.cc#L1509">https://github.com/apache/arrow/blob/ec3d2839d102cc44d368c154cfa756eb946909ee/cpp/src/arrow/acero/asof_join_node.cc#L1509</a></li>
<li>ScanNode / SourceNode，需要准备生成数据。Scan 会用 <code>plan_-&gt;query_context()-&gt;async_scheduler()-&gt;AddSimpleTask</code> 来添加 Scan 的上下文: <a target="_blank" rel="noopener" href="https://github.com/apache/arrow/blob/ec3d2839d102cc44d368c154cfa756eb946909ee/cpp/src/arrow/acero/source_node.cc#L165">https://github.com/apache/arrow/blob/ec3d2839d102cc44d368c154cfa756eb946909ee/cpp/src/arrow/acero/source_node.cc#L165</a> ， <a target="_blank" rel="noopener" href="https://github.com/apache/arrow/blob/ec3d2839d102cc44d368c154cfa756eb946909ee/cpp/src/arrow/dataset/scan_node.cc#L439-L451">https://github.com/apache/arrow/blob/ec3d2839d102cc44d368c154cfa756eb946909ee/cpp/src/arrow/dataset/scan_node.cc#L439-L451</a></li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;&gt; scheduler_finished = arrow::util::AsyncTaskScheduler::<span class="built_in">Make</span>(</span><br><span class="line">    [<span class="keyword">this</span>](arrow::util::AsyncTaskScheduler* async_scheduler) &#123;</span><br><span class="line">      QueryContext* ctx = <span class="built_in">query_context</span>();</span><br><span class="line">      <span class="built_in">RETURN_NOT_OK</span>(ctx-&gt;<span class="built_in">Init</span>(async_scheduler));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nodes_) &#123;</span><br><span class="line">        <span class="built_in">RETURN_NOT_OK</span>(n-&gt;<span class="built_in">Init</span>());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ctx-&gt;<span class="built_in">scheduler</span>()-&gt;<span class="built_in">RegisterEnd</span>();</span><br><span class="line">      <span class="type">int</span> num_threads = <span class="number">1</span>;</span><br><span class="line">      <span class="type">bool</span> sync_execution = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> executor = <span class="built_in">query_context</span>()-&gt;<span class="built_in">exec_context</span>()-&gt;<span class="built_in">executor</span>()) &#123;</span><br><span class="line">        num_threads = executor-&gt;<span class="built_in">GetCapacity</span>();</span><br><span class="line">        sync_execution = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">RETURN_NOT_OK</span>(ctx-&gt;<span class="built_in">scheduler</span>()-&gt;<span class="built_in">StartScheduling</span>(</span><br><span class="line">          <span class="number">0</span> <span class="comment">/* thread_index */</span>,</span><br><span class="line">          [ctx](std::function&lt;<span class="built_in">Status</span>(<span class="type">size_t</span>)&gt; fn) -&gt; Status &#123;</span><br><span class="line">            <span class="comment">// TODO(weston) add names to synchronous scheduler so we can use something</span></span><br><span class="line">            <span class="comment">// better than sync-scheduler-task here</span></span><br><span class="line">            ctx-&gt;<span class="built_in">ScheduleTask</span>(std::<span class="built_in">move</span>(fn), <span class="string">&quot;sync-scheduler-task&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">/*concurrent_tasks=*/</span><span class="number">2</span> * num_threads, sync_execution));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// producers precede consumers</span></span><br><span class="line">      sorted_nodes_ = <span class="built_in">TopoSort</span>();</span><br><span class="line"></span><br><span class="line">      Status st = Status::<span class="built_in">OK</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">using</span> rev_it = std::reverse_iterator&lt;NodeVector::iterator&gt;;</span><br><span class="line">      <span class="keyword">for</span> (rev_it <span class="built_in">it</span>(sorted_nodes_.<span class="built_in">end</span>()), <span class="built_in">end</span>(sorted_nodes_.<span class="built_in">begin</span>()); it != end;</span><br><span class="line">           ++it) &#123;</span><br><span class="line">        <span class="keyword">auto</span> node = *it;</span><br><span class="line"></span><br><span class="line">        st = node-&gt;<span class="built_in">StartProducing</span>();</span><br><span class="line">        <span class="keyword">if</span> (!st.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="comment">// Stop nodes that successfully started, in reverse order</span></span><br><span class="line">          <span class="type">bool</span> expected = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (stopped_.<span class="built_in">compare_exchange_strong</span>(expected, <span class="literal">true</span>)) &#123;</span><br><span class="line">            <span class="built_in">StopProducingImpl</span>(it.<span class="built_in">base</span>(), sorted_nodes_.<span class="built_in">end</span>());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> st;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> st;</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="keyword">this</span>](<span class="type">const</span> Status&amp; st) &#123;</span><br><span class="line">      <span class="comment">// If an error occurs we call StopProducing.  The scheduler will already have</span></span><br><span class="line">      <span class="comment">// stopped scheduling new tasks at this point.  However, any nodes that are</span></span><br><span class="line">      <span class="comment">// dealing with external tasks will need to trigger those external tasks to end</span></span><br><span class="line">      <span class="comment">// early.</span></span><br><span class="line">      <span class="built_in">StopProducing</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">scheduler_finished.<span class="built_in">AddCallback</span>([<span class="keyword">this</span>](<span class="type">const</span> Status&amp; st) &#123;</span><br><span class="line">  <span class="keyword">if</span> (st.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stopped_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">      finished_.<span class="built_in">MarkFinished</span>(Status::<span class="built_in">Cancelled</span>(<span class="string">&quot;Plan was cancelled early.&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      finished_.<span class="built_in">MarkFinished</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    finished_.<span class="built_in">MarkFinished</span>(st);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面就是 Node / QueryContext 视角的 Scan 全流程。</p>
<h2 id="AsyncTaskScheduler"><a href="#AsyncTaskScheduler" class="headerlink" title="AsyncTaskScheduler"></a>AsyncTaskScheduler</h2><p><code>AsyncTaskScheduler</code> 用于「调度」对应的 <code>Task</code> 的执行，但是它本身不包含任何所谓线程池有关的逻辑，它负责：</p>
<ol>
<li>维护 <code>StopToken</code> 和 <code>maybe_error_</code>，它内部的错误状态被称为 “Abort”，Abort 可能来自下列情景。<code>Abort</code> 的时候，出错的第一个线程会设置 <code>maybe_error_</code>，然后调用 <code>abort_callback_</code><ol>
<li>stopToken 被通知任务已经停止</li>
<li>任何 Task 执行出错</li>
</ol>
</li>
<li>维护 <code>running_tasks_</code>，<code>Task</code> 可以自己投递 Running Tasks，同时 <code>running_tasks_</code> 数为 0 表示真的结束了，可以通知下游任务了，这里会通知内部的 <code>Future&lt;&gt; finished_</code></li>
</ol>
<p>我们上面提到了，<code>AsyncTaskScheduler</code> 中 <code>Task</code> 直接执行就够了，具体的 io/cpu 发送者还是在 <code>QueryContext::</code> 里面包装给了 io thread 或者 cpu thread。</p>
<p>上面的逻辑比较有意思，就是会要求 <code>AsyncTaskScheduler</code> 内部在查询运行期间一直有任务在被调度，我们根据代码来思考一个这样的流程，以下代码来自 <code>ScanNode</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StartProducing</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NoteStartProducing</span>(<span class="built_in">ToStringExtra</span>());</span><br><span class="line">  batches_throttle_ = util::ThrottledAsyncTaskScheduler::<span class="built_in">Make</span>(</span><br><span class="line">      plan_-&gt;<span class="built_in">query_context</span>()-&gt;<span class="built_in">async_scheduler</span>(), options_.target_bytes_readahead + <span class="number">1</span>);</span><br><span class="line">  plan_-&gt;<span class="built_in">query_context</span>()-&gt;<span class="built_in">async_scheduler</span>()-&gt;<span class="built_in">AddSimpleTask</span>(</span><br><span class="line">      [<span class="keyword">this</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetFragments</span>(options_.dataset.<span class="built_in">get</span>(), options_.filter)</span><br><span class="line">            .<span class="built_in">Then</span>([<span class="keyword">this</span>](<span class="type">const</span> AsyncGenerator&lt;std::shared_ptr&lt;Fragment&gt;&gt;&amp; frag_gen) &#123;</span><br><span class="line">              <span class="built_in">ScanFragments</span>(frag_gen);</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;ScanNode::ListDataset::GetFragments&quot;</span>sv);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScanFragments</span><span class="params">(<span class="type">const</span> AsyncGenerator&lt;std::shared_ptr&lt;Fragment&gt;&gt;&amp; frag_gen)</span> </span>&#123;</span><br><span class="line">  std::shared_ptr&lt;util::AsyncTaskScheduler&gt; fragment_tasks =</span><br><span class="line">      util::<span class="built_in">MakeThrottledAsyncTaskGroup</span>(</span><br><span class="line">          plan_-&gt;<span class="built_in">query_context</span>()-&gt;<span class="built_in">async_scheduler</span>(), options_.fragment_readahead + <span class="number">1</span>,</span><br><span class="line">          <span class="comment">/*queue=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">          [<span class="keyword">this</span>]() &#123; <span class="keyword">return</span> output_-&gt;<span class="built_in">InputFinished</span>(<span class="keyword">this</span>, num_batches_.<span class="built_in">load</span>()); &#125;);</span><br><span class="line">  fragment_tasks-&gt;AddAsyncGenerator&lt;std::shared_ptr&lt;Fragment&gt;&gt;(</span><br><span class="line">      frag_gen,</span><br><span class="line">      [<span class="keyword">this</span>, fragment_tasks =</span><br><span class="line">                 std::<span class="built_in">move</span>(fragment_tasks)](<span class="type">const</span> std::shared_ptr&lt;Fragment&gt;&amp; fragment) &#123;</span><br><span class="line">        fragment_tasks-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">make_unique</span>&lt;ListFragmentTask&gt;(<span class="keyword">this</span>, fragment));</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;ScanNode::ListDataset::Next&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListFragmentTask</span> : util::AsyncTaskScheduler::Task &#123;</span><br><span class="line">  <span class="built_in">ListFragmentTask</span>(ScanNode* node, std::shared_ptr&lt;Fragment&gt; fragment)</span><br><span class="line">      : <span class="built_in">node</span>(node), <span class="built_in">fragment</span>(std::<span class="built_in">move</span>(fragment)) &#123;</span><br><span class="line">    name_ = <span class="string">&quot;ScanNode::ListFragment::&quot;</span> + <span class="keyword">this</span>-&gt;fragment-&gt;<span class="built_in">ToString</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Result&lt;Future&lt;&gt;&gt; <span class="built_in">operator</span>()() <span class="keyword">override</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fragment</span><br><span class="line">        -&gt;<span class="built_in">InspectFragment</span>(node-&gt;options_.format_options,</span><br><span class="line">                          node-&gt;plan_-&gt;<span class="built_in">query_context</span>()-&gt;<span class="built_in">exec_context</span>())</span><br><span class="line">        .<span class="built_in">Then</span>([<span class="keyword">this</span>](<span class="type">const</span> std::shared_ptr&lt;InspectedFragment&gt;&amp; inspected_fragment) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">BeginScan</span>(inspected_fragment);</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简述一下上面的逻辑：</p>
<ol>
<li>启动的时候，驱动 <code>ThrottledAsyncTaskScheduler</code> 来做一定的 Fragment Rate Limit</li>
<li>初始化 <code>GetFragments</code> 作为 Generator，这个接口类似 List，根据 <code>Dataset</code> 和 <code>Predicate</code> 来返回出合适的 <code>Fragments</code></li>
<li><code>Fragment</code> 的下游是 <code>ScanFragments</code>，它接受 <code>AsyncGenerator&gt;</code>，然后调用 <code>ListFragmentTask</code> 来从 <code>shared_ptr</code> 产生 Scan</li>
<li>…</li>
</ol>
<p>最后，根据一层层调用，Scan 出 Batch 后，这里会有对应的回调，来在系统中，交给 CPU Thread 调度下游节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">HandleBatch</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;RecordBatch&gt;&amp; batch)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(</span><br><span class="line">      compute::ExecBatch evolved_batch,</span><br><span class="line">      scan_-&gt;fragment_evolution-&gt;<span class="built_in">EvolveBatch</span>(</span><br><span class="line">          batch, node_-&gt;options_.columns, *scan_-&gt;scan_request.fragment_selection));</span><br><span class="line">  compute::ExecBatch with_known_values = <span class="built_in">AddKnownValues</span>(std::<span class="built_in">move</span>(evolved_batch));</span><br><span class="line">  node_-&gt;plan_-&gt;<span class="built_in">query_context</span>()-&gt;<span class="built_in">ScheduleTask</span>(</span><br><span class="line">      [node = node_, output_batch = std::<span class="built_in">move</span>(with_known_values)] &#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;output_-&gt;<span class="built_in">InputReceived</span>(node, output_batch);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;ScanNode::ProcessMorsel&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AddAsyncGenerator"><a href="#AddAsyncGenerator" class="headerlink" title="AddAsyncGenerator"></a>AddAsyncGenerator</h3><p>这个代码实在是有意思，所以单独抽一节讲讲：</p>
<ol>
<li>上游是 <code>generator</code>，然后 generator 产生的东西被异步提交给 visitor</li>
<li>维护了 <code>State</code> 存放整体的状态</li>
<li>维护了 <code>SumbitTask</code> 作为最初的 Task，然后在它的 <code>operator()</code> 里面，尝试在循环中执行尽可能多的 Task，防止过多的递归 Callback</li>
<li>如果有阻塞，构建 <code>SubmitTaskCallback</code>, <code>SubmitTaskCallback</code> 在 call 的时候也会尝试再投敌一个 <code>SubmitTask</code> 任务，递归的执行</li>
</ol>
<p>笔者感觉 3/4 的思路上还是挺有意思的，值得借鉴一下。不过感觉这代码还是复杂了吧…n</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AsyncTaskScheduler::AddAsyncGenerator</span><span class="params">(std::function&lt;Future&lt;T&gt;()&gt; generator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           std::function&lt;Status(<span class="type">const</span> T&amp;)&gt; visitor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="built_in">State</span>(std::function&lt;<span class="built_in">Future</span>&lt;T&gt;()&gt; generator, std::function&lt;<span class="built_in">Status</span>(<span class="type">const</span> T&amp;)&gt; visitor,</span><br><span class="line">          std::unique_ptr&lt;AsyncTaskGroup&gt; task_group, std::string_view name)</span><br><span class="line">        : <span class="built_in">generator</span>(std::<span class="built_in">move</span>(generator)),</span><br><span class="line">          <span class="built_in">visitor</span>(std::<span class="built_in">move</span>(visitor)),</span><br><span class="line">          <span class="built_in">task_group</span>(std::<span class="built_in">move</span>(task_group)),</span><br><span class="line">          <span class="built_in">name</span>(name) &#123;&#125;</span><br><span class="line">    std::function&lt;Future&lt;T&gt;()&gt; generator;</span><br><span class="line">    std::function&lt;Status(<span class="type">const</span> T&amp;)&gt; visitor;</span><br><span class="line">    std::unique_ptr&lt;AsyncTaskGroup&gt; task_group;</span><br><span class="line">    std::string_view name;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">SubmitTask</span> : <span class="keyword">public</span> Task &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SubmitTask</span><span class="params">(std::unique_ptr&lt;State&gt; state_holder)</span></span></span><br><span class="line"><span class="function">        : state_holder(std::move(state_holder)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SubmitTaskCallback</span> &#123;</span><br><span class="line">      <span class="built_in">SubmitTaskCallback</span>(std::unique_ptr&lt;State&gt; state_holder, Future&lt;&gt; task_completion)</span><br><span class="line">          : <span class="built_in">state_holder</span>(std::<span class="built_in">move</span>(state_holder)),</span><br><span class="line">            <span class="built_in">task_completion</span>(std::<span class="built_in">move</span>(task_completion)) &#123;&#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Result&lt;T&gt;&amp; maybe_item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!maybe_item.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          task_completion.<span class="built_in">MarkFinished</span>(maybe_item.<span class="built_in">status</span>());</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; item = *maybe_item;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsIterationEnd</span>(item)) &#123;</span><br><span class="line">          task_completion.<span class="built_in">MarkFinished</span>();</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Status visit_st = state_holder-&gt;<span class="built_in">visitor</span>(item);</span><br><span class="line">        <span class="keyword">if</span> (!visit_st.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          task_completion.<span class="built_in">MarkFinished</span>(std::<span class="built_in">move</span>(visit_st));</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        state_holder-&gt;task_group-&gt;<span class="built_in">AddTask</span>(</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;SubmitTask&gt;(std::<span class="built_in">move</span>(state_holder)));</span><br><span class="line">        task_completion.<span class="built_in">MarkFinished</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      std::unique_ptr&lt;State&gt; state_holder;</span><br><span class="line">      Future&lt;&gt; task_completion;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Result&lt;Future&lt;&gt;&gt; <span class="built_in">operator</span>()() &#123;</span><br><span class="line">      Future&lt;&gt; task = Future&lt;&gt;::<span class="built_in">Make</span>();</span><br><span class="line">      <span class="comment">// Consume as many items as we can (those that are already finished)</span></span><br><span class="line">      <span class="comment">// synchronously to avoid recursion / stack overflow.</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Future&lt;T&gt; next = state_holder-&gt;<span class="built_in">generator</span>();</span><br><span class="line">        <span class="keyword">if</span> (next.<span class="built_in">TryAddCallback</span>(</span><br><span class="line">                [&amp;] &#123; <span class="keyword">return</span> <span class="built_in">SubmitTaskCallback</span>(std::<span class="built_in">move</span>(state_holder), task); &#125;)) &#123;</span><br><span class="line">          <span class="keyword">return</span> task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(T item, next.<span class="built_in">result</span>());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsIterationEnd</span>(item)) &#123;</span><br><span class="line">          task.<span class="built_in">MarkFinished</span>();</span><br><span class="line">          <span class="keyword">return</span> task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ARROW_RETURN_NOT_OK</span>(state_holder-&gt;<span class="built_in">visitor</span>(item));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string_view <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> state_holder-&gt;name; &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;State&gt; state_holder;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::unique_ptr&lt;AsyncTaskGroup&gt; task_group =</span><br><span class="line">      AsyncTaskGroup::<span class="built_in">Make</span>(<span class="keyword">this</span>, [] &#123; <span class="keyword">return</span> Status::<span class="built_in">OK</span>(); &#125;);</span><br><span class="line">  AsyncTaskGroup* task_group_view = task_group.<span class="built_in">get</span>();</span><br><span class="line">  std::unique_ptr&lt;State&gt; state_holder = std::<span class="built_in">make_unique</span>&lt;State&gt;(</span><br><span class="line">      std::<span class="built_in">move</span>(generator), std::<span class="built_in">move</span>(visitor), std::<span class="built_in">move</span>(task_group), name);</span><br><span class="line">  task_group_view-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">make_unique</span>&lt;SubmitTask&gt;(std::<span class="built_in">move</span>(state_holder)));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ThrottledAsyncTaskScheduler"><a href="#ThrottledAsyncTaskScheduler" class="headerlink" title="ThrottledAsyncTaskScheduler"></a>ThrottledAsyncTaskScheduler</h3><p><code>ThrottledAsyncTaskScheduler</code> 依赖一个已有的 <code>AsyncTaskScheduler</code>，通常是某个 ExecNode 内部用来给某种操作限流的。<code>ThrottledAsyncTaskScheduler</code> 的内容包含：</p>
<ol>
<li><code>Queue</code>: 缓存积压消费的任务的 <code>Queue</code>，默认 FIFO，也可以定义别的 Queue</li>
<li><code>Throttle</code>: 对应的限流器，也允许 <code>Pause</code> 和 <code>Resume</code>. 每个 <code>Task</code> 会有一个默认为 1 的 <code>cost</code>，使用 <code>ThrottledAsyncTaskScheduler</code> 的用户也可以自己定义</li>
</ol>
<h4 id="Future-的-TryAddCallback-语义"><a href="#Future-的-TryAddCallback-语义" class="headerlink" title="Future 的 TryAddCallback 语义"></a>Future 的 TryAddCallback 语义</h4><p>我们可以想象几个 <code>Future</code> 有关的语义：</p>
<ol>
<li><code>folly</code> 没有 shared future ，只有 <code>SharedPromise</code>，它的 <code>Future</code> 也是单个 <code>Future</code> 去 <code>then..</code> 之类的方式生成下来的</li>
<li>Arrow Acero 使用的 Future 类似 <code>SharedPromise + SharedFuture</code>，这里有一个很好玩的两个接口：<ol>
<li>AddCallback 无论如何都会添加 Callback，如果完成了会就地执行</li>
<li>TryAdd 则不会，相当于是对递归场景的可能优化，避免在 Loop 里面可以解决的问题变成 Callback 一层又一层。</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// \brief Consumer API: Register a callback to run when this future completes</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The callback should receive the result of the future (const Result&lt;T&gt;&amp;)</span></span><br><span class="line"><span class="comment">/// For a void or statusy future this should be (const Status&amp;)</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// There is no guarantee to the order in which callbacks will run.  In</span></span><br><span class="line"><span class="comment">/// particular, callbacks added while the future is being marked complete</span></span><br><span class="line"><span class="comment">/// may be executed immediately, ahead of, or even the same time as, other</span></span><br><span class="line"><span class="comment">/// callbacks that have been previously added.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// WARNING: callbacks may hold arbitrary references, including cyclic references.</span></span><br><span class="line"><span class="comment">/// Since callbacks will only be destroyed after they are invoked, this can lead to</span></span><br><span class="line"><span class="comment">/// memory leaks if a Future is never marked finished (abandoned):</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// &#123;</span></span><br><span class="line"><span class="comment">///     auto fut = Future&lt;&gt;::Make();</span></span><br><span class="line"><span class="comment">///     fut.AddCallback([fut]() &#123;&#125;);</span></span><br><span class="line"><span class="comment">/// &#125;</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In this example `fut` falls out of scope but is not destroyed because it holds a</span></span><br><span class="line"><span class="comment">/// cyclic reference to itself through the callback.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OnComplete, <span class="keyword">typename</span> Callback = WrapOnComplete&lt;OnComplete&gt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">AddCallback</span>(OnComplete on_complete,</span><br><span class="line">                 CallbackOptions opts = CallbackOptions::<span class="built_in">Defaults</span>()) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="comment">// We know impl_ will not be dangling when invoking callbacks because at least one</span></span><br><span class="line">  <span class="comment">// thread will be waiting for MarkFinished to return. Thus it&#x27;s safe to keep a</span></span><br><span class="line">  <span class="comment">// weak reference to impl_ here</span></span><br><span class="line">  impl_-&gt;<span class="built_in">AddCallback</span>(Callback&#123;std::<span class="built_in">move</span>(on_complete)&#125;, opts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// \brief Overload of AddCallback that will return false instead of running</span></span><br><span class="line"><span class="comment">/// synchronously</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This overload will guarantee the callback is never run synchronously.  If the future</span></span><br><span class="line"><span class="comment">/// is already finished then it will simply return false.  This can be useful to avoid</span></span><br><span class="line"><span class="comment">/// stack overflow in a situation where you have recursive Futures.  For an example</span></span><br><span class="line"><span class="comment">/// see the Loop function</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Takes in a callback factory function to allow moving callbacks (the factory function</span></span><br><span class="line"><span class="comment">/// will only be called if the callback can successfully be added)</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Returns true if a callback was actually added and false if the callback failed</span></span><br><span class="line"><span class="comment">/// to add because the future was marked complete.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CallbackFactory,</span><br><span class="line">          <span class="keyword">typename</span> OnComplete = detail::<span class="type">result_of_t</span>&lt;<span class="built_in">CallbackFactory</span>()&gt;,</span><br><span class="line">          <span class="keyword">typename</span> Callback = WrapOnComplete&lt;OnComplete&gt;&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">TryAddCallback</span>(CallbackFactory callback_factory,</span><br><span class="line">                    CallbackOptions opts = CallbackOptions::<span class="built_in">Defaults</span>()) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> impl_-&gt;<span class="built_in">TryAddCallback</span>([&amp;]() &#123; <span class="keyword">return</span> Callback&#123;<span class="built_in">callback_factory</span>()&#125;; &#125;, opts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知道这个之后，我们可以看看 <code>Throttle</code> 限流的逻辑：</p>
<ol>
<li><code>AddTask</code> 简单的尝试 <code>AddCallback</code> 来回调，争取调度更多任务（<code>ContinueTasks</code>）</li>
<li><code>SubmitTask</code> 需要防止递归 <code>ContinueTasks</code>，比较有意思，这里面逻辑就会 <code>TryAddCallback</code></li>
<li>如果一旦 <code>Status</code> 不为 ok，不需要管理剩下的 throttle，因为，<code>ThrottleImpl</code> 析构的时候，会尝试清理掉 blocking 的 Future。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AddTask</span><span class="params">(std::unique_ptr&lt;Task&gt; task)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lk</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// If the queue isn&#x27;t empty then don&#x27;t even try and acquire the throttle</span></span><br><span class="line">  <span class="comment">// We can safely assume it is either blocked or in the middle of trying to</span></span><br><span class="line">  <span class="comment">// alert a queued task.</span></span><br><span class="line">  <span class="keyword">if</span> (!queue_-&gt;<span class="built_in">Empty</span>()) &#123;</span><br><span class="line">    queue_-&gt;<span class="built_in">Push</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> latched_cost = std::<span class="built_in">min</span>(task-&gt;<span class="built_in">cost</span>(), throttle_-&gt;<span class="built_in">Capacity</span>());</span><br><span class="line">  std::optional&lt;Future&lt;&gt;&gt; maybe_backoff = throttle_-&gt;<span class="built_in">TryAcquire</span>(latched_cost);</span><br><span class="line">  <span class="keyword">if</span> (maybe_backoff) &#123;</span><br><span class="line">    queue_-&gt;<span class="built_in">Push</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    maybe_backoff-&gt;<span class="built_in">AddCallback</span>(</span><br><span class="line">        [weak_self = std::<span class="built_in">weak_ptr</span>&lt;ThrottledAsyncTaskSchedulerImpl&gt;(</span><br><span class="line">             <span class="built_in">shared_from_this</span>())](<span class="type">const</span> Status&amp; st) &#123;</span><br><span class="line">          <span class="keyword">if</span> (st.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> self = weak_self.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">              self-&gt;<span class="built_in">ContinueTasks</span>();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SubmitTask</span>(std::<span class="built_in">move</span>(task), latched_cost, <span class="comment">/*in_continue=*/</span><span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SubmitTask</span><span class="params">(std::unique_ptr&lt;Task&gt; task, <span class="type">int</span> latched_cost, <span class="type">bool</span> in_continue)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Wrap the task with a wrapper that runs it and then checks to see if there are any</span></span><br><span class="line">  <span class="comment">// queued tasks</span></span><br><span class="line">  std::string_view name = task-&gt;<span class="built_in">name</span>();</span><br><span class="line">  <span class="keyword">return</span> target_-&gt;<span class="built_in">AddSimpleTask</span>(</span><br><span class="line">      [latched_cost, in_continue, inner_task = std::<span class="built_in">move</span>(task),</span><br><span class="line">       self = <span class="built_in">shared_from_this</span>()]() <span class="keyword">mutable</span> -&gt; Result&lt;Future&lt;&gt;&gt; &#123;</span><br><span class="line">        <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(Future&lt;&gt; inner_fut, (*inner_task)());</span><br><span class="line">        <span class="keyword">if</span> (!inner_fut.<span class="built_in">TryAddCallback</span>([&amp;] &#123;</span><br><span class="line">              <span class="keyword">return</span> [latched_cost, self = std::<span class="built_in">move</span>(self)](<span class="type">const</span> Status&amp; st) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (st.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">                  self-&gt;throttle_-&gt;<span class="built_in">Release</span>(latched_cost);</span><br><span class="line">                  self-&gt;<span class="built_in">ContinueTasks</span>();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;;</span><br><span class="line">            &#125;)) &#123;</span><br><span class="line">          <span class="comment">// If the task is already finished then don&#x27;t run ContinueTasks</span></span><br><span class="line">          <span class="comment">// if we are already running it so we can avoid stack overflow</span></span><br><span class="line">          self-&gt;throttle_-&gt;<span class="built_in">Release</span>(latched_cost);</span><br><span class="line">          <span class="keyword">if</span> (!in_continue) &#123;</span><br><span class="line">            self-&gt;<span class="built_in">ContinueTasks</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inner_fut;</span><br><span class="line">      &#125;,</span><br><span class="line">      name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContinueTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lk</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (!queue_-&gt;<span class="built_in">Empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> next_cost = std::<span class="built_in">min</span>(queue_-&gt;<span class="built_in">Peek</span>().<span class="built_in">cost</span>(), throttle_-&gt;<span class="built_in">Capacity</span>());</span><br><span class="line">    std::optional&lt;Future&lt;&gt;&gt; maybe_backoff = throttle_-&gt;<span class="built_in">TryAcquire</span>(next_cost);</span><br><span class="line">    <span class="keyword">if</span> (maybe_backoff) &#123;</span><br><span class="line">      lk.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="keyword">if</span> (!maybe_backoff-&gt;<span class="built_in">TryAddCallback</span>([&amp;] &#123;</span><br><span class="line">            <span class="keyword">return</span> [self = <span class="built_in">shared_from_this</span>()](<span class="type">const</span> Status&amp; st) &#123;</span><br><span class="line">              <span class="keyword">if</span> (st.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">                self-&gt;<span class="built_in">ContinueTasks</span>();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!maybe_backoff-&gt;<span class="built_in">status</span>().<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lk.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::unique_ptr&lt;Task&gt; next_task = queue_-&gt;<span class="built_in">Pop</span>();</span><br><span class="line">      lk.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">SubmitTask</span>(std::<span class="built_in">move</span>(next_task), next_cost, <span class="comment">/*in_continue=*/</span><span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      lk.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AsyncTaskGroup"><a href="#AsyncTaskGroup" class="headerlink" title="AsyncTaskGroup"></a>AsyncTaskGroup</h3><p>提供一个 Group 和一个 Group Callback。代码很简单，直接看一眼就懂：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncTaskGroupImpl</span> : <span class="keyword">public</span> AsyncTaskGroup &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AsyncTaskGroupImpl</span>(AsyncTaskScheduler* target, FnOnce&lt;<span class="built_in">Status</span>()&gt; finish_cb)</span><br><span class="line">      : <span class="built_in">target_</span>(target), <span class="built_in">state_</span>(std::<span class="built_in">make_shared</span>&lt;State&gt;(std::<span class="built_in">move</span>(finish_cb))) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">AsyncTaskGroupImpl</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (--state_-&gt;task_count == <span class="number">0</span>) &#123;</span><br><span class="line">      Status st = std::<span class="built_in">move</span>(state_-&gt;finish_cb)();</span><br><span class="line">      <span class="keyword">if</span> (!st.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="comment">// We can&#x27;t return an invalid status from the destructor so we schedule a dummy</span></span><br><span class="line">        <span class="comment">// failing task</span></span><br><span class="line">        target_-&gt;<span class="built_in">AddSimpleTask</span>([st = std::<span class="built_in">move</span>(st)]() &#123; <span class="keyword">return</span> st; &#125;,</span><br><span class="line">                               <span class="string">&quot;failed_task_reporter&quot;</span>sv);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">AddTask</span><span class="params">(std::unique_ptr&lt;Task&gt; task)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    state_-&gt;task_count++;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">WrapperTask</span> : <span class="keyword">public</span> Task &#123;</span><br><span class="line">      <span class="built_in">WrapperTask</span>(std::unique_ptr&lt;Task&gt; target, std::shared_ptr&lt;State&gt; state)</span><br><span class="line">          : <span class="built_in">target</span>(std::<span class="built_in">move</span>(target)), <span class="built_in">state</span>(std::<span class="built_in">move</span>(state)) &#123;&#125;</span><br><span class="line">      Result&lt;Future&lt;&gt;&gt; <span class="built_in">operator</span>()() <span class="keyword">override</span> &#123;</span><br><span class="line">        <span class="built_in">ARROW_ASSIGN_OR_RAISE</span>(Future&lt;&gt; inner_fut, (*target)());</span><br><span class="line">        <span class="keyword">return</span> inner_fut.<span class="built_in">Then</span>([state = std::<span class="built_in">move</span>(state)]() &#123;</span><br><span class="line">          <span class="keyword">if</span> (--state-&gt;task_count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">move</span>(state-&gt;finish_cb)();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">cost</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> target-&gt;<span class="built_in">cost</span>(); &#125;</span><br><span class="line">      <span class="function">std::string_view <span class="title">name</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> target-&gt;<span class="built_in">name</span>(); &#125;</span><br><span class="line">      std::unique_ptr&lt;Task&gt; target;</span><br><span class="line">      std::shared_ptr&lt;State&gt; state;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> target_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">make_unique</span>&lt;WrapperTask&gt;(std::<span class="built_in">move</span>(task), state_));</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">State</span><span class="params">(FnOnce&lt;Status()&gt; finish_cb)</span></span></span><br><span class="line"><span class="function">        : task_count(<span class="number">1</span>), finish_cb(std::move(finish_cb)) &#123;</span>&#125;</span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; task_count;</span><br><span class="line">    FnOnce&lt;<span class="built_in">Status</span>()&gt; finish_cb;</span><br><span class="line">  &#125;;</span><br><span class="line">  AsyncTaskScheduler* target_;</span><br><span class="line">  std::shared_ptr&lt;State&gt; state_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="TaskScheduler"><a href="#TaskScheduler" class="headerlink" title="TaskScheduler"></a>TaskScheduler</h2><p>TaskScheduler 是一个写了不少无锁代码的 Task Group 调度器。虽然不是全部部分都无锁，但这部分代码还是比较复杂的。感觉是为了性能特意搞得相对复杂了一些，不过我个人总觉得它并发数好像不一定有那么高。我们先贴一下 TaskScheduler 对应的几个 Callback 和接口：</p>
<ol>
<li>Group 的执行函数 <code>TaskImpl</code> 暴露了一个 <code>(thread_id, task_id)</code> 的参数，同时提供了一个 <code>TaskGroupContinuationImpl</code> 的函数，留了一个 <code>thread_id</code> 的参数</li>
<li><code>ScheduleImpl</code> 本质上是一种…你在这本篇文章搜一下就能找到调用的地方了，发给我们亲爱的 <code>QueryContext::ScheduleTask</code> 了</li>
<li>我帮你们看过代码了，<code>ExecuteMore</code> 根本没有外部调用者，呵呵</li>
<li>在外部注册完成的时候，会调用 <code>StartScheduling</code> ，但是这个时候什么都不会发生，当需要的时候，比如 Hash Build 完成了，来调用 HashProbe 管线，这里就会启动对应的 Tasks。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Used for asynchronous execution of operations that can be broken into</span></span><br><span class="line"><span class="comment">// a fixed number of symmetric tasks that can be executed concurrently.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Implements priorities between multiple such operations, called task groups.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allows to specify the maximum number of in-flight tasks at any moment.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Also allows for executing next pending tasks immediately using a caller thread.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ARROW_ACERO_EXPORT</span> TaskScheduler &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> TaskImpl = std::function&lt;<span class="built_in">Status</span>(<span class="type">size_t</span>, <span class="type">int64_t</span>)&gt;;</span><br><span class="line">  <span class="keyword">using</span> TaskGroupContinuationImpl = std::function&lt;<span class="built_in">Status</span>(<span class="type">size_t</span>)&gt;;</span><br><span class="line">  <span class="keyword">using</span> ScheduleImpl = std::function&lt;<span class="built_in">Status</span>(TaskGroupContinuationImpl)&gt;;</span><br><span class="line">  <span class="keyword">using</span> AbortContinuationImpl = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">TaskScheduler</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="comment">// Order in which task groups are registered represents priorities of their tasks</span></span><br><span class="line">  <span class="comment">// (the first group has the highest priority).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Returns task group identifier that is used to request operations on the task group.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">RegisterTaskGroup</span><span class="params">(TaskImpl task_impl,</span></span></span><br><span class="line"><span class="params"><span class="function">                                TaskGroupContinuationImpl cont_impl)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RegisterEnd</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// total_num_tasks may be zero, in which case task group continuation will be executed</span></span><br><span class="line">  <span class="comment">// immediately</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">StartTaskGroup</span><span class="params">(<span class="type">size_t</span> thread_id, <span class="type">int</span> group_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">int64_t</span> total_num_tasks)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Execute given number of tasks immediately using caller thread</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">ExecuteMore</span><span class="params">(<span class="type">size_t</span> thread_id, <span class="type">int</span> num_tasks_to_execute,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">bool</span> execute_all)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Begin scheduling tasks using provided callback and</span></span><br><span class="line">  <span class="comment">// the limit on the number of in-flight tasks at any moment.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Scheduling will continue as long as there are waiting tasks.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// It will automatically resume whenever new task group gets started.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">StartScheduling</span><span class="params">(<span class="type">size_t</span> thread_id, ScheduleImpl schedule_impl,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">int</span> num_concurrent_tasks, <span class="type">bool</span> use_sync_execution)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Abort scheduling and execution.</span></span><br><span class="line">  <span class="comment">// Used in case of being notified about unrecoverable error for the entire query.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Abort</span><span class="params">(AbortContinuationImpl impl)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> std::unique_ptr&lt;TaskScheduler&gt; <span class="title">Make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么这里的内部逻辑是什么样的呢？之前被馒头总带着看了这个 patch: <a target="_blank" rel="noopener" href="https://github.com/apache/arrow/pull/45268">https://github.com/apache/arrow/pull/45268</a></p>
<p>我还是偷懒直接贴一下成员:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Task group state transitions progress one way.</span></span><br><span class="line">  <span class="comment">// Seeing an old version of the state by a thread is a valid situation.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">enum class</span> <span class="title class_">TaskGroupState</span> : <span class="type">int</span> &#123;</span><br><span class="line">    NOT_READY,</span><br><span class="line">    READY,</span><br><span class="line">    ALL_TASKS_STARTED,</span><br><span class="line">    ALL_TASKS_FINISHED</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">TaskGroup</span> &#123;</span><br><span class="line">    <span class="built_in">TaskGroup</span>(TaskImpl task_impl, TaskGroupContinuationImpl cont_impl)</span><br><span class="line">        : <span class="built_in">task_impl_</span>(std::<span class="built_in">move</span>(task_impl)),</span><br><span class="line">          <span class="built_in">cont_impl_</span>(std::<span class="built_in">move</span>(cont_impl)),</span><br><span class="line">          <span class="built_in">state_</span>(TaskGroupState::NOT_READY),</span><br><span class="line">          <span class="built_in">num_tasks_present_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">      num_tasks_started_.value.<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">      num_tasks_finished_.value.<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">TaskGroup</span>(<span class="type">const</span> TaskGroup&amp; src)</span><br><span class="line">        : <span class="built_in">task_impl_</span>(src.task_impl_),</span><br><span class="line">          <span class="built_in">cont_impl_</span>(src.cont_impl_),</span><br><span class="line">          <span class="built_in">state_</span>(TaskGroupState::NOT_READY),</span><br><span class="line">          <span class="built_in">num_tasks_present_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">ARROW_DCHECK</span>(src.state_ == TaskGroupState::NOT_READY);</span><br><span class="line">      num_tasks_started_.value.<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">      num_tasks_finished_.value.<span class="built_in">store</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TaskImpl task_impl_;</span><br><span class="line">    TaskGroupContinuationImpl cont_impl_;</span><br><span class="line"></span><br><span class="line">    TaskGroupState state_;</span><br><span class="line">    <span class="type">int64_t</span> num_tasks_present_;</span><br><span class="line"></span><br><span class="line">    AtomicWithPadding&lt;<span class="type">int64_t</span>&gt; num_tasks_started_;</span><br><span class="line">    AtomicWithPadding&lt;<span class="type">int64_t</span>&gt; num_tasks_finished_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最多允许同时运行的任务数</span></span><br><span class="line">  <span class="type">int</span> num_concurrent_tasks_;</span><br><span class="line">  <span class="comment">// schedule 函数，调度的时候会发给 AsyncTaskScheduler</span></span><br><span class="line">  ScheduleImpl schedule_impl_;</span><br><span class="line">  <span class="comment">// 外部主动调用 abort 的时候设置的 callback</span></span><br><span class="line">  AbortContinuationImpl abort_cont_impl_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有的 TaskGroup</span></span><br><span class="line">  std::vector&lt;TaskGroup&gt; task_groups_;</span><br><span class="line">  <span class="type">bool</span> register_finished_;</span><br><span class="line">  std::mutex mutex_;  <span class="comment">// Mutex protecting task_groups_ (state_ and num_tasks_present_</span></span><br><span class="line">                      <span class="comment">// fields) and register_finished_ flag</span></span><br><span class="line"></span><br><span class="line">  AtomicWithPadding&lt;<span class="type">bool</span>&gt; aborted_;</span><br><span class="line">  <span class="comment">// 最大为 `num_concurrent_tasks_`，表示最大可用的剩余并发数</span></span><br><span class="line">  AtomicWithPadding&lt;<span class="type">int</span>&gt; num_tasks_to_schedule_;</span><br><span class="line">  <span class="comment">// If a task group adds tasks it&#x27;s possible for a thread inside</span></span><br><span class="line">  <span class="comment">// ScheduleMore to miss this fact.  This serves as a flag to</span></span><br><span class="line">  <span class="comment">// notify the scheduling thread that it might need to make</span></span><br><span class="line">  <span class="comment">// another pass through the scheduler</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 在数次调用之中，是否有新的 StartTaskGroup 插入了, 用来防止丢失调度机会</span></span><br><span class="line">  AtomicWithPadding&lt;<span class="type">bool</span>&gt; tasks_added_recently_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基本上 TaskScheduler 就是不停靠 fetch 任务数 -&gt; 找到任务组 -&gt; 调度任务这样的流程来执行了。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AF%E7%9E%B0-acero-QueryContext"><span class="toc-number">1.</span> <span class="toc-text">俯瞰 acero::QueryContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncTaskScheduler"><span class="toc-number">2.</span> <span class="toc-text">AsyncTaskScheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AddAsyncGenerator"><span class="toc-number">2.1.</span> <span class="toc-text">AddAsyncGenerator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThrottledAsyncTaskScheduler"><span class="toc-number">2.2.</span> <span class="toc-text">ThrottledAsyncTaskScheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Future-%E7%9A%84-TryAddCallback-%E8%AF%AD%E4%B9%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">Future 的 TryAddCallback 语义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AsyncTaskGroup"><span class="toc-number">2.3.</span> <span class="toc-text">AsyncTaskGroup</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TaskScheduler"><span class="toc-number">3.</span> <span class="toc-text">TaskScheduler</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&text=Acero Task Scheduler"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&title=Acero Task Scheduler"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&is_video=false&description=Acero Task Scheduler"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Acero Task Scheduler&body=Check out this article: http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&title=Acero Task Scheduler"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&title=Acero Task Scheduler"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&title=Acero Task Scheduler"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&title=Acero Task Scheduler"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&name=Acero Task Scheduler&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://blog.mwish.me/2025/02/19/Acero-Task-Scheduler/&t=Acero Task Scheduler"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2022-2025
    mwish
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/search/">搜索</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FL51GBW6JT"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FL51GBW6JT');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
